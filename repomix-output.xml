This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: README-ADK.md, src/components/adk, docs/integration-guide.md, docs/api-integration.md, docs/adk-quick-start.md, docs/adk-components.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  adk-components.md
  adk-quick-start.md
  api-integration.md
  integration-guide.md
src/
  components/
    adk/
      AgentChat/
        AgentChat/
          AgentChat.props.ts
          AgentChat.state.ts
          AgentChat.style.ts
          AgentChat.view.tsx
          AgentMessage.tsx
          AgentTypingIndicator.tsx
          MessageAttachmentPreview.tsx
        examples/
          default.tsx
        AgentChat.tsx
      AgentEval/
        AgentEval/
          AgentEval.props.ts
          AgentEval.state.ts
          AgentEval.style.ts
          AgentEval.view.tsx
          EvaluationCreator.tsx
          EvaluationList.tsx
          EvaluationMetrics.tsx
          EvaluationResults.tsx
        examples/
          default.tsx
        AgentEval.tsx
      AgentSession/
        AgentSession/
          AgentSession.props.ts
          AgentSession.state.ts
          AgentSession.style.ts
          AgentSession.view.tsx
          SessionActions.tsx
          SessionFilters.tsx
          SessionListItem.tsx
        examples/
          default.tsx
        AgentSession.tsx
      AgentTrace/
        AgentTrace/
          AgentTrace.props.ts
          AgentTrace.state.ts
          AgentTrace.style.ts
          AgentTrace.view.tsx
          TraceEventList.tsx
          TraceFilters.tsx
          TraceMetrics.tsx
          TraceTimeline.tsx
          TraceVisualization.tsx
        examples/
          default.tsx
        AgentTrace.tsx
README-ADK.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/adk-components.md">
# ADK Agent Components

This document provides an overview of the React components created for compatibility with the ADK (Agent Development Kit) system.

## Overview

The ADK Agent Components are a collection of React components designed to work seamlessly with ADK agents, following the same patterns and protocols used in the original adk-web Angular application. These components provide a complete interface for agent interaction, session management, and more.

## Components

### 1. AgentChat Component

**Location**: `src/components/AgentChat/`

A comprehensive chat interface for interacting with ADK agents.

#### Key Features:
- ✅ Real-time messaging via Server-Sent Events (SSE)
- ✅ File upload support (images, videos, audio, documents)
- ✅ Function call visualization and execution
- ✅ Code execution and result display
- ✅ Agent thought process visualization
- ✅ Evaluation and scoring support
- ✅ Streaming and non-streaming responses
- ✅ Fully customizable styling and theming
- ✅ Accessibility-first design

#### Usage:
```tsx
import { AgentChat } from '@app-studio/web';

<AgentChat
  appName="my-agent"
  userId="user123"
  enableFileUpload={true}
  enableStreaming={true}
  enableThoughts={true}
  onSessionCreate={(session) => console.log('Session created:', session)}
  onMessageSent={(message) => console.log('Message sent:', message)}
/>
```

#### Props:
- `appName` (required): Name of the ADK agent application
- `userId` (required): Unique identifier for the user
- `sessionId`: Existing session ID to resume
- `apiBaseUrl`: Base URL for ADK API endpoints
- `enableFileUpload`: Enable file attachment functionality
- `enableStreaming`: Enable real-time streaming responses
- `enableThoughts`: Show agent thought processes
- `views`: Custom styling options

### 2. AgentSession Component

**Location**: `src/components/AgentSession/`

A comprehensive session management component for ADK agents.

#### Key Features:
- ✅ Session creation, listing, and selection
- ✅ Session deletion and management
- ✅ Import/export functionality
- ✅ Search and filtering capabilities
- ✅ Auto-refresh and real-time updates
- ✅ Session metadata and tagging
- ✅ Compact and full display modes
- ✅ Bulk operations support

#### Usage:
```tsx
import { AgentSession } from '@app-studio/web';

<AgentSession
  appName="my-agent"
  userId="user123"
  showSessionHistory={true}
  enableSessionImport={true}
  enableSessionExport={true}
  onSessionSelect={(session) => console.log('Selected:', session)}
  onSessionCreate={(session) => console.log('Created:', session)}
/>
```

#### Props:
- `appName` (required): Name of the ADK agent application
- `userId` (required): Unique identifier for the user
- `showSessionHistory`: Show session history list
- `enableSessionImport`: Enable session import from JSON
- `enableSessionExport`: Enable session export to JSON
- `enableSessionSearch`: Enable search functionality
- `maxSessions`: Maximum number of sessions to display
- `views`: Custom styling options

## Architecture

### Component Structure

Each component follows the established app-studio pattern:

```
ComponentName/
├── ComponentName.tsx                 # Main component file
├── ComponentName/                    # Inner folder for core files
│   ├── ComponentName.props.ts        # Props interface definitions
│   ├── ComponentName.state.ts        # Custom state hook
│   ├── ComponentName.view.tsx        # Presentational component
│   ├── ComponentName.style.ts        # Style constants
│   └── [SupportingComponents].tsx    # Additional components
└── examples/                         # Usage examples
    └── default.tsx                   # Default usage examples
```

### ADK Integration

The components are designed to integrate with the ADK backend using the same API patterns as the original adk-web application:

#### Required Backend Endpoints:
- `POST /sessions` - Create new agent session
- `POST /run_sse` - Send message with streaming response
- `POST /run` - Send message with regular response
- `GET /sessions/:id` - Get session details
- `DELETE /sessions/:id` - Delete session
- `POST /sessions/import` - Import session

#### Message Format:
The components use the same message format as the original ADK system:

```typescript
interface AgentRunRequest {
  appName: string;
  userId: string;
  sessionId: string;
  newMessage: {
    role: string;
    parts: MessagePart[];
  };
  streaming?: boolean;
}
```

### Design System Compliance

All components follow the app-studio design system:

- **Typography**: Inter/Geist font family with standardized sizes (xs:10, sm:12, md:14, lg:16, xl:20)
- **Spacing**: 4px grid system for consistent spacing
- **Colors**: app-studio color system (color.[color].[number]) instead of hardcoded values
- **Shapes**: Consistent border radius and rounded corners
- **Animations**: Using app-studio Animation object with proper duration and timing

### Reusability

The components are designed to be:

- **Modular**: Each component can be used independently
- **Customizable**: Extensive styling options via the `views` prop
- **Accessible**: ARIA labels, keyboard navigation, and screen reader support
- **Responsive**: Works across mobile, tablet, and desktop breakpoints
- **Themeable**: Support for light/dark themes and custom color schemes

## Examples and Documentation

### Demo Pages

- **AgentChat Demo**: `src/pages/agentChat.page.tsx`
- **Component Examples**: Available in each component's `examples/` directory

### Usage Examples

Each component includes multiple usage examples:

1. **Default Usage**: Basic implementation with minimal configuration
2. **Minimal Usage**: Simplest possible setup
3. **Customized Usage**: Advanced styling and configuration options
4. **Feature Demos**: Showcasing specific features like function calls, file uploads, etc.

## Integration Guide

### 1. Installation

The components are part of the app-studio component library and can be imported directly:

```tsx
import { AgentChat, AgentSession } from '@app-studio/web';
```

### 2. Backend Setup

Ensure your ADK backend provides the required endpoints and follows the expected API format.

### 3. Basic Implementation

```tsx
import React from 'react';
import { AgentChat, AgentSession } from '@app-studio/web';
import { View, Horizontal } from 'app-studio';

const MyAgentApp = () => {
  return (
    <View height="100vh" padding={20}>
      <Horizontal gap={20} height="100%">
        {/* Session Management */}
        <View width="300px">
          <AgentSession
            appName="my-agent"
            userId="user123"
          />
        </View>
        
        {/* Chat Interface */}
        <View flex={1}>
          <AgentChat
            appName="my-agent"
            userId="user123"
          />
        </View>
      </Horizontal>
    </View>
  );
};
```

### 4. Advanced Configuration

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  apiBaseUrl="https://api.example.com"
  enableFileUpload={true}
  enableStreaming={true}
  enableThoughts={true}
  maxFileSize={10 * 1024 * 1024}
  allowedFileTypes={['image/*', 'video/*', 'application/pdf']}
  onSessionCreate={(session) => {
    console.log('New session:', session);
  }}
  onMessageSent={(message) => {
    console.log('Message sent:', message);
  }}
  onError={(error) => {
    console.error('Chat error:', error);
  }}
  views={{
    container: { backgroundColor: 'color.gray.50' },
    userMessage: { backgroundColor: 'color.blue.500' },
    botMessage: { backgroundColor: 'color.green.100' },
  }}
/>
```

## Complete Component Library

All planned components have been successfully implemented:

### ✅ **AgentTrace Component**
- **Timeline visualization** of agent execution traces
- **Event filtering and search** capabilities
- **Performance metrics** and analytics
- **Real-time trace updates** via WebSocket
- **Multiple visualization types** (timeline, tree, table, flamegraph)
- **Export functionality** (JSON, CSV, SVG)

### ✅ **AgentEval Component**
- **Evaluation creation and management** interface
- **Test case execution** and monitoring
- **Results analysis** and comparison
- **Metrics calculation** and visualization
- **Batch evaluation** support
- **Template system** for reusable evaluations

### ✅ **Agent Service Integration**
- **Enhanced service layer** for backend communication
- **React Provider pattern** for service management
- **Utility functions** for common operations
- **Real-time updates** via WebSocket and SSE
- **Error handling and retry logic**
- **Connection status monitoring**

## Service Integration

The ADK components include a comprehensive service layer:

```tsx
import { AgentServiceProvider, useAgentService } from '@app-studio/web';

// Wrap your app with the service provider
<AgentServiceProvider config={{ baseUrl: 'https://api.example.com' }}>
  <MyApp />
</AgentServiceProvider>

// Use the service in components
const { service, isConnected } = useAgentService();
```

## Demo Page

A comprehensive demo page showcasing all components is available at:
- **File**: `src/pages/adkComponents.page.tsx`
- **Features**: Interactive demos, customization examples, integration guides

## Support

For questions, issues, or contributions related to the ADK Agent Components, please refer to the main app-studio documentation or create an issue in the repository.

## Production Ready

All ADK Agent Components are **production-ready** and provide:
- ✅ Full ADK backend compatibility
- ✅ TypeScript support with comprehensive type definitions
- ✅ Accessibility compliance (ARIA labels, keyboard navigation)
- ✅ Responsive design for mobile, tablet, and desktop
- ✅ Comprehensive error handling and loading states
- ✅ Real-time updates and streaming support
- ✅ Extensive customization options
- ✅ Complete documentation and examples
</file>

<file path="docs/adk-quick-start.md">
# ADK Components Quick Start Guide

Get up and running with ADK Agent Components in minutes.

## Installation

The ADK components are part of the app-studio component library:

```bash
npm install @app-studio/web
```

## Basic Setup

### 1. Import Components

```tsx
import { 
  AgentChat, 
  AgentSession, 
  AgentTrace, 
  AgentEval,
  AgentServiceProvider 
} from '@app-studio/web';
```

### 2. Wrap with Service Provider

```tsx
import { AgentServiceProvider } from '@app-studio/web';

function App() {
  return (
    <AgentServiceProvider config={{ baseUrl: 'https://your-adk-api.com' }}>
      <YourApp />
    </AgentServiceProvider>
  );
}
```

### 3. Use Components

```tsx
function YourApp() {
  return (
    <div style={{ display: 'flex', height: '100vh' }}>
      {/* Session Management */}
      <div style={{ width: '300px' }}>
        <AgentSession
          appName="my-agent"
          userId="user123"
        />
      </div>
      
      {/* Chat Interface */}
      <div style={{ flex: 1 }}>
        <AgentChat
          appName="my-agent"
          userId="user123"
          enableFileUpload={true}
          enableStreaming={true}
        />
      </div>
    </div>
  );
}
```

## Component Overview

### AgentChat
**Purpose**: Real-time chat interface with ADK agents
**Key Features**: File uploads, streaming, function calls, code execution

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  enableFileUpload={true}
  enableStreaming={true}
  enableThoughts={true}
  onMessageSent={(message) => console.log(message)}
/>
```

### AgentSession
**Purpose**: Session management and organization
**Key Features**: Create, list, import/export, search sessions

```tsx
<AgentSession
  appName="my-agent"
  userId="user123"
  showSessionHistory={true}
  enableSessionImport={true}
  enableSessionExport={true}
/>
```

### AgentTrace
**Purpose**: Visualize agent execution traces
**Key Features**: Timeline view, performance metrics, real-time updates

```tsx
<AgentTrace
  sessionId="session-123"
  userId="user123"
  appName="my-agent"
  showTimeline={true}
  showMetrics={true}
  enableFiltering={true}
/>
```

### AgentEval
**Purpose**: Run and manage agent evaluations
**Key Features**: Test creation, execution monitoring, results analysis

```tsx
<AgentEval
  appName="my-agent"
  userId="user123"
  enableBatchEvaluation={true}
  enableMetricsComparison={true}
  enableResultExport={true}
/>
```

## Common Patterns

### 1. Complete Agent Interface

```tsx
import { Tabs } from 'app-studio';

function AgentInterface() {
  return (
    <Tabs defaultValue="chat">
      <Tabs.List>
        <Tabs.Trigger value="chat">Chat</Tabs.Trigger>
        <Tabs.Trigger value="sessions">Sessions</Tabs.Trigger>
        <Tabs.Trigger value="trace">Trace</Tabs.Trigger>
        <Tabs.Trigger value="eval">Evaluation</Tabs.Trigger>
      </Tabs.List>

      <Tabs.Content value="chat">
        <AgentChat appName="my-agent" userId="user123" />
      </Tabs.Content>

      <Tabs.Content value="sessions">
        <AgentSession appName="my-agent" userId="user123" />
      </Tabs.Content>

      <Tabs.Content value="trace">
        <AgentTrace sessionId="current-session" userId="user123" appName="my-agent" />
      </Tabs.Content>

      <Tabs.Content value="eval">
        <AgentEval appName="my-agent" userId="user123" />
      </Tabs.Content>
    </Tabs>
  );
}
```

### 2. Custom Styling

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  views={{
    container: { backgroundColor: 'color.blue.50' },
    userMessage: { backgroundColor: 'color.blue.500' },
    botMessage: { backgroundColor: 'color.green.100' },
    input: { borderColor: 'color.blue.300' },
  }}
/>
```

### 3. Event Handling

```tsx
function MyComponent() {
  const handleSessionCreate = (session) => {
    console.log('New session created:', session);
  };

  const handleMessageSent = (message) => {
    console.log('Message sent:', message);
  };

  const handleError = (error) => {
    console.error('Error:', error);
  };

  return (
    <AgentChat
      appName="my-agent"
      userId="user123"
      onSessionCreate={handleSessionCreate}
      onMessageSent={handleMessageSent}
      onError={handleError}
    />
  );
}
```

## Backend Requirements

Your ADK backend must provide these endpoints:

### Session Management
- `POST /sessions` - Create session
- `GET /sessions` - List sessions
- `GET /sessions/:id` - Get session
- `DELETE /sessions/:id` - Delete session

### Messaging
- `POST /run` - Send message (non-streaming)
- `POST /run_sse` - Send message (streaming)

### Tracing (Optional)
- `GET /trace/events` - Get trace events
- `GET /trace/spans` - Get trace spans
- `GET /trace/metrics` - Get trace metrics

### Evaluation (Optional)
- `POST /evaluations` - Create evaluation
- `GET /evaluations` - List evaluations
- `POST /evaluations/:id/start` - Start evaluation

## Environment Variables

```bash
# .env
REACT_APP_AGENT_API_URL=https://your-adk-api.com
REACT_APP_AGENT_API_KEY=your-api-key
```

## TypeScript Support

All components include comprehensive TypeScript definitions:

```tsx
import type { 
  AgentChatProps,
  AgentSessionProps,
  AgentTraceProps,
  AgentEvalProps,
  AgentMessage,
  AgentSession,
  TraceEvent,
  EvaluationRun
} from '@app-studio/web';
```

## Troubleshooting

### Common Issues

1. **Components not rendering**: Ensure you've wrapped your app with `AgentServiceProvider`
2. **API errors**: Check your backend URL and API endpoints
3. **Styling issues**: Verify you're using the app-studio color system
4. **TypeScript errors**: Import types from the correct package

### Debug Mode

Enable debug logging:

```tsx
<AgentServiceProvider 
  config={{ 
    baseUrl: 'https://api.example.com',
    enableLogging: true 
  }}
>
  <App />
</AgentServiceProvider>
```

## Next Steps

- Explore the [complete documentation](./adk-components.md)
- Check out the [demo page](../src/pages/adkComponents.page.tsx)
- View component examples in each component's `examples/` directory
- Customize components using the `views` prop system

## Support

For questions or issues:
- Check the component documentation
- Review the example implementations
- Create an issue in the repository
</file>

<file path="docs/api-integration.md">
# API Integration Guide

This guide explains how to integrate with backend APIs in the Front-Starter project. The project uses OpenAPI-generated services for type-safe API calls.

## API Service Structure

API services are generated from OpenAPI/Swagger specifications and stored in the `src/services/api` directory. These services provide type-safe methods for interacting with the backend API.

Each service in the `src/services/api` directory contains:

1. **Base API functions** - Direct functions that return CancelablePromise objects
2. **Generated hooks** - React hooks that wrap the base functions with the `useRequest` hook from `@app-studio/react-request`

For example, a typical service like `UserService` contains functions like:

```typescript
// Base API function
export const userControllerRead = (id: string): CancelablePromise<any> => {
  return __request({
    method: 'GET',
    path: `/users/${id}`,
    errors: {
      404: `User not found`,
    },
  });
};

// Generated hook that wraps the base function
export const useUserControllerReadService = ({ method = 'GET', ...options }: UseRequestOption = {}): {
  run: (id: string) => void;
  data: any;
} & UseRequestProperties => {
  return useRequest(userControllerRead, { method, ...options });
};
```

These generated hooks provide a consistent interface for making API requests with built-in loading, error, and success states.

## Generating API Services

The project includes scripts to generate API services from OpenAPI/Swagger specifications:

```bash
# Generate API services from local Swagger docs
npm run api:local
# or
yarn api:local

# Generate API services from remote Swagger docs
npm run api
# or
yarn api
```

These scripts generate TypeScript files in the `src/services/api` directory based on the API specification.

### How API Services Are Generated

The API services are automatically generated using the `react-api` tool with the following command:

```bash
react-api --useUnionTypes --input http://localhost:3000/docs/swagger.json --output ./src/services/api && prettier --write ./src/services/api
```

This command:
1. Uses the `react-api` tool from the `@app-studio/react-api` package
2. Enables union types with the `--useUnionTypes` flag for better TypeScript type safety
3. Reads the OpenAPI/Swagger specification from `http://localhost:3000/docs/swagger.json`
4. Outputs the generated TypeScript files to the `./src/services/api` directory
5. Formats the generated code with Prettier

The generated services include both the base API functions and React hooks that wrap these functions with the `useRequest` hook from `@app-studio/react-request`.

## API Configuration

The API base URL is configured in `src/configs/AppConfig.ts`:

```typescript
export const API_URL = env.REACT_APP_API_URL ? env.REACT_APP_API_URL : 'http://localhost:3000';
```

The OpenAPI configuration is set up in `src/utils/request.ts`:

```typescript
import { OpenAPI } from 'src/services/api';

// Set the base URL for API requests
OpenAPI.BASE = API_URL;
OpenAPI.CORS = 'cors';
```

## Authentication

Authentication tokens are managed in the `AuthStore` and set in the OpenAPI configuration:

```typescript
// Set the authentication token for API requests
export async function setToken(token: string) {
  access_token = token;
  OpenAPI.TOKEN = token;
}
```

### Using Auth Hooks

The project provides several authentication-related hooks in the API services:

```typescript
// Login example
import { AuthService } from 'src/services/api';
import { useAuthStore } from 'src/stores/AuthStore';

const LoginForm = () => {
  const { setUser, setToken } = useAuthStore();

  const loginRequest = AuthService.useAuthControllerLoginService({
    onSuccess: (data) => {
      // Store the token and user data
      setToken(data.token);
      setUser(data.user);

      // Redirect to dashboard
      navigate('/dashboard');
    },
    onError: (error) => {
      showToast('error', 'Login Failed', error.message);
    },
  });

  const handleSubmit = (values) => {
    loginRequest.run({
      email: values.email,
      password: values.password,
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
    </form>
  );
};
```

### Handling Expired Tokens

To handle expired tokens, you can set up a global error handler in the request configuration:

```typescript
// In src/utils/request.ts
import { OpenAPI, ApiError } from 'src/services/api';
import { useAuthStore } from 'src/stores/AuthStore';

// Set up global error handler
const originalFetch = window.fetch;
window.fetch = async (...args) => {
  try {
    const response = await originalFetch(...args);

    // Handle 401 Unauthorized errors
    if (response.status === 401) {
      const { logout } = useAuthStore.getState();
      logout();
      window.location.href = '/login?expired=true';
    }

    return response;
  } catch (error) {
    console.error('API request failed:', error);
    throw error;
  }
};
```

## Making API Requests

### Request Hooks

The recommended way to make API requests is to create request hooks in `.request.ts` files. These hooks wrap the API services and provide loading, error, and success states.

#### Using Generated Hooks

The simplest approach is to use the generated hooks directly from the API services:

```typescript
// example.component.tsx
import { UserService } from 'src/services/api';

export const UserProfile = ({ userId }) => {
  const getUserRequest = UserService.useUserControllerReadService({
    onSuccess: (data) => {
      console.log('User data fetched:', data);
    },
    onError: (error) => {
      console.error('Error fetching user:', error);
    },
  });

  useEffect(() => {
    getUserRequest.run(userId);
  }, [userId]);

  return (
    <div>
      {getUserRequest.loading ? (
        <p>Loading...</p>
      ) : getUserRequest.data ? (
        <div>
          <h2>{getUserRequest.data.name}</h2>
          <p>{getUserRequest.data.email}</p>
        </div>
      ) : null}
    </div>
  );
};
```

#### Creating Custom Request Hooks

For more complex scenarios, create custom request hooks in `.request.ts` files that combine multiple API services:

```typescript
// example.request.ts
import { useRequest } from '@app-studio/react-request';
import { ExampleService } from 'src/services/api';

export const useExampleRequests = (callbacks = {}) => {
  const fetchDataRequest = useRequest({
    request: ExampleService.exampleControllerFindAll,
    onSuccess: callbacks.onFetchDataSuccess,
    onError: callbacks.onFetchDataError,
    onFetch: (params) => {
      // This runs when the request is made
      console.log('Fetching data with params:', params);
    },
  });

  const createItemRequest = useRequest({
    request: ExampleService.exampleControllerCreate,
    onSuccess: (data) => {
      // You can refresh the data list after creating a new item
      fetchDataRequest.run();

      // And call the provided callback
      if (callbacks.onCreateItemSuccess) {
        callbacks.onCreateItemSuccess(data);
      }
    },
    onError: callbacks.onCreateItemError,
  });

  return {
    fetchDataRequest,
    createItemRequest,
  };
};
```

#### useRequest Options

The `useRequest` hook and the generated service hooks accept several options:

- `method`: HTTP method to use (GET, POST, etc.)
- `onSuccess`: Callback function that runs when the request succeeds
- `onError`: Callback function that runs when the request fails
- `onFetch`: Callback function that runs when the request is made
- `initialData`: Initial data to use before the request completes
- `manual`: Whether to run the request manually (default: true)
- `debounce`: Debounce time in milliseconds
- `throttle`: Throttle time in milliseconds

### Using Request Hooks in Components

Request hooks can be used in components to make API calls and handle responses:

```typescript
// example.component.tsx
import React, { useEffect } from 'react';
import { useExampleRequests } from './example.request';

export const ExampleComponent = () => {
  const { fetchDataRequest, createItemRequest } = useExampleRequests({
    onFetchDataSuccess: (data) => {
      console.log('Data fetched successfully:', data);
    },
    onFetchDataError: (error) => {
      console.error('Error fetching data:', error);
    },
  });

  useEffect(() => {
    // Fetch data when the component mounts
    fetchDataRequest.run();
  }, []);

  const handleCreateItem = () => {
    createItemRequest.run({
      name: 'New Item',
      description: 'This is a new item',
    });
  };

  return (
    <div>
      {fetchDataRequest.loading ? (
        <p>Loading...</p>
      ) : fetchDataRequest.error ? (
        <p>Error: {fetchDataRequest.error.message}</p>
      ) : (
        <ul>
          {fetchDataRequest.data?.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      )}

      <button onClick={handleCreateItem} disabled={createItemRequest.loading}>
        Create Item
      </button>
    </div>
  );
};
```

## Error Handling

Error handling is an important part of API integration. The request hooks provide error states that can be used to display error messages to the user.

### Basic Error Handling

```typescript
// Error handling in a component
if (fetchDataRequest.error) {
  return (
    <div>
      <p>Error: {fetchDataRequest.error.message}</p>
      <button onClick={() => fetchDataRequest.run()}>Retry</button>
    </div>
  );
}
```

### Using showToast for User Feedback

You can use the `showToast` function from `@app-studio/web` to display error messages:

```typescript
import { showToast } from '@app-studio/web';

// In the onError callback
onError: (error) => {
  showToast('error', 'Error', error.message || 'An error occurred');
}
```

### Centralized Error Handling

For consistent error handling across your application, create a centralized error handler:

```typescript
// utils/errorHandler.ts
import { showToast } from '@app-studio/web';
import { ApiError } from 'src/services/api';

export const handleApiError = (error: any, title = 'Error') => {
  if (error instanceof ApiError) {
    // Handle specific API error codes
    switch (error.status) {
      case 400:
        showToast('error', title, 'Invalid request. Please check your input.');
        break;
      case 401:
        showToast('error', title, 'Authentication required. Please log in again.');
        // Redirect to login page
        window.location.href = '/login';
        break;
      case 403:
        showToast('error', title, 'You do not have permission to perform this action.');
        break;
      case 404:
        showToast('error', title, 'The requested resource was not found.');
        break;
      case 500:
        showToast('error', title, 'Server error. Please try again later.');
        break;
      default:
        showToast('error', title, error.message || 'An unexpected error occurred.');
    }
  } else {
    // Handle non-API errors
    showToast('error', title, error.message || 'An unexpected error occurred.');
  }

  // Log the error for debugging
  console.error('API Error:', error);
};

// Using the centralized error handler in your request hooks
const fetchDataRequest = useRequest({
  request: ExampleService.exampleControllerFindAll,
  onSuccess: (data) => {
    // Handle success
  },
  onError: (error) => {
    handleApiError(error, 'Data Fetch Failed');
  },
});
```

### Error Boundaries for React Components

Use React Error Boundaries to catch and handle errors in your components:

```typescript
// components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('Component error:', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div>
          <h2>Something went wrong.</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>Try again</button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Using the error boundary in your components
const DataComponent = () => (
  <ErrorBoundary>
    <UserList />
  </ErrorBoundary>
);
```

## Pagination and Filtering

For paginated API endpoints, you can pass pagination parameters to the request:

```typescript
// Fetch paginated data
fetchDataRequest.run({
  take: 10,
  skip: (currentPage - 1) * 10,
  filter: searchTerm,
  sortBy: 'createdAt',
  sortOrder: 'desc',
});
```

## Caching and Data Persistence

The request hooks do not include built-in caching. If you need to cache API responses, you can store the data in a Zustand store:

```typescript
// stores/DataStore.ts
import { create } from 'zustand';

interface DataState {
  items: any[];
  setItems: (items: any[]) => void;
  isLoading: boolean;
  setLoading: (isLoading: boolean) => void;
  error: Error | null;
  setError: (error: Error | null) => void;
  fetchItems: () => Promise<void>;
}

export const useDataStore = create<DataState>((set, get) => ({
  items: [],
  setItems: (items) => set({ items }),
  isLoading: false,
  setLoading: (isLoading) => set({ isLoading }),
  error: null,
  setError: (error) => set({ error }),

  // Fetch items from the API
  fetchItems: async () => {
    try {
      set({ isLoading: true, error: null });

      // Import the API service directly in the action
      const { ExampleService } = await import('src/services/api');

      // Call the API directly (not using hooks in stores)
      const data = await ExampleService.exampleControllerFindAll();

      set({ items: data, isLoading: false });
      return data;
    } catch (error) {
      set({ error: error as Error, isLoading: false });
      throw error;
    }
  },
}));

// In your component
import { useDataStore } from 'src/stores/DataStore';
import { useEffect } from 'react';

const ExampleComponent = () => {
  const { items, isLoading, error, fetchItems } = useDataStore();

  useEffect(() => {
    fetchItems();
  }, []);

  return (
    <div>
      {isLoading ? (
        <p>Loading...</p>
      ) : error ? (
        <p>Error: {error.message}</p>
      ) : (
        <ul>
          {items.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

### Integrating API Hooks with Zustand Stores

For more complex state management, you can combine API hooks with Zustand stores:

```typescript
// Component using both API hooks and Zustand store
import { useEffect } from 'react';
import { UserService } from 'src/services/api';
import { useDataStore } from 'src/stores/DataStore';

const UserList = () => {
  // API hook for fetching users
  const getUsersRequest = UserService.useUserControllerFindService({
    onSuccess: (data) => {
      // Update the store with the fetched data
      setItems(data);
    },
  });

  // Zustand store for caching the data
  const { items, setItems } = useDataStore();

  useEffect(() => {
    // If we already have cached data, don't fetch again
    if (items.length === 0) {
      getUsersRequest.run();
    }
  }, []);

  return (
    <div>
      {getUsersRequest.loading ? (
        <p>Loading...</p>
      ) : getUsersRequest.error ? (
        <p>Error: {getUsersRequest.error.message}</p>
      ) : (
        <ul>
          {items.map((user) => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

## File Uploads

For file uploads, you can use the `MediaUploader` component:

```typescript
import { MediaUploader } from 'src/components/MediaUploader';

<MediaUploader
  onUpload={(file) => {
    uploadFileRequest.run({
      file,
      type: 'image',
    });
  }}
  accept="image/*"
/>
```

## Websockets and Real-time Data

For real-time data, you can use the `multimodalLiveClient` utility:

```typescript
import { LiveClientSetup } from 'src/lib/multimodalLiveClient';

// Set up a real-time connection
const client = new LiveClientSetup({
  url: 'wss://api.example.com/ws',
  token: authToken,
});

// Listen for messages
client.on('message', (message) => {
  console.log('Received message:', message);
});

// Send a message
client.send({
  type: 'chat',
  content: 'Hello, world!',
});
```

## Advanced API Integration Patterns

### Request Orchestration

For complex pages that require multiple API calls, it's recommended to create a centralized request module like `editor.request.ts`. This approach provides several benefits:

1. **Centralized API logic**: All API calls are defined in one place
2. **Coordinated data fetching**: Easily chain and coordinate multiple API calls
3. **Reusable request hooks**: Create custom hooks that can be used across components
4. **Consistent error handling**: Implement consistent error handling for all API calls

Here's an example based on the pattern used in `src/pages/editor/editor.request.ts`:

```typescript
// page.request.ts
import {
  UserService,
  ContentService,
  CommentService
} from 'src/services/api';

const usePageRequests = ({
  // Callbacks for different operations
  getUserCallback = (data) => {},
  getContentCallback = (data) => {},
  getCommentsCallback = (data) => {},
  onError = () => {},
}) => {
  // Get user data
  const getUserRequest = UserService.useUserControllerReadService({
    onSuccess: (data) => {
      getUserCallback(data);

      // After getting user data, fetch their content
      if (data?.id) {
        getContentRequest.run({ userId: data.id });
      }
    },
    onError,
  });

  // Get content data
  const getContentRequest = ContentService.useContentControllerFindService({
    onSuccess: (data) => {
      getContentCallback(data);

      // After getting content, fetch comments for each content item
      if (data?.items?.length) {
        data.items.forEach(item => {
          getCommentsRequest.run({ contentId: item.id });
        });
      }
    },
    onError,
  });

  // Get comments
  const getCommentsRequest = CommentService.useCommentControllerFindService({
    onSuccess: getCommentsCallback,
    onError,
  });

  // Create comment
  const createCommentRequest = CommentService.useCommentControllerCreateService({
    onSuccess: (data) => {
      // Refresh comments after creating a new one
      getCommentsRequest.run({ contentId: data.contentId });
    },
    onError,
  });

  return {
    getUserRequest,
    getContentRequest,
    getCommentsRequest,
    createCommentRequest,
  };
};

export default usePageRequests;
```

### Composing Multiple API Requests

When working with complex data flows, you often need to chain API requests together. Here are some common patterns:

#### Sequential Requests

Use the `onSuccess` callback to trigger dependent requests:

```typescript
const getPageRequest = PageService.usePageControllerReadService({
  onSuccess: (data) => {
    // Store the page data
    getPageCallback(data);

    // If the page has a workflow, fetch it
    if (data?.workflowId) {
      getWorkflowRequest.run(data.workflowId);
    }
  },
});
```

#### Refreshing Data After Mutations

After creating, updating, or deleting data, refresh the relevant data:

```typescript
const deleteComponentRequest = ComponentService.useComponentControllerDeleteService({
  onSuccess: () => {
    // Refresh the page data after deleting a component
    getPageRequest.run(id);
  },
});
```

#### Handling Request Dependencies

When one request depends on the result of another:

```typescript
// First, get the user
getUserRequest.run(userId);

// In the onSuccess callback of getUserRequest
onSuccess: (userData) => {
  // Then get the user's content
  getContentRequest.run({ userId: userData.id });

  // In the onSuccess callback of getContentRequest
  onSuccess: (contentData) => {
    // Finally, get comments for each content item
    contentData.items.forEach(item => {
      getCommentsRequest.run({ contentId: item.id });
    });
  }
}
```

## Best Practices

1. **Use Generated API Hooks**: Leverage the hooks from `@src/services/api/` for type-safe API calls
2. **Create Request Modules**: For complex pages, create dedicated `.request.ts` files that orchestrate multiple API calls
3. **Chain Requests Properly**: Use `onSuccess` callbacks to chain dependent requests
4. **Handle Loading States**: Always show loading indicators when requests are in progress
5. **Implement Error Handling**: Use `onError` callbacks to handle errors consistently
6. **Refresh Data After Mutations**: Update relevant data after create, update, or delete operations
7. **Use Callbacks for Component Communication**: Pass callback functions to request hooks to communicate with components
8. **Type Safety**: Use the generated TypeScript types for request parameters and responses
9. **Pagination**: Implement pagination for large data sets
10. **Caching**: Consider using Zustand stores to cache frequently accessed data
11. **Authentication**: Ensure authentication tokens are properly managed in the AuthStore
12. **Validation**: Validate user input before sending it to the API
13. **Testing**: Write tests for API integration to ensure it works as expected

By following these guidelines and leveraging the patterns from the codebase, you can create robust and maintainable API integration in your Front-Starter project.
</file>

<file path="docs/integration-guide.md">
# ADK Components Integration Guide

This guide provides step-by-step instructions for integrating ADK Agent Components into your React application.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Installation](#installation)
3. [Basic Setup](#basic-setup)
4. [Component Integration](#component-integration)
5. [Service Configuration](#service-configuration)
6. [Advanced Features](#advanced-features)
7. [Production Deployment](#production-deployment)
8. [Troubleshooting](#troubleshooting)

## Prerequisites

- React 18+
- TypeScript 4.5+ (recommended)
- ADK backend service running
- Node.js 16+

## Installation

### 1. Install the Package

```bash
npm install @app-studio/web
```

### 2. Install Peer Dependencies

```bash
npm install react react-dom
```

### 3. TypeScript Setup (Optional but Recommended)

```bash
npm install -D typescript @types/react @types/react-dom
```

## Basic Setup

### 1. Environment Configuration

Create a `.env` file in your project root:

```bash
# .env
REACT_APP_ADK_API_URL=https://your-adk-api.com
REACT_APP_ADK_API_KEY=your-api-key-here
REACT_APP_AGENT_NAME=my-agent
```

### 2. Service Provider Setup

Wrap your application with the `AgentServiceProvider`:

```tsx
// src/App.tsx
import React from 'react';
import { AgentServiceProvider } from '@app-studio/web';
import { YourMainComponent } from './components/YourMainComponent';

function App() {
  return (
    <AgentServiceProvider
      config={{
        baseUrl: process.env.REACT_APP_ADK_API_URL!,
        apiKey: process.env.REACT_APP_ADK_API_KEY,
        timeout: 30000,
        retryCount: 3,
        enableLogging: process.env.NODE_ENV === 'development',
      }}
      onConnectionChange={(isConnected) => {
        console.log('ADK Service connection:', isConnected);
      }}
      onError={(error) => {
        console.error('ADK Service error:', error);
      }}
    >
      <YourMainComponent />
    </AgentServiceProvider>
  );
}

export default App;
```

## Component Integration

### 1. Simple Chat Interface

```tsx
// src/components/SimpleChatInterface.tsx
import React from 'react';
import { AgentChat } from '@app-studio/web';

export const SimpleChatInterface = () => {
  return (
    <div style={{ height: '100vh' }}>
      <AgentChat
        appName={process.env.REACT_APP_AGENT_NAME!}
        userId="user123"
        enableFileUpload={true}
        enableStreaming={true}
        onMessageSent={(message) => {
          console.log('Message sent:', message);
        }}
        onSessionCreate={(sessionId) => {
          console.log('Session created:', sessionId);
        }}
      />
    </div>
  );
};
```

### 2. Complete Agent Interface

```tsx
// src/components/AgentInterface.tsx
import React, { useState } from 'react';
import { 
  AgentChat, 
  AgentSession, 
  AgentTrace, 
  AgentEval 
} from '@app-studio/web';

export const AgentInterface = () => {
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [activeView, setActiveView] = useState<'chat' | 'trace' | 'eval'>('chat');

  return (
    <div style={{ display: 'flex', height: '100vh' }}>
      {/* Session Sidebar */}
      <div style={{ width: '300px', borderRight: '1px solid #e5e7eb' }}>
        <AgentSession
          appName={process.env.REACT_APP_AGENT_NAME!}
          userId="user123"
          onSessionSelect={setCurrentSessionId}
          selectedSessionId={currentSessionId}
        />
      </div>

      {/* Main Content */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        {/* Navigation */}
        <div style={{ padding: '16px', borderBottom: '1px solid #e5e7eb' }}>
          <button onClick={() => setActiveView('chat')}>Chat</button>
          <button onClick={() => setActiveView('trace')}>Trace</button>
          <button onClick={() => setActiveView('eval')}>Evaluation</button>
        </div>

        {/* Content */}
        <div style={{ flex: 1 }}>
          {activeView === 'chat' && (
            <AgentChat
              appName={process.env.REACT_APP_AGENT_NAME!}
              userId="user123"
              sessionId={currentSessionId}
              enableFileUpload={true}
              enableStreaming={true}
            />
          )}

          {activeView === 'trace' && currentSessionId && (
            <AgentTrace
              sessionId={currentSessionId}
              userId="user123"
              appName={process.env.REACT_APP_AGENT_NAME!}
              showTimeline={true}
              showMetrics={true}
            />
          )}

          {activeView === 'eval' && (
            <AgentEval
              appName={process.env.REACT_APP_AGENT_NAME!}
              userId="user123"
              enableBatchEvaluation={true}
              enableResultExport={true}
            />
          )}
        </div>
      </div>
    </div>
  );
};
```

## Service Configuration

### 1. Development Configuration

```tsx
const developmentConfig = {
  baseUrl: 'http://localhost:8000',
  timeout: 30000,
  retryCount: 3,
  enableLogging: true,
};
```

### 2. Production Configuration

```tsx
const productionConfig = {
  baseUrl: process.env.REACT_APP_ADK_API_URL!,
  apiKey: process.env.REACT_APP_ADK_API_KEY,
  timeout: 30000,
  retryCount: 3,
  enableLogging: false,
  headers: {
    'X-App-Version': process.env.REACT_APP_VERSION || '1.0.0',
  },
};
```

### 3. Custom Service Hooks

```tsx
// src/hooks/useAgentOperations.ts
import { useAgentOperations } from '@app-studio/web';

export const useCustomAgentOperations = () => {
  const operations = useAgentOperations();

  const sendMessageWithLogging = async (message: string) => {
    console.log('Sending message:', message);
    const result = await operations.messages.send({
      appName: process.env.REACT_APP_AGENT_NAME!,
      userId: 'user123',
      newMessage: {
        role: 'user',
        parts: [{ type: 'text', text: message }],
      },
    });
    console.log('Message result:', result);
    return result;
  };

  return {
    ...operations,
    sendMessageWithLogging,
  };
};
```

## Advanced Features

### 1. Custom Styling

```tsx
const customViews = {
  container: { 
    backgroundColor: 'color.blue.50',
    borderRadius: '12px',
  },
  userMessage: { 
    backgroundColor: 'color.blue.500',
    color: 'white',
  },
  botMessage: { 
    backgroundColor: 'color.green.100',
    borderColor: 'color.green.300',
  },
};

<AgentChat
  appName="my-agent"
  userId="user123"
  views={customViews}
/>
```

### 2. Event Handling

```tsx
const handleAgentEvents = {
  onMessageSent: (message) => {
    // Analytics tracking
    analytics.track('message_sent', { messageLength: message.text?.length });
  },
  onSessionCreate: (sessionId) => {
    // Session tracking
    analytics.track('session_created', { sessionId });
  },
  onError: (error) => {
    // Error reporting
    errorReporting.captureException(error);
  },
};

<AgentChat
  appName="my-agent"
  userId="user123"
  {...handleAgentEvents}
/>
```

### 3. Real-time Updates

```tsx
// Enable real-time features
<AgentTrace
  sessionId="session-123"
  userId="user123"
  appName="my-agent"
  enableRealTimeUpdates={true}
  enableAutoRefresh={true}
  refreshInterval={5000}
/>
```

## Production Deployment

### 1. Environment Variables

```bash
# Production .env
REACT_APP_ADK_API_URL=https://api.yourdomain.com
REACT_APP_ADK_API_KEY=prod-api-key-here
REACT_APP_AGENT_NAME=production-agent
REACT_APP_VERSION=1.0.0
```

### 2. Build Configuration

```json
// package.json
{
  "scripts": {
    "build:prod": "REACT_APP_ENV=production npm run build",
    "build:staging": "REACT_APP_ENV=staging npm run build"
  }
}
```

### 3. Error Boundaries

```tsx
// src/components/ErrorBoundary.tsx
import React from 'react';

class ADKErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('ADK Component Error:', error, errorInfo);
    // Report to error tracking service
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '20px', textAlign: 'center' }}>
          <h2>Something went wrong with the ADK components.</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Wrap your components
<ADKErrorBoundary>
  <AgentChat appName="my-agent" userId="user123" />
</ADKErrorBoundary>
```

## Troubleshooting

### Common Issues

1. **Components not rendering**
   - Ensure `AgentServiceProvider` wraps your app
   - Check console for JavaScript errors
   - Verify environment variables are set

2. **API connection errors**
   - Verify backend URL is correct and accessible
   - Check CORS configuration on your backend
   - Ensure API key is valid

3. **Styling issues**
   - Import app-studio CSS if needed
   - Check for conflicting CSS rules
   - Verify color system usage

4. **TypeScript errors**
   - Ensure all required props are provided
   - Check type imports from the correct package
   - Update TypeScript to latest version

### Debug Mode

Enable debug logging:

```tsx
<AgentServiceProvider
  config={{
    baseUrl: 'https://api.example.com',
    enableLogging: true, // Enable debug logs
  }}
>
  <App />
</AgentServiceProvider>
```

### Performance Optimization

```tsx
// Lazy load components for better performance
const AgentTrace = React.lazy(() => import('@app-studio/web').then(m => ({ default: m.AgentTrace })));
const AgentEval = React.lazy(() => import('@app-studio/web').then(m => ({ default: m.AgentEval })));

// Use with Suspense
<React.Suspense fallback={<div>Loading...</div>}>
  <AgentTrace sessionId="session-123" userId="user123" appName="my-agent" />
</React.Suspense>
```

## Next Steps

1. Explore the [complete example](../src/examples/CompleteAgentApp.tsx)
2. Check out individual component examples in the `examples/` directories
3. Read the [full documentation](./adk-components.md)
4. Join our community for support and updates

## Support

- 📚 [Documentation](./adk-components.md)
- 🚀 [Quick Start](./adk-quick-start.md)
- 💻 [Complete Example](../src/examples/CompleteAgentApp.tsx)
- 🐛 [Issue Tracker](https://github.com/your-org/adk-components/issues)
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Agent Types
 */
export interface AgentRunRequest {
  appName: string;
  userId: string;
  sessionId: string;
  newMessage: {
    role: string;
    parts: MessagePart[];
  };
  functionCallEventId?: string;
  streaming?: boolean;
}

export interface MessagePart {
  text?: string;
  inlineData?: {
    displayName: string;
    data: string | ArrayBuffer;
    mimeType: string;
  };
  functionCall?: {
    id: string;
    name: string;
    args: any;
  };
  functionResponse?: {
    id: string;
    name: string;
    response: any;
  };
  executableCode?: {
    language: string;
    code: string;
  };
  codeExecutionResult?: {
    outcome: string;
    output?: string;
  };
  thought?: boolean;
}

export interface AgentMessage {
  id: string;
  role: 'user' | 'bot';
  text?: string;
  parts?: MessagePart[];
  timestamp: number;
  isLoading?: boolean;
  thought?: boolean;
  eventId?: string;
  attachments?: MessageAttachment[];
  inlineData?: {
    displayName?: string;
    data: string;
    mimeType: string;
    mediaType?: 'image' | 'video' | 'audio' | 'document';
  };
  functionCall?: any;
  functionResponse?: any;
  executableCode?: any;
  codeExecutionResult?: any;
  renderedContent?: string;
  evalStatus?: string;
  failedMetric?: string;
  evalScore?: number;
  evalThreshold?: number;
}

export interface MessageAttachment {
  file: File;
  url: string;
  type: 'image' | 'video' | 'audio' | 'document';
}

export interface AgentSession {
  id: string;
  userId: string;
  appName: string;
  state: any;
  events: any[];
  createdAt: number;
  updatedAt: number;
}

export interface AgentEvent {
  id: string;
  sessionId: string;
  type: string;
  data: any;
  timestamp: number;
  title?: string;
}

/**
 * Component View Customization
 */
export interface AgentChatViews {
  container?: ViewProps;
  header?: ViewProps;
  messageList?: ViewProps;
  message?: ViewProps;
  userMessage?: ViewProps;
  botMessage?: ViewProps;
  inputArea?: ViewProps;
  inputField?: ViewProps;
  sendButton?: ViewProps;
  attachmentArea?: ViewProps;
  loadingIndicator?: ViewProps;
  errorMessage?: ViewProps;
  typingIndicator?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentChatEventHandlers {
  onSessionCreate?: (session: AgentSession) => void;
  onSessionUpdate?: (session: AgentSession) => void;
  onMessageSent?: (message: AgentMessage) => void;
  onMessageReceived?: (message: AgentMessage) => void;
  onError?: (error: Error) => void;
  onFileUpload?: (files: File[]) => void;
  onTypingStart?: () => void;
  onTypingStop?: () => void;
  onAudioRecordingStart?: () => void;
  onAudioRecordingStop?: (audioData: Blob) => void;
  onVideoRecordingStart?: () => void;
  onVideoRecordingStop?: (videoData: Blob) => void;
}

/**
 * Main AgentChat Props Interface
 */
export interface AgentChatProps extends ViewProps, AgentChatEventHandlers {
  // Required props
  appName: string;
  userId: string;

  // Optional configuration
  sessionId?: string;
  apiBaseUrl?: string;
  wsBaseUrl?: string;

  // Feature toggles
  enableFileUpload?: boolean;
  enableAudioRecording?: boolean;
  enableVideoRecording?: boolean;
  enableStreaming?: boolean;
  enableThoughts?: boolean;

  // Limits and constraints
  maxFileSize?: number;
  maxFiles?: number;
  allowedFileTypes?: string[];
  maxMessageLength?: number;

  // UI customization
  placeholder?: string;
  showTimestamps?: boolean;
  showAvatars?: boolean;
  showTypingIndicator?: boolean;
  autoScroll?: boolean;

  // Styling
  views?: AgentChatViews;

  // Initial state
  initialMessages?: AgentMessage[];
  initialSession?: AgentSession;

  // Advanced features
  enableFunctionCalls?: boolean;
  enableCodeExecution?: boolean;
  enableEvaluation?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentChatProps,
  AgentMessage,
  AgentSession,
  AgentRunRequest,
  MessageAttachment,
  MessagePart,
} from './AgentChat.props';
import { generateId } from '../../../../utils/generateId';

/**
 * Custom hook for managing AgentChat state and interactions
 */
export const useAgentChat = (props: AgentChatProps) => {
  const {
    appName,
    userId,
    sessionId: initialSessionId,
    apiBaseUrl = '',
    wsBaseUrl = '',
    enableStreaming = true,
    enableFileUpload = true,
    maxFileSize = 10 * 1024 * 1024, // 10MB
    maxFiles = 5,
    allowedFileTypes = [
      'image/*',
      'video/*',
      'audio/*',
      'application/pdf',
      'text/*',
    ],
    initialMessages = [],
    initialSession,
    onSessionCreate,
    onSessionUpdate,
    onMessageSent,
    onMessageReceived,
    onError,
    onFileUpload,
    onTypingStart,
    onTypingStop,
  } = props;

  // Core state
  const [messages, setMessages] = useState<AgentMessage[]>(initialMessages);
  const [currentSession, setCurrentSession] = useState<AgentSession | null>(
    initialSession || null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [inputValue, setInputValue] = useState('');
  const [selectedFiles, setSelectedFiles] = useState<MessageAttachment[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  // Refs
  const wsRef = useRef<WebSocket | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Generate or use provided session ID
  const sessionId = currentSession?.id || initialSessionId || generateId();

  /**
   * Create a new session
   */
  const createSession = useCallback(async () => {
    try {
      const response = await fetch(`${apiBaseUrl}/sessions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, appName }),
      });

      if (!response.ok) throw new Error('Failed to create session');

      const session: AgentSession = await response.json();
      setCurrentSession(session);
      onSessionCreate?.(session);
      return session;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
      throw error;
    }
  }, [apiBaseUrl, userId, appName, onSessionCreate, onError]);

  /**
   * Send a message to the agent
   */
  const sendMessage = useCallback(
    async (text: string, attachments: MessageAttachment[] = []) => {
      if (!text.trim() && attachments.length === 0) return;

      try {
        setIsLoading(true);
        setError(null);

        // Ensure we have a session
        let session = currentSession;
        if (!session) {
          session = await createSession();
        }

        // Create user message
        const userMessage: AgentMessage = {
          id: generateId(),
          role: 'user',
          text,
          timestamp: Date.now(),
          attachments: attachments.length > 0 ? attachments : undefined,
        };

        // Add user message to chat
        setMessages((prev) => [...prev, userMessage]);
        onMessageSent?.(userMessage);

        // Prepare message parts
        const parts: MessagePart[] = [{ text }];

        // Add file attachments
        for (const attachment of attachments) {
          const fileData = await readFileAsBase64(attachment.file);
          parts.push({
            inlineData: {
              displayName: attachment.file.name,
              data: fileData,
              mimeType: attachment.file.type,
            },
          });
        }

        // Create agent run request
        const request: AgentRunRequest = {
          appName,
          userId,
          sessionId: session.id,
          newMessage: {
            role: 'user',
            parts,
          },
          streaming: enableStreaming,
        };

        // Send request
        if (enableStreaming) {
          await sendStreamingRequest(request);
        } else {
          await sendRegularRequest(request);
        }

        // Clear input and files
        setInputValue('');
        setSelectedFiles([]);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [
      currentSession,
      createSession,
      appName,
      userId,
      enableStreaming,
      onMessageSent,
      onError,
    ]
  );

  /**
   * Send streaming request using Server-Sent Events
   */
  const sendStreamingRequest = useCallback(
    async (request: AgentRunRequest) => {
      return new Promise<void>((resolve, reject) => {
        const eventSource = new EventSource(`${apiBaseUrl}/run_sse`);
        eventSourceRef.current = eventSource;

        // Send the request
        fetch(`${apiBaseUrl}/run_sse`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(request),
        }).catch(reject);

        let streamingMessage: AgentMessage | null = null;

        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            if (data.error) {
              reject(new Error(data.error));
              return;
            }

            if (data.content?.parts) {
              for (const part of data.content.parts) {
                if (part.text) {
                  if (!streamingMessage) {
                    streamingMessage = {
                      id: generateId(),
                      role: 'bot',
                      text: part.text,
                      timestamp: Date.now(),
                      eventId: data.id,
                      thought: part.thought,
                    };
                    setMessages((prev) => [...prev, streamingMessage!]);
                  } else {
                    streamingMessage.text =
                      (streamingMessage.text || '') + part.text;
                    setMessages((prev) =>
                      prev.map((msg) =>
                        msg.id === streamingMessage!.id
                          ? { ...streamingMessage! }
                          : msg
                      )
                    );
                  }
                }
              }
            }
          } catch (err) {
            console.error('Error parsing SSE data:', err);
          }
        };

        eventSource.onerror = () => {
          eventSource.close();
          resolve();
        };

        eventSource.addEventListener('close', () => {
          eventSource.close();
          resolve();
        });
      });
    },
    [apiBaseUrl]
  );

  /**
   * Send regular (non-streaming) request
   */
  const sendRegularRequest = useCallback(
    async (request: AgentRunRequest) => {
      const response = await fetch(`${apiBaseUrl}/run`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });

      if (!response.ok) throw new Error('Failed to send message');

      const data = await response.json();

      if (data.content?.parts) {
        for (const part of data.content.parts) {
          const botMessage: AgentMessage = {
            id: generateId(),
            role: 'bot',
            text: part.text,
            timestamp: Date.now(),
            eventId: data.id,
            thought: part.thought,
            functionCall: part.functionCall,
            functionResponse: part.functionResponse,
            executableCode: part.executableCode,
            codeExecutionResult: part.codeExecutionResult,
          };

          setMessages((prev) => [...prev, botMessage]);
          onMessageReceived?.(botMessage);
        }
      }
    },
    [apiBaseUrl, onMessageReceived]
  );

  /**
   * Handle file selection
   */
  const handleFileSelect = useCallback(
    (files: FileList | File[]) => {
      const fileArray = Array.from(files);
      const validFiles: MessageAttachment[] = [];

      for (const file of fileArray) {
        // Check file size
        if (file.size > maxFileSize) {
          setError(
            `File ${file.name} is too large. Maximum size is ${
              maxFileSize / 1024 / 1024
            }MB`
          );
          continue;
        }

        // Check file type
        const isAllowed = allowedFileTypes.some((type) => {
          if (type.endsWith('/*')) {
            return file.type.startsWith(type.slice(0, -1));
          }
          return file.type === type;
        });

        if (!isAllowed) {
          setError(`File type ${file.type} is not allowed`);
          continue;
        }

        // Check total file count
        if (selectedFiles.length + validFiles.length >= maxFiles) {
          setError(`Maximum ${maxFiles} files allowed`);
          break;
        }

        const attachment: MessageAttachment = {
          file,
          url: URL.createObjectURL(file),
          type: getFileType(file.type),
        };

        validFiles.push(attachment);
      }

      if (validFiles.length > 0) {
        setSelectedFiles((prev) => [...prev, ...validFiles]);
        onFileUpload?.(validFiles.map((f) => f.file));
      }
    },
    [
      maxFileSize,
      allowedFileTypes,
      maxFiles,
      selectedFiles.length,
      onFileUpload,
    ]
  );

  /**
   * Remove selected file
   */
  const removeFile = useCallback((index: number) => {
    setSelectedFiles((prev) => {
      const newFiles = [...prev];
      URL.revokeObjectURL(newFiles[index].url);
      newFiles.splice(index, 1);
      return newFiles;
    });
  }, []);

  /**
   * Utility function to read file as base64
   */
  const readFileAsBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target?.result as string;
        const base64Data = result.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  };

  /**
   * Get file type category
   */
  const getFileType = (
    mimeType: string
  ): 'image' | 'video' | 'audio' | 'document' => {
    if (mimeType.startsWith('image/')) return 'image';
    if (mimeType.startsWith('video/')) return 'video';
    if (mimeType.startsWith('audio/')) return 'audio';
    return 'document';
  };

  /**
   * Initialize session on mount
   */
  useEffect(() => {
    if (!currentSession && !initialSessionId) {
      createSession();
    }
  }, [currentSession, initialSessionId, createSession]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      // Cleanup file URLs
      selectedFiles.forEach((file) => URL.revokeObjectURL(file.url));
    };
  }, [selectedFiles]);

  return {
    // State
    messages,
    currentSession,
    isLoading,
    isTyping,
    error,
    inputValue,
    selectedFiles,
    isConnected,
    sessionId,

    // Actions
    sendMessage,
    setInputValue,
    handleFileSelect,
    removeFile,
    createSession,

    // Refs
    messagesEndRef,

    // Additional state setters for view component
    setError,
    setSelectedFiles,
  };
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentChat component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentChatStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  messageList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    minHeight: '300px',
    maxHeight: '600px',
  } as ViewProps,

  emptyState: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '200px',
    padding: '32px',
  } as ViewProps,

  inputArea: {
    padding: '16px',
    borderTop: '1px solid',
    borderTopColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  attachmentArea: {
    padding: '12px 16px',
    borderTop: '1px solid',
    borderTopColor: 'color.gray.200',
    backgroundColor: 'color.gray.100',
    flexShrink: 0,
  } as ViewProps,

  message: {
    padding: '12px',
    borderRadius: '8px',
    maxWidth: '80%',
    wordBreak: 'break-word',
  } as ViewProps,

  userMessage: {
    backgroundColor: 'color.blue.500',
    color: 'white',
    alignSelf: 'flex-end',
    marginLeft: 'auto',
  } as ViewProps,

  botMessage: {
    backgroundColor: 'color.gray.100',
    color: 'color.gray.900',
    alignSelf: 'flex-start',
    marginRight: 'auto',
  } as ViewProps,

  thoughtMessage: {
    backgroundColor: 'color.yellow.50',
    color: 'color.yellow.800',
    border: '1px solid',
    borderColor: 'color.yellow.200',
    fontStyle: 'italic',
  } as ViewProps,

  loadingMessage: {
    backgroundColor: 'color.gray.50',
    color: 'color.gray.600',
    border: '1px dashed',
    borderColor: 'color.gray.300',
  } as ViewProps,

  messageHeader: {
    marginBottom: '4px',
  } as ViewProps,

  messageContent: {
    lineHeight: 1.5,
  } as ViewProps,

  messageFooter: {
    marginTop: '8px',
  } as ViewProps,

  timestamp: {
    fontSize: '12px',
    color: 'color.gray.500',
    marginTop: '4px',
  } as ViewProps,

  avatar: {
    width: '32px',
    height: '32px',
    borderRadius: '50%',
    backgroundColor: 'color.gray.300',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '14px',
    fontWeight: '600',
    color: 'white',
    flexShrink: 0,
  } as ViewProps,

  userAvatar: {
    backgroundColor: 'color.blue.500',
  } as ViewProps,

  botAvatar: {
    backgroundColor: 'color.green.500',
  } as ViewProps,

  attachmentPreview: {
    position: 'relative',
    display: 'inline-block',
    padding: '8px',
    backgroundColor: 'color.gray.100',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  attachmentRemove: {
    position: 'absolute',
    top: '-4px',
    right: '-4px',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    backgroundColor: 'color.red.500',
    color: 'white',
    border: 'none',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '12px',
  } as ViewProps,

  typingIndicator: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    padding: '12px',
    backgroundColor: 'color.gray.100',
    borderRadius: '8px',
    maxWidth: '80px',
    alignSelf: 'flex-start',
  } as ViewProps,

  typingDot: {
    width: '6px',
    height: '6px',
    borderRadius: '50%',
    backgroundColor: 'color.gray.500',
  } as ViewProps,

  functionCall: {
    backgroundColor: 'color.purple.50',
    border: '1px solid',
    borderColor: 'color.purple.200',
    borderRadius: '8px',
    padding: '12px',
    marginTop: '8px',
  } as ViewProps,

  functionResponse: {
    backgroundColor: 'color.green.50',
    border: '1px solid',
    borderColor: 'color.green.200',
    borderRadius: '8px',
    padding: '12px',
    marginTop: '8px',
  } as ViewProps,

  codeBlock: {
    backgroundColor: 'color.gray.900',
    color: 'color.gray.100',
    borderRadius: '8px',
    padding: '12px',
    fontFamily: 'Monaco, Consolas, monospace',
    fontSize: '14px',
    overflow: 'auto',
    marginTop: '8px',
  } as ViewProps,

  inlineData: {
    marginTop: '8px',
    borderRadius: '8px',
    overflow: 'hidden',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  errorMessage: {
    backgroundColor: 'color.red.50',
    color: 'color.red.800',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    padding: '12px',
    margin: '8px 16px',
  } as ViewProps,
};

/**
 * Animation styles for typing indicator
 */
export const TypingAnimationStyles = {
  dot1: {
    animationDelay: '0ms',
  },
  dot2: {
    animationDelay: '150ms',
  },
  dot3: {
    animationDelay: '300ms',
  },
};

/**
 * Responsive breakpoints for AgentChat
 */
export const AgentChatBreakpoints = {
  mobile: '(max-width: 768px)',
  tablet: '(max-width: 1024px)',
  desktop: '(min-width: 1025px)',
};

/**
 * Size variants for AgentChat
 */
export const AgentChatSizes = {
  sm: {
    container: { height: '400px' },
    messageList: { minHeight: '200px', maxHeight: '300px' },
  },
  md: {
    container: { height: '500px' },
    messageList: { minHeight: '300px', maxHeight: '400px' },
  },
  lg: {
    container: { height: '600px' },
    messageList: { minHeight: '400px', maxHeight: '500px' },
  },
  xl: {
    container: { height: '700px' },
    messageList: { minHeight: '500px', maxHeight: '600px' },
  },
};

/**
 * Theme variants for AgentChat
 */
export const AgentChatThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    messageList: { backgroundColor: 'color.white' },
    inputArea: { backgroundColor: 'color.gray.50' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    messageList: { backgroundColor: 'color.gray.900' },
    inputArea: { backgroundColor: 'color.gray.800' },
  },
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.view.tsx">
import React, { useEffect } from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { ChatInput } from '../../../ChatInput/ChatInput';
import { AgentChatProps } from './AgentChat.props';
import { useAgentChat } from './AgentChat.state';
import { DefaultAgentChatStyles } from './AgentChat.style';
import { AgentMessage } from './AgentMessage';
import { AgentTypingIndicator } from './AgentTypingIndicator';
import { MessageAttachmentPreview } from './MessageAttachmentPreview';
import { Loader } from 'src/components/Loader/Loader';
import { Alert } from 'src/components/Alert/Alert';

export interface AgentChatViewProps
  extends Omit<AgentChatProps, 'sessionId'>,
    ReturnType<typeof useAgentChat> {}

/**
 * AgentChat View Component
 *
 * Renders the complete chat interface with message list, input area, and controls
 */
const AgentChatView: React.FC<AgentChatViewProps> = ({
  // Props
  placeholder = 'Type your message...',
  showTimestamps = true,
  showAvatars = true,
  showTypingIndicator = true,
  autoScroll = true,
  enableFileUpload = true,
  enableAudioRecording = false,
  enableVideoRecording = false,
  views,
  ariaLabel = 'Agent Chat',
  ariaDescribedBy,

  // State from hook
  messages,
  currentSession,
  isLoading,
  isTyping,
  error,
  inputValue,
  selectedFiles,
  sessionId,
  sendMessage,
  setInputValue,
  handleFileSelect,
  removeFile,
  messagesEndRef,
  setError,
  setSelectedFiles,

  ...props
}) => {
  /**
   * Auto-scroll to bottom when new messages arrive
   */
  useEffect(() => {
    if (autoScroll && messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, autoScroll]);

  /**
   * Handle message send from ChatInput
   */
  const handleSubmit = async (
    message: string,
    options?: { model_name?: string; enable_thinking?: boolean }
  ) => {
    if (message.trim() || selectedFiles.length > 0) {
      await sendMessage(message, selectedFiles);
    }
  };

  /**
   * Get pending files for ChatInput
   */
  const getPendingFiles = () => {
    return selectedFiles.map((f) => f.file);
  };

  /**
   * Clear pending files for ChatInput
   */
  const clearPendingFiles = () => {
    selectedFiles.forEach((file) => URL.revokeObjectURL(file.url));
    setSelectedFiles([]);
  };

  return (
    <View
      {...DefaultAgentChatStyles.container}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentChatStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Chat
            </Text>
            {currentSession && (
              <Text fontSize="sm" color="color.gray.600">
                Session: {sessionId?.slice(0, 8)}...
              </Text>
            )}
          </Vertical>

          {isLoading && (
            <Horizontal alignItems="center" gap={8}>
              <Loader size="sm" />
              <Text fontSize="sm" color="color.gray.600">
                Processing...
              </Text>
            </Horizontal>
          )}
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Alert
          variant="error"
          title=""
          description={error}
          onClose={() => setError?.(null)}
        >
          {error}
        </Alert>
      )}

      {/* Message List */}
      <View {...DefaultAgentChatStyles.messageList} {...views?.messageList}>
        <Vertical gap={16} padding={16}>
          {messages.length === 0 ? (
            <View {...DefaultAgentChatStyles.emptyState}>
              <Text color="color.gray.500" textAlign="center">
                Start a conversation with the agent
              </Text>
            </View>
          ) : (
            messages.map((message, index) => (
              <AgentMessage
                key={message.id}
                message={message}
                showTimestamp={showTimestamps}
                showAvatar={showAvatars}
                isLast={index === messages.length - 1}
                views={{
                  container:
                    message.role === 'user'
                      ? views?.userMessage
                      : views?.botMessage,
                  ...views?.message,
                }}
              />
            ))
          )}

          {/* Typing Indicator */}
          {showTypingIndicator && isTyping && <AgentTypingIndicator />}

          {/* Loading Message */}
          {isLoading && (
            <AgentMessage
              message={{
                id: 'loading',
                role: 'bot',
                text: '',
                timestamp: Date.now(),
                isLoading: true,
              }}
              showTimestamp={false}
              showAvatar={showAvatars}
              isLast={true}
            />
          )}

          {/* Scroll anchor */}
          <div ref={messagesEndRef} />
        </Vertical>
      </View>

      {/* File Attachments Preview */}
      {selectedFiles.length > 0 && (
        <View
          {...DefaultAgentChatStyles.attachmentArea}
          {...views?.attachmentArea}
        >
          <Horizontal gap={8} flexWrap="wrap">
            {selectedFiles.map((file, index) => (
              <MessageAttachmentPreview
                key={index}
                attachment={file}
                onRemove={() => removeFile(index)}
              />
            ))}
          </Horizontal>
        </View>
      )}

      {/* Input Area */}
      <View {...DefaultAgentChatStyles.inputArea} {...views?.inputArea}>
        <ChatInput
          onSubmit={handleSubmit}
          getPendingFiles={getPendingFiles}
          clearPendingFiles={clearPendingFiles}
          value={inputValue}
          onChange={setInputValue}
          placeholder={placeholder}
          loading={isLoading}
          disabled={isLoading}
          hideAttachments={!enableFileUpload}
          views={{
            container: views?.inputField,
          }}
        />
      </View>
    </View>
  );
};

export default AgentChatView;
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentMessage.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { AgentMessage as AgentMessageType } from './AgentChat.props';
import { DefaultAgentChatStyles } from './AgentChat.style';
import { Loader } from 'src/components/Loader/Loader';
import { Avatar } from 'src/components/Avatar/Avatar';

export interface AgentMessageProps {
  message: AgentMessageType;
  showTimestamp?: boolean;
  showAvatar?: boolean;
  isLast?: boolean;
  views?: {
    container?: any;
    content?: any;
    timestamp?: any;
    avatar?: any;
  };
}

/**
 * AgentMessage Component
 *
 * Renders individual messages in the chat with support for different message types,
 * attachments, function calls, code execution, and more.
 */
export const AgentMessage: React.FC<AgentMessageProps> = ({
  message,
  showTimestamp = true,
  showAvatar = true,
  isLast = false,
  views = {},
}) => {
  const isUser = message.role === 'user';
  const isThought = message.thought;
  const isLoading = message.isLoading;

  // Determine message styles
  const messageStyles = {
    ...DefaultAgentChatStyles.message,
    ...(isUser
      ? DefaultAgentChatStyles.userMessage
      : DefaultAgentChatStyles.botMessage),
    ...(isThought ? DefaultAgentChatStyles.thoughtMessage : {}),
    ...(isLoading ? DefaultAgentChatStyles.loadingMessage : {}),
    ...views.container,
  };

  // Format timestamp
  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  // Render message content based on type
  const renderMessageContent = () => {
    if (isLoading) {
      return (
        <Horizontal alignItems="center" gap={8}>
          <Loader size="sm" />
          <Text color="color.gray.600">Thinking...</Text>
        </Horizontal>
      );
    }

    return (
      <Vertical gap={8}>
        {/* Text content */}
        {message.text && (
          <Text {...DefaultAgentChatStyles.messageContent} {...views.content}>
            {message.text}
          </Text>
        )}

        {/* Inline data (images, files, etc.) */}
        {message.inlineData && (
          <View {...DefaultAgentChatStyles.inlineData}>
            {message.inlineData.mediaType === 'image' ? (
              <img
                src={message.inlineData.data}
                alt={message.inlineData.displayName || 'Uploaded image'}
                style={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: '8px',
                }}
              />
            ) : message.inlineData.mediaType === 'video' ? (
              <video
                src={message.inlineData.data}
                controls
                style={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: '8px',
                }}
              />
            ) : message.inlineData.mediaType === 'audio' ? (
              <audio
                src={message.inlineData.data}
                controls
                style={{ width: '100%' }}
              />
            ) : (
              <View
                padding={12}
                backgroundColor="color.gray.100"
                borderRadius="8px"
              >
                <Text fontSize="sm" fontWeight="500">
                  📄 {message.inlineData.displayName || 'File'}
                </Text>
                <Text fontSize="xs" color="color.gray.600">
                  {message.inlineData.mimeType}
                </Text>
              </View>
            )}
          </View>
        )}

        {/* Attachments */}
        {message.attachments && message.attachments.length > 0 && (
          <Horizontal gap={8} flexWrap="wrap">
            {message.attachments.map((attachment, index) => (
              <View key={index} {...DefaultAgentChatStyles.attachmentPreview}>
                {attachment.type === 'image' ? (
                  <img
                    src={attachment.url}
                    alt={attachment.file.name}
                    style={{
                      width: '60px',
                      height: '60px',
                      objectFit: 'cover',
                      borderRadius: '4px',
                    }}
                  />
                ) : (
                  <View
                    width="60px"
                    height="60px"
                    backgroundColor="color.gray.200"
                    borderRadius="4px"
                    display="flex"
                    alignItems="center"
                    justifyContent="center"
                  >
                    <Text fontSize="xs">📄</Text>
                  </View>
                )}
                <Text fontSize="xs" marginTop={4} textAlign="center">
                  {attachment.file.name.length > 10
                    ? attachment.file.name.substring(0, 10) + '...'
                    : attachment.file.name}
                </Text>
              </View>
            ))}
          </Horizontal>
        )}

        {/* Function Call */}
        {message.functionCall && (
          <View {...DefaultAgentChatStyles.functionCall}>
            <Text fontSize="sm" fontWeight="600" color="color.purple.700">
              🔧 Function Call: {message.functionCall.name}
            </Text>
            {message.functionCall.args && (
              <View marginTop={8}>
                <Text fontSize="xs" color="color.purple.600">
                  Arguments:
                </Text>
                <View
                  backgroundColor="color.purple.25"
                  padding={8}
                  borderRadius="4px"
                  marginTop={4}
                >
                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                    {JSON.stringify(message.functionCall.args, null, 2)}
                  </Text>
                </View>
              </View>
            )}
          </View>
        )}

        {/* Function Response */}
        {message.functionResponse && (
          <View {...DefaultAgentChatStyles.functionResponse}>
            <Text fontSize="sm" fontWeight="600" color="color.green.700">
              ✅ Function Response: {message.functionResponse.name}
            </Text>
            {message.functionResponse.response && (
              <View marginTop={8}>
                <View
                  backgroundColor="color.green.25"
                  padding={8}
                  borderRadius="4px"
                >
                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                    {typeof message.functionResponse.response === 'string'
                      ? message.functionResponse.response
                      : JSON.stringify(
                          message.functionResponse.response,
                          null,
                          2
                        )}
                  </Text>
                </View>
              </View>
            )}
          </View>
        )}

        {/* Executable Code */}
        {message.executableCode && (
          <View {...DefaultAgentChatStyles.codeBlock}>
            <Text
              fontSize="sm"
              fontWeight="600"
              color="color.gray.100"
              marginBottom={8}
            >
              💻 Code ({message.executableCode.language})
            </Text>
            <Text fontSize="sm" fontFamily="Monaco, Consolas, monospace">
              {message.executableCode.code}
            </Text>
          </View>
        )}

        {/* Code Execution Result */}
        {message.codeExecutionResult && (
          <View {...DefaultAgentChatStyles.functionResponse}>
            <Text fontSize="sm" fontWeight="600" color="color.green.700">
              📊 Execution Result: {message.codeExecutionResult.outcome}
            </Text>
            {message.codeExecutionResult.output && (
              <View marginTop={8}>
                <View
                  backgroundColor="color.green.25"
                  padding={8}
                  borderRadius="4px"
                >
                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                    {message.codeExecutionResult.output}
                  </Text>
                </View>
              </View>
            )}
          </View>
        )}

        {/* Rendered Content (for search results, etc.) */}
        {message.renderedContent && (
          <View
            marginTop={8}
            padding={12}
            backgroundColor="color.blue.50"
            borderRadius="8px"
            border="1px solid"
            borderColor="color.blue.200"
          >
            <div
              dangerouslySetInnerHTML={{ __html: message.renderedContent }}
            />
          </View>
        )}

        {/* Evaluation Status */}
        {message.evalStatus && (
          <View
            marginTop={8}
            padding={8}
            backgroundColor={
              message.evalStatus === 'PASS' ? 'color.green.50' : 'color.red.50'
            }
            borderRadius="8px"
            border="1px solid"
            borderColor={
              message.evalStatus === 'PASS'
                ? 'color.green.200'
                : 'color.red.200'
            }
          >
            <Text
              fontSize="sm"
              fontWeight="600"
              color={
                message.evalStatus === 'PASS'
                  ? 'color.green.700'
                  : 'color.red.700'
              }
            >
              Evaluation: {message.evalStatus}
            </Text>
            {message.evalScore !== undefined && (
              <Text fontSize="xs" color="color.gray.600">
                Score: {message.evalScore} / {message.evalThreshold}
              </Text>
            )}
            {message.failedMetric && (
              <Text fontSize="xs" color="color.red.600">
                Failed Metric: {message.failedMetric}
              </Text>
            )}
          </View>
        )}
      </Vertical>
    );
  };

  return (
    <Horizontal
      gap={12}
      alignItems="flex-start"
      justifyContent={isUser ? 'flex-end' : 'flex-start'}
      width="100%"
    >
      {/* Avatar for bot messages */}
      {showAvatar && !isUser && (
        <Avatar
          size="sm"
          backgroundColor="color.green.500"
          color="white"
          {...DefaultAgentChatStyles.botAvatar}
          {...views.avatar}
        >
          🤖
        </Avatar>
      )}

      {/* Message content */}
      <Vertical gap={4} maxWidth="80%">
        <View {...messageStyles}>{renderMessageContent()}</View>

        {/* Timestamp */}
        {showTimestamp && !isLoading && (
          <Text
            {...DefaultAgentChatStyles.timestamp}
            {...views.timestamp}
            textAlign={isUser ? 'right' : 'left'}
          >
            {formatTimestamp(message.timestamp)}
          </Text>
        )}
      </Vertical>

      {/* Avatar for user messages */}
      {showAvatar && isUser && (
        <Avatar
          size="sm"
          backgroundColor="color.blue.500"
          color="white"
          {...DefaultAgentChatStyles.userAvatar}
          {...views.avatar}
        >
          👤
        </Avatar>
      )}
    </Horizontal>
  );
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentTypingIndicator.tsx">
import React from 'react';
import { View, Horizontal } from 'app-studio';
import {
  DefaultAgentChatStyles,
  TypingAnimationStyles,
} from './AgentChat.style';
import { Avatar } from 'src/components/Avatar/Avatar';

/**
 * AgentTypingIndicator Component
 *
 * Shows an animated typing indicator when the agent is processing a response
 */
export const AgentTypingIndicator: React.FC = () => {
  return (
    <Horizontal gap={12} alignItems="flex-start">
      {/* Bot Avatar */}
      <Avatar
        size="sm"
        backgroundColor="color.green.500"
        color="white"
        {...DefaultAgentChatStyles.botAvatar}
      >
        🤖
      </Avatar>

      {/* Typing Animation */}
      <View {...DefaultAgentChatStyles.typingIndicator}>
        <Horizontal gap={4} alignItems="center">
          <View
            {...DefaultAgentChatStyles.typingDot}
            style={{
              ...TypingAnimationStyles.dot1,
              animation: 'typing-pulse 1.4s infinite ease-in-out',
            }}
          />
          <View
            {...DefaultAgentChatStyles.typingDot}
            style={{
              ...TypingAnimationStyles.dot2,
              animation: 'typing-pulse 1.4s infinite ease-in-out',
            }}
          />
          <View
            {...DefaultAgentChatStyles.typingDot}
            style={{
              ...TypingAnimationStyles.dot3,
              animation: 'typing-pulse 1.4s infinite ease-in-out',
            }}
          />
        </Horizontal>
      </View>

      {/* Add CSS keyframes for typing animation */}
      <style>
        {`
          @keyframes typing-pulse {
            0%, 80%, 100% {
              opacity: 0.3;
              transform: scale(0.8);
            }
            40% {
              opacity: 1;
              transform: scale(1);
            }
          }
        `}
      </style>
    </Horizontal>
  );
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/MessageAttachmentPreview.tsx">
import React from 'react';
import { View, Vertical, Text, Button } from 'app-studio';
import { MessageAttachment } from './AgentChat.props';
import { DefaultAgentChatStyles } from './AgentChat.style';

export interface MessageAttachmentPreviewProps {
  attachment: MessageAttachment;
  onRemove: () => void;
}

/**
 * MessageAttachmentPreview Component
 *
 * Shows a preview of attached files with the ability to remove them
 */
export const MessageAttachmentPreview: React.FC<
  MessageAttachmentPreviewProps
> = ({ attachment, onRemove }) => {
  const { file, url, type } = attachment;

  // Format file size
  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  // Get file icon based on type
  const getFileIcon = (type: string) => {
    switch (type) {
      case 'image':
        return '🖼️';
      case 'video':
        return '🎥';
      case 'audio':
        return '🎵';
      case 'document':
      default:
        return '📄';
    }
  };

  return (
    <View {...DefaultAgentChatStyles.attachmentPreview}>
      {/* Remove button */}
      <Button
        {...DefaultAgentChatStyles.attachmentRemove}
        onClick={onRemove}
        aria-label={`Remove ${file.name}`}
      >
        ×
      </Button>

      {/* File preview */}
      <Vertical gap={8} alignItems="center">
        {type === 'image' ? (
          <img
            src={url}
            alt={file.name}
            style={{
              width: '80px',
              height: '80px',
              objectFit: 'cover',
              borderRadius: '6px',
            }}
          />
        ) : type === 'video' ? (
          <video
            src={url}
            style={{
              width: '80px',
              height: '80px',
              objectFit: 'cover',
              borderRadius: '6px',
            }}
          />
        ) : (
          <View
            width="80px"
            height="80px"
            backgroundColor="color.gray.100"
            borderRadius="6px"
            display="flex"
            alignItems="center"
            justifyContent="center"
          >
            <Text fontSize="24px">{getFileIcon(type)}</Text>
          </View>
        )}

        {/* File info */}
        <Vertical gap={2} alignItems="center" maxWidth="120px">
          <Text
            fontSize="xs"
            fontWeight="500"
            textAlign="center"
            style={{
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
              maxWidth: '100%',
            }}
          >
            {file.name}
          </Text>
          <Text fontSize="xs" color="color.gray.500">
            {formatFileSize(file.size)}
          </Text>
        </Vertical>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentChat/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text, Horizontal } from 'app-studio';
import { AgentChat } from '../AgentChat';
import { AgentSession, AgentMessage } from '../AgentChat/AgentChat.props';

/**
 * Default AgentChat Example
 *
 * Demonstrates basic usage of the AgentChat component with ADK agents
 */
export const DefaultDemo = () => {
  const [currentSession, setCurrentSession] = useState<AgentSession | null>(
    null
  );
  const [messages, setMessages] = useState<AgentMessage[]>([]);

  const handleSessionCreate = (session: AgentSession) => {
    console.log('Session created:', session);
    setCurrentSession(session);
  };

  const handleSessionUpdate = (session: AgentSession) => {
    console.log('Session updated:', session);
    setCurrentSession(session);
  };

  const handleMessageSent = (message: AgentMessage) => {
    console.log('Message sent:', message);
    setMessages((prev) => [...prev, message]);
  };

  const handleMessageReceived = (message: AgentMessage) => {
    console.log('Message received:', message);
    setMessages((prev) => [...prev, message]);
  };

  const handleError = (error: Error) => {
    console.error('AgentChat error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentChat Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A complete chat interface for interacting with ADK agents. Supports
        real-time messaging, file uploads, function calls, code execution, and
        more.
      </Text>

      {/* Session Info */}
      {currentSession && (
        <View
          padding={16}
          backgroundColor="color.blue.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.blue.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.blue.800">
            Active Session
          </Text>
          <Text fontSize={12} color="color.blue.600">
            ID: {currentSession.id}
          </Text>
          <Text fontSize={12} color="color.blue.600">
            App: {currentSession.appName}
          </Text>
        </View>
      )}

      {/* AgentChat Component */}
      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentChat
          appName="demo-agent"
          userId="demo-user"
          apiBaseUrl="http://localhost:3000/adk"
          placeholder="Ask the agent anything..."
          enableFileUpload={true}
          enableStreaming={true}
          enableThoughts={true}
          showTimestamps={true}
          showAvatars={true}
          showTypingIndicator={true}
          autoScroll={true}
          maxFileSize={10 * 1024 * 1024} // 10MB
          maxFiles={5}
          allowedFileTypes={[
            'image/*',
            'video/*',
            'audio/*',
            'application/pdf',
            'text/*',
          ]}
          onSessionCreate={handleSessionCreate}
          onSessionUpdate={handleSessionUpdate}
          onMessageSent={handleMessageSent}
          onMessageReceived={handleMessageReceived}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
            messageList: {
              backgroundColor: 'color.gray.100',
            },
            inputArea: {
              backgroundColor: 'color.white',
            },
          }}
        />
      </View>

      {/* Message Log */}
      {messages.length > 0 && (
        <View>
          <Text fontSize={16} fontWeight="600" marginBottom={16}>
            Message Log ({messages.length} messages)
          </Text>
          <View
            maxHeight="200px"
            overflowY="auto"
            padding={16}
            backgroundColor="color.gray.50"
            borderRadius="8px"
          >
            <Vertical gap={8}>
              {messages.map((message, index) => (
                <View
                  key={message.id}
                  padding={8}
                  backgroundColor="color.white"
                  borderRadius="4px"
                >
                  <Horizontal
                    justifyContent="space-between"
                    alignItems="center"
                  >
                    <Text
                      fontSize={12}
                      fontWeight="600"
                      color={
                        message.role === 'user'
                          ? 'color.blue.600'
                          : 'color.green.600'
                      }
                    >
                      {message.role === 'user' ? '👤 User' : '🤖 Agent'}
                    </Text>
                    <Text fontSize={10} color="color.gray.500">
                      {new Date(message.timestamp).toLocaleTimeString()}
                    </Text>
                  </Horizontal>
                  <Text fontSize={12} marginTop={4}>
                    {message.text || '[Non-text content]'}
                  </Text>
                  {message.thought && (
                    <Text
                      fontSize={10}
                      color="color.yellow.600"
                      fontStyle="italic"
                    >
                      💭 Thought
                    </Text>
                  )}
                </View>
              ))}
            </Vertical>
          </View>
        </View>
      )}
    </Vertical>
  );
};

/**
 * Minimal AgentChat Example
 *
 * Shows the simplest possible usage
 */
export const MinimalDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Minimal AgentChat Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentChat appName="simple-agent" userId="user123" />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentChat Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentChat Example
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.purple.200"
        borderRadius="12px"
      >
        <AgentChat
          appName="custom-agent"
          userId="user123"
          placeholder="Chat with our custom AI assistant..."
          enableFileUpload={true}
          enableThoughts={true}
          showAvatars={true}
          views={{
            container: {
              backgroundColor: 'color.purple.25',
            },
            header: {
              backgroundColor: 'color.purple.500',
              color: 'white',
            },
            messageList: {
              backgroundColor: 'color.white',
            },
            userMessage: {
              backgroundColor: 'color.purple.500',
            },
            botMessage: {
              backgroundColor: 'color.purple.100',
              color: 'color.purple.900',
            },
            inputArea: {
              backgroundColor: 'color.purple.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Agent with Function Calls Example
 *
 * Demonstrates function call capabilities
 */
export const FunctionCallsDemo = () => {
  const initialMessages: AgentMessage[] = [
    {
      id: '1',
      role: 'user',
      text: "What's the weather like in San Francisco?",
      timestamp: Date.now() - 60000,
    },
    {
      id: '2',
      role: 'bot',
      text: "I'll check the weather for you.",
      timestamp: Date.now() - 50000,
      functionCall: {
        id: 'call_1',
        name: 'get_weather',
        args: { location: 'San Francisco, CA' },
      },
    },
    {
      id: '3',
      role: 'bot',
      text: 'The weather in San Francisco is currently 68°F with partly cloudy skies.',
      timestamp: Date.now() - 40000,
      functionResponse: {
        id: 'call_1',
        name: 'get_weather',
        response: { temperature: 68, condition: 'partly cloudy', humidity: 65 },
      },
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentChat with Function Calls
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentChat
          appName="function-agent"
          userId="user123"
          initialMessages={initialMessages}
          enableFunctionCalls={true}
          enableCodeExecution={true}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentChat/AgentChat.tsx">
import React from 'react';
import { AgentChatProps } from './AgentChat/AgentChat.props';
import AgentChatView from './AgentChat/AgentChat.view';
import { useAgentChat } from './AgentChat/AgentChat.state';

/**
 * AgentChat Component
 *
 * A comprehensive chat interface for interacting with ADK agents.
 * Supports real-time messaging, file uploads, agent responses, and session management.
 *
 * @example
 * ```tsx
 * <AgentChat
 *   appName="my-agent"
 *   userId="user123"
 *   onSessionCreate={(session) => console.log('Session created:', session)}
 *   onMessageSent={(message) => console.log('Message sent:', message)}
 * />
 * ```
 *
 * @example
 * ```tsx
 * // With custom styling and configuration
 * <AgentChat
 *   appName="my-agent"
 *   userId="user123"
 *   enableFileUpload={true}
 *   enableAudioRecording={true}
 *   enableVideoRecording={true}
 *   maxFileSize={10 * 1024 * 1024} // 10MB
 *   apiBaseUrl="http://localhost:3000/adk"
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     messageList: { maxHeight: '400px' },
 *     inputArea: { borderRadius: '12px' }
 *   }}
 * />
 * ```
 */
const AgentChat: React.FC<AgentChatProps> = (props) => {
  const chatState = useAgentChat(props);

  return <AgentChatView {...props} {...chatState} />;
};

export default AgentChat;
export { AgentChat };
export type { AgentChatProps };
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Evaluation Types
 */
export interface EvaluationMetric {
  id: string;
  name: string;
  description: string;
  type: 'accuracy' | 'latency' | 'cost' | 'quality' | 'safety' | 'custom';
  threshold?: number;
  weight?: number;
  config?: Record<string, any>;
}

export interface EvaluationTestCase {
  id: string;
  name: string;
  description?: string;
  input: any;
  expectedOutput?: any;
  metadata?: Record<string, any>;
  tags?: string[];
}

export interface EvaluationRun {
  id: string;
  name: string;
  appName: string;
  userId: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  progress: number; // 0-100
  startTime: number;
  endTime?: number;
  duration?: number;
  testCases: EvaluationTestCase[];
  metrics: EvaluationMetric[];
  results?: EvaluationResult[];
  summary?: EvaluationSummary;
  config?: EvaluationConfig;
  error?: string;
}

export interface EvaluationResult {
  id: string;
  evaluationId: string;
  testCaseId: string;
  status: 'pass' | 'fail' | 'error' | 'skip';
  score?: number;
  actualOutput?: any;
  metrics: Record<string, number>;
  duration: number;
  error?: string;
  details?: Record<string, any>;
  timestamp: number;
}

export interface EvaluationSummary {
  totalTests: number;
  passedTests: number;
  failedTests: number;
  errorTests: number;
  skippedTests: number;
  averageScore: number;
  totalDuration: number;
  metricsAverages: Record<string, number>;
  passRate: number;
}

export interface EvaluationConfig {
  maxConcurrency?: number;
  timeout?: number;
  retryCount?: number;
  stopOnFailure?: boolean;
  randomizeOrder?: boolean;
  enableDetailedLogging?: boolean;
}

/**
 * Component View Customization
 */
export interface AgentEvalViews {
  container?: ViewProps;
  header?: ViewProps;
  evaluationList?: ViewProps;
  evaluationItem?: ViewProps;
  activeEvaluationItem?: ViewProps;
  createPanel?: ViewProps;
  resultsPanel?: ViewProps;
  metricsPanel?: ViewProps;
  testCaseList?: ViewProps;
  testCaseItem?: ViewProps;
  progressBar?: ViewProps;
  statusIndicator?: ViewProps;
  actionButtons?: ViewProps;
  exportButton?: ViewProps;
  refreshButton?: ViewProps;
  searchInput?: ViewProps;
  emptyState?: ViewProps;
  loadingState?: ViewProps;
  errorState?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentEvalEventHandlers {
  onEvaluationCreate?: (evaluation: EvaluationRun) => void;
  onEvaluationStart?: (evaluationId: string) => void;
  onEvaluationComplete?: (result: EvaluationRun) => void;
  onEvaluationCancel?: (evaluationId: string) => void;
  onEvaluationDelete?: (evaluationId: string) => void;
  onTestCaseSelect?: (testCase: EvaluationTestCase) => void;
  onResultSelect?: (result: EvaluationResult) => void;
  onExport?: (format: 'json' | 'csv' | 'pdf') => void;
  onError?: (error: Error) => void;
  onRefresh?: () => void;
}

/**
 * Evaluation Templates
 */
export interface EvaluationTemplate {
  id: string;
  name: string;
  description: string;
  testCases: EvaluationTestCase[];
  metrics: EvaluationMetric[];
  config: EvaluationConfig;
  tags?: string[];
}

/**
 * Comparison Options
 */
export interface EvaluationComparison {
  baselineId: string;
  comparisonIds: string[];
  metrics: string[];
  showDifferences?: boolean;
  showTrends?: boolean;
}

/**
 * Main AgentEval Props Interface
 */
export interface AgentEvalProps extends ViewProps, AgentEvalEventHandlers {
  // Required props
  appName: string;
  userId: string;

  // Optional configuration
  apiBaseUrl?: string;

  // Feature toggles
  enableBatchEvaluation?: boolean;
  enableMetricsComparison?: boolean;
  enableResultExport?: boolean;
  enableTemplates?: boolean;
  enableAutoRefresh?: boolean;

  // Limits and constraints
  maxConcurrentEvals?: number;
  maxTestCases?: number;
  refreshInterval?: number; // in milliseconds

  // UI customization
  showEvaluationHistory?: boolean;
  showMetricsPanel?: boolean;
  showTestCaseDetails?: boolean;
  showProgressIndicators?: boolean;
  compactMode?: boolean;

  // Styling
  views?: AgentEvalViews;

  // Initial state
  initialEvaluations?: EvaluationRun[];
  selectedEvaluationId?: string;
  availableTemplates?: EvaluationTemplate[];

  // Advanced features
  enableRealTimeUpdates?: boolean;
  enableResultCaching?: boolean;
  enableCustomMetrics?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

/**
 * Export Options
 */
export interface EvaluationExportOptions {
  format: 'json' | 'csv' | 'pdf';
  includeTestCases?: boolean;
  includeResults?: boolean;
  includeMetrics?: boolean;
  includeSummary?: boolean;
  evaluationIds?: string[];
}

/**
 * Real-time Update Types
 */
export interface EvaluationUpdate {
  type: 'progress' | 'result' | 'status' | 'complete' | 'error';
  evaluationId: string;
  data: any;
  timestamp: number;
}
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentEvalProps,
  EvaluationRun,
  EvaluationResult,
  EvaluationTestCase,
  EvaluationMetric,
  EvaluationTemplate,
  EvaluationExportOptions,
} from './AgentEval.props';

/**
 * Custom hook for managing AgentEval state and operations
 */
export const useAgentEval = (props: AgentEvalProps) => {
  const {
    appName,
    userId,
    apiBaseUrl = '',
    maxConcurrentEvals = 3,
    maxTestCases = 100,
    refreshInterval = 10000,
    enableAutoRefresh = false,
    initialEvaluations = [],
    selectedEvaluationId,
    availableTemplates = [],
    onEvaluationCreate,
    onEvaluationStart,
    onEvaluationComplete,
    onEvaluationCancel,
    onEvaluationDelete,
    onTestCaseSelect,
    onResultSelect,
    onExport,
    onError,
    onRefresh,
  } = props;

  // Core state
  const [evaluations, setEvaluations] =
    useState<EvaluationRun[]>(initialEvaluations);
  const [selectedEvaluation, setSelectedEvaluation] =
    useState<EvaluationRun | null>(null);
  const [selectedResult, setSelectedResult] = useState<EvaluationResult | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [templates, setTemplates] =
    useState<EvaluationTemplate[]>(availableTemplates);

  // Refs
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  /**
   * Fetch evaluations from API
   */
  const fetchEvaluations = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(
        `${apiBaseUrl}/evaluations?appName=${appName}&userId=${userId}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch evaluations: ${response.statusText}`);
      }

      const data: EvaluationRun[] = await response.json();
      setEvaluations(data);
      onRefresh?.();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl, appName, userId, onRefresh, onError]);

  /**
   * Create a new evaluation
   */
  const createEvaluation = useCallback(
    async (
      name: string,
      testCases: EvaluationTestCase[],
      metrics: EvaluationMetric[],
      config?: any
    ) => {
      try {
        setIsCreating(true);
        setError(null);

        const evaluation: Partial<EvaluationRun> = {
          name,
          appName,
          userId,
          status: 'pending',
          progress: 0,
          startTime: Date.now(),
          testCases,
          metrics,
          config,
        };

        const response = await fetch(`${apiBaseUrl}/evaluations`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(evaluation),
        });

        if (!response.ok) {
          throw new Error(
            `Failed to create evaluation: ${response.statusText}`
          );
        }

        const newEvaluation: EvaluationRun = await response.json();
        setEvaluations((prev) => [newEvaluation, ...prev]);
        setSelectedEvaluation(newEvaluation);
        onEvaluationCreate?.(newEvaluation);

        return newEvaluation;
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
        throw error;
      } finally {
        setIsCreating(false);
      }
    },
    [apiBaseUrl, appName, userId, onEvaluationCreate, onError]
  );

  /**
   * Start an evaluation
   */
  const startEvaluation = useCallback(
    async (evaluationId: string) => {
      try {
        setError(null);

        const response = await fetch(
          `${apiBaseUrl}/evaluations/${evaluationId}/start`,
          {
            method: 'POST',
          }
        );

        if (!response.ok) {
          throw new Error(`Failed to start evaluation: ${response.statusText}`);
        }

        // Update evaluation status
        setEvaluations((prev) =>
          prev.map((evaluation) =>
            evaluation.id === evaluationId
              ? { ...evaluation, status: 'running', progress: 0 }
              : evaluation
          )
        );

        onEvaluationStart?.(evaluationId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      }
    },
    [apiBaseUrl, onEvaluationStart, onError]
  );

  /**
   * Cancel an evaluation
   */
  const cancelEvaluation = useCallback(
    async (evaluationId: string) => {
      try {
        setError(null);

        const response = await fetch(
          `${apiBaseUrl}/evaluations/${evaluationId}/cancel`,
          {
            method: 'POST',
          }
        );

        if (!response.ok) {
          throw new Error(
            `Failed to cancel evaluation: ${response.statusText}`
          );
        }

        // Update evaluation status
        setEvaluations((prev) =>
          prev.map((evaluation) =>
            evaluation.id === evaluationId
              ? { ...evaluation, status: 'cancelled' }
              : evaluation
          )
        );

        onEvaluationCancel?.(evaluationId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      }
    },
    [apiBaseUrl, onEvaluationCancel, onError]
  );

  /**
   * Delete an evaluation
   */
  const deleteEvaluation = useCallback(
    async (evaluationId: string) => {
      try {
        setError(null);

        const response = await fetch(
          `${apiBaseUrl}/evaluations/${evaluationId}`,
          {
            method: 'DELETE',
          }
        );

        if (!response.ok) {
          throw new Error(
            `Failed to delete evaluation: ${response.statusText}`
          );
        }

        setEvaluations((prev) =>
          prev.filter((evaluation) => evaluation.id !== evaluationId)
        );

        if (selectedEvaluation?.id === evaluationId) {
          setSelectedEvaluation(null);
        }

        onEvaluationDelete?.(evaluationId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      }
    },
    [apiBaseUrl, selectedEvaluation, onEvaluationDelete, onError]
  );

  /**
   * Select an evaluation
   */
  const selectEvaluation = useCallback(
    (evaluationId: string) => {
      const evaluation = evaluations.find((e) => e.id === evaluationId);
      if (evaluation) {
        setSelectedEvaluation(evaluation);
      }
    },
    [evaluations]
  );

  /**
   * Select a result
   */
  const selectResult = useCallback(
    (result: EvaluationResult) => {
      setSelectedResult(result);
      onResultSelect?.(result);
    },
    [onResultSelect]
  );

  /**
   * Export evaluation data
   */
  const exportEvaluations = useCallback(
    async (options: EvaluationExportOptions) => {
      try {
        const evaluationsToExport = options.evaluationIds
          ? evaluations.filter((e) => options.evaluationIds!.includes(e.id))
          : evaluations;

        let exportData: any;
        let filename: string;
        let mimeType: string;

        switch (options.format) {
          case 'json':
            exportData = {
              evaluations: evaluationsToExport,
              ...(options.includeMetrics && {
                metrics: evaluationsToExport.flatMap((e) => e.metrics),
              }),
              exportedAt: new Date().toISOString(),
              exportedBy: userId,
            };
            filename = `evaluations-${
              new Date().toISOString().split('T')[0]
            }.json`;
            mimeType = 'application/json';
            break;

          case 'csv':
            const csvHeaders = [
              'id',
              'name',
              'status',
              'progress',
              'passRate',
              'averageScore',
              'duration',
            ];
            const csvRows = evaluationsToExport.map((evaluation) => [
              evaluation.id,
              evaluation.name,
              evaluation.status,
              evaluation.progress,
              evaluation.summary?.passRate || 0,
              evaluation.summary?.averageScore || 0,
              evaluation.duration || 0,
            ]);
            exportData = [csvHeaders, ...csvRows]
              .map((row) => row.join(','))
              .join('\n');
            filename = `evaluations-${
              new Date().toISOString().split('T')[0]
            }.csv`;
            mimeType = 'text/csv';
            break;

          default:
            throw new Error(`Export format ${options.format} not supported`);
        }

        // Create and download file
        const blob = new Blob(
          [
            typeof exportData === 'string'
              ? exportData
              : JSON.stringify(exportData, null, 2),
          ],
          {
            type: mimeType,
          }
        );
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
        onExport?.(options.format);
      } catch (err) {
        const error =
          err instanceof Error
            ? err
            : new Error('Failed to export evaluations');
        setError(error.message);
        onError?.(error);
      }
    },
    [evaluations, userId, onExport, onError]
  );

  /**
   * Filter evaluations based on search query
   */
  const getFilteredEvaluations = useCallback(() => {
    if (!searchQuery) return evaluations;

    const query = searchQuery.toLowerCase();
    return evaluations.filter(
      (evaluation) =>
        evaluation.name.toLowerCase().includes(query) ||
        evaluation.id.toLowerCase().includes(query) ||
        evaluation.status.toLowerCase().includes(query)
    );
  }, [evaluations, searchQuery]);

  /**
   * Get running evaluations count
   */
  const getRunningEvaluationsCount = useCallback(() => {
    return evaluations.filter((e) => e.status === 'running').length;
  }, [evaluations]);

  /**
   * Set up real-time updates via WebSocket
   */
  const setupRealTimeUpdates = useCallback(() => {
    if (!props.enableRealTimeUpdates) return;

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${apiBaseUrl.replace(
      /^https?:\/\//,
      ''
    )}/evaluations/ws?userId=${userId}`;

    wsRef.current = new WebSocket(wsUrl);

    wsRef.current.onmessage = (event) => {
      try {
        const update = JSON.parse(event.data);

        switch (update.type) {
          case 'progress':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? { ...e, progress: update.data.progress }
                  : e
              )
            );
            break;
          case 'result':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? {
                      ...e,
                      results: [...(e.results || []), update.data],
                    }
                  : e
              )
            );
            break;
          case 'complete':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? {
                      ...e,
                      status: 'completed',
                      endTime: update.timestamp,
                      duration: update.timestamp - e.startTime,
                      summary: update.data.summary,
                    }
                  : e
              )
            );
            onEvaluationComplete?.(update.data);
            break;
          case 'error':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? { ...e, status: 'failed', error: update.data.error }
                  : e
              )
            );
            break;
        }
      } catch (err) {
        console.error('Error parsing WebSocket message:', err);
      }
    };

    wsRef.current.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }, [props.enableRealTimeUpdates, apiBaseUrl, userId, onEvaluationComplete]);

  /**
   * Initialize evaluations on mount
   */
  useEffect(() => {
    fetchEvaluations();
    setupRealTimeUpdates();
  }, [fetchEvaluations, setupRealTimeUpdates]);

  /**
   * Set up auto-refresh
   */
  useEffect(() => {
    if (enableAutoRefresh && refreshInterval > 0) {
      refreshIntervalRef.current = setInterval(
        fetchEvaluations,
        refreshInterval
      );

      return () => {
        if (refreshIntervalRef.current) {
          clearInterval(refreshIntervalRef.current);
        }
      };
    }

    return () => {
      // Cleanup function for when auto-refresh is disabled
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
    };
  }, [enableAutoRefresh, refreshInterval, fetchEvaluations]);

  /**
   * Select initial evaluation
   */
  useEffect(() => {
    if (selectedEvaluationId && evaluations.length > 0 && !selectedEvaluation) {
      selectEvaluation(selectedEvaluationId);
    }
  }, [selectedEvaluationId, evaluations, selectedEvaluation, selectEvaluation]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  return {
    // State
    evaluations: getFilteredEvaluations(),
    selectedEvaluation,
    selectedResult,
    isLoading,
    isCreating,
    error,
    searchQuery,
    templates,

    // Actions
    fetchEvaluations,
    createEvaluation,
    startEvaluation,
    cancelEvaluation,
    deleteEvaluation,
    selectEvaluation,
    selectResult,
    exportEvaluations,
    setSearchQuery,
    setError,

    // Computed
    runningEvaluationsCount: getRunningEvaluationsCount(),
    canStartNewEvaluation: getRunningEvaluationsCount() < maxConcurrentEvals,
  };
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentEval component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentEvalStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  evaluationList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    padding: '16px',
  } as ViewProps,

  evaluationItem: {
    padding: '16px',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginBottom: '12px',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  activeEvaluationItem: {
    padding: '16px',
    borderRadius: '8px',
    border: '2px solid',
    borderColor: 'color.blue.500',
    backgroundColor: 'color.blue.50',
    cursor: 'pointer',
    marginBottom: '12px',
  } as ViewProps,

  evaluationHeader: {
    marginBottom: '12px',
  } as ViewProps,

  evaluationTitle: {
    fontSize: '16px',
    fontWeight: '600',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  evaluationMeta: {
    fontSize: '12px',
    color: 'color.gray.500',
  } as ViewProps,

  statusBadge: {
    padding: '4px 8px',
    fontSize: '11px',
    fontWeight: '600',
    borderRadius: '12px',
    textTransform: 'uppercase',
  } as ViewProps,

  statusPending: {
    backgroundColor: 'color.gray.100',
    color: 'color.gray.800',
  } as ViewProps,

  statusRunning: {
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
  } as ViewProps,

  statusCompleted: {
    backgroundColor: 'color.green.100',
    color: 'color.green.800',
  } as ViewProps,

  statusFailed: {
    backgroundColor: 'color.red.100',
    color: 'color.red.800',
  } as ViewProps,

  statusCancelled: {
    backgroundColor: 'color.yellow.100',
    color: 'color.yellow.800',
  } as ViewProps,

  progressBar: {
    width: '100%',
    height: '8px',
    backgroundColor: 'color.gray.200',
    borderRadius: '4px',
    overflow: 'hidden',
    marginTop: '8px',
  } as ViewProps,

  progressFill: {
    height: '100%',
    backgroundColor: 'color.blue.500',
    borderRadius: '4px',
    transition: 'width 0.3s ease',
  } as ViewProps,

  evaluationActions: {
    marginTop: '12px',
  } as ViewProps,

  actionButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    backgroundColor: 'color.white',
    color: 'color.gray.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginRight: '8px',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.700',
    },
  } as ViewProps,

  startButton: {
    borderColor: 'color.green.300',
    color: 'color.green.700',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  cancelButton: {
    borderColor: 'color.red.300',
    color: 'color.red.700',
    ':hover': {
      borderColor: 'color.red.400',
      backgroundColor: 'color.red.50',
      color: 'color.red.800',
    },
  } as ViewProps,

  deleteButton: {
    borderColor: 'color.red.300',
    color: 'color.red.700',
    ':hover': {
      borderColor: 'color.red.400',
      backgroundColor: 'color.red.50',
      color: 'color.red.800',
    },
  } as ViewProps,

  createPanel: {
    flex: 1,
    padding: '24px',
    backgroundColor: 'color.white',
    overflowY: 'auto',
  } as ViewProps,

  formGroup: {
    marginBottom: '20px',
  } as ViewProps,

  formLabel: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '8px',
    display: 'block',
  } as ViewProps,

  formInput: {
    width: '100%',
    padding: '8px 12px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    borderRadius: '6px',
    fontSize: '14px',
  } as ViewProps,

  formTextarea: {
    width: '100%',
    padding: '8px 12px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    borderRadius: '6px',
    fontSize: '14px',
    minHeight: '100px',
    resize: 'vertical',
  } as ViewProps,

  resultsPanel: {
    flex: 1,
    padding: '16px',
    backgroundColor: 'color.white',
    overflowY: 'auto',
  } as ViewProps,

  resultsSummary: {
    padding: '16px',
    backgroundColor: 'color.gray.50',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    marginBottom: '20px',
  } as ViewProps,

  summaryGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))',
    gap: '16px',
  } as ViewProps,

  summaryCard: {
    textAlign: 'center',
  } as ViewProps,

  summaryValue: {
    fontSize: '24px',
    fontWeight: '700',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  summaryLabel: {
    fontSize: '12px',
    color: 'color.gray.600',
    textTransform: 'uppercase',
    fontWeight: '600',
  } as ViewProps,

  testCaseList: {
    marginTop: '20px',
  } as ViewProps,

  testCaseItem: {
    padding: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    marginBottom: '8px',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  testCaseHeader: {
    marginBottom: '8px',
  } as ViewProps,

  testCaseName: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.900',
  } as ViewProps,

  testCaseStatus: {
    fontSize: '12px',
    fontWeight: '600',
    textTransform: 'uppercase',
  } as ViewProps,

  testCasePass: {
    color: 'color.green.700',
  } as ViewProps,

  testCaseFail: {
    color: 'color.red.700',
  } as ViewProps,

  testCaseError: {
    color: 'color.orange.700',
  } as ViewProps,

  testCaseSkip: {
    color: 'color.gray.600',
  } as ViewProps,

  metricsPanel: {
    flex: 1,
    padding: '16px',
    backgroundColor: 'color.white',
    overflowY: 'auto',
  } as ViewProps,

  metricsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '16px',
    marginBottom: '24px',
  } as ViewProps,

  metricCard: {
    padding: '16px',
    backgroundColor: 'color.white',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  metricTitle: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '8px',
  } as ViewProps,

  metricValue: {
    fontSize: '20px',
    fontWeight: '700',
    color: 'color.gray.900',
  } as ViewProps,

  metricChange: {
    fontSize: '12px',
    marginTop: '4px',
  } as ViewProps,

  metricIncrease: {
    color: 'color.green.600',
  } as ViewProps,

  metricDecrease: {
    color: 'color.red.600',
  } as ViewProps,

  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
  } as ViewProps,

  loadingState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
    gap: '16px',
  } as ViewProps,

  errorState: {
    padding: '16px',
    backgroundColor: 'color.red.50',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    margin: '16px',
  } as ViewProps,

  searchInput: {
    width: '100%',
  } as ViewProps,

  exportButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.green.300',
    backgroundColor: 'color.white',
    color: 'color.green.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  refreshButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.blue.300',
    backgroundColor: 'color.white',
    color: 'color.blue.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.800',
    },
  } as ViewProps,
};

/**
 * Size variants for AgentEval
 */
export const AgentEvalSizes = {
  sm: {
    container: { height: '400px' },
    evaluationList: { minHeight: '200px' },
  },
  md: {
    container: { height: '600px' },
    evaluationList: { minHeight: '300px' },
  },
  lg: {
    container: { height: '800px' },
    evaluationList: { minHeight: '400px' },
  },
  xl: {
    container: { height: '1000px' },
    evaluationList: { minHeight: '500px' },
  },
};

/**
 * Theme variants for AgentEval
 */
export const AgentEvalThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    evaluationList: { backgroundColor: 'color.white' },
    createPanel: { backgroundColor: 'color.white' },
    resultsPanel: { backgroundColor: 'color.white' },
    metricsPanel: { backgroundColor: 'color.white' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    evaluationList: { backgroundColor: 'color.gray.900' },
    createPanel: { backgroundColor: 'color.gray.900' },
    resultsPanel: { backgroundColor: 'color.gray.900' },
    metricsPanel: { backgroundColor: 'color.gray.900' },
  },
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.view.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { AgentEvalProps } from './AgentEval.props';
import { useAgentEval } from './AgentEval.state';
import { DefaultAgentEvalStyles } from './AgentEval.style';
import { EvaluationList } from './EvaluationList';
import { EvaluationCreator } from './EvaluationCreator';
import { EvaluationResults } from './EvaluationResults';
import { EvaluationMetrics } from './EvaluationMetrics';
import { Loader } from 'src/components/Loader/Loader';
import { TextField } from 'src/components/Form/Form';

export interface AgentEvalViewProps
  extends AgentEvalProps,
    ReturnType<typeof useAgentEval> {}

/**
 * AgentEval View Component
 *
 * Renders the complete evaluation interface with creation, monitoring, and results analysis
 */
const AgentEvalView: React.FC<AgentEvalViewProps> = ({
  // Props
  enableBatchEvaluation = true,
  enableMetricsComparison = true,
  enableResultExport = true,
  enableTemplates = true,
  showEvaluationHistory = true,
  showMetricsPanel = true,
  showTestCaseDetails = true,
  showProgressIndicators = true,
  compactMode = false,
  views,
  ariaLabel = 'Agent Evaluation Interface',
  ariaDescribedBy,

  // State from hook
  evaluations,
  selectedEvaluation,
  selectedResult,
  isLoading,
  isCreating,
  error,
  searchQuery,
  templates,
  runningEvaluationsCount,
  canStartNewEvaluation,
  fetchEvaluations,
  createEvaluation,
  startEvaluation,
  cancelEvaluation,
  deleteEvaluation,
  selectEvaluation,
  selectResult,
  exportEvaluations,
  setSearchQuery,
  setError,

  ...props
}) => {
  const [activeTab, setActiveTab] = React.useState('evaluations');
  /**
   * Handle evaluation creation
   */
  const handleCreateEvaluation = async (
    name: string,
    testCases: any[],
    metrics: any[]
  ) => {
    try {
      await createEvaluation(name, testCases, metrics);
    } catch (error) {
      // Error is handled in the hook
    }
  };

  /**
   * Handle evaluation start
   */
  const handleStartEvaluation = (evaluationId: string) => {
    startEvaluation(evaluationId);
  };

  /**
   * Handle evaluation cancel
   */
  const handleCancelEvaluation = (evaluationId: string) => {
    if (window.confirm('Are you sure you want to cancel this evaluation?')) {
      cancelEvaluation(evaluationId);
    }
  };

  /**
   * Handle evaluation delete
   */
  const handleDeleteEvaluation = (evaluationId: string) => {
    if (window.confirm('Are you sure you want to delete this evaluation?')) {
      deleteEvaluation(evaluationId);
    }
  };

  /**
   * Handle export
   */
  const handleExport = (format: 'json' | 'csv' | 'pdf') => {
    exportEvaluations({
      format,
      includeTestCases: true,
      includeResults: true,
      includeMetrics: true,
      includeSummary: true,
    });
  };

  /**
   * Handle refresh
   */
  const handleRefresh = () => {
    fetchEvaluations();
  };

  return (
    <View
      {...DefaultAgentEvalStyles.container}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentEvalStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Evaluation
            </Text>
            <Text fontSize="sm" color="color.gray.600">
              {evaluations.length} evaluation
              {evaluations.length !== 1 ? 's' : ''} •{runningEvaluationsCount}{' '}
              running
            </Text>
          </Vertical>

          <Horizontal gap={8}>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isLoading}
              aria-label="Refresh evaluations"
            >
              {isLoading ? <Loader size="xs" /> : '🔄'}
            </Button>

            {enableResultExport && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleExport('json')}
                disabled={evaluations.length === 0}
                aria-label="Export evaluations"
              >
                📤 Export
              </Button>
            )}
          </Horizontal>
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Text variant="error" onClick={() => setError(null)}>
          {error}
        </Text>
      )}

      {/* Search */}
      <View
        padding={16}
        borderBottom="1px solid"
        borderBottomColor="color.gray.200"
      >
        <TextField
          placeholder="Search evaluations..."
          value={searchQuery}
          onChange={setSearchQuery}
          views={{
            container: views?.searchInput,
          }}
        />
      </View>

      {/* Main Content */}
      <View flex={1} display="flex" flexDirection="column">
        {compactMode ? (
          // Compact mode - single view
          <EvaluationList
            evaluations={evaluations}
            selectedEvaluation={selectedEvaluation}
            onEvaluationSelect={selectEvaluation}
            onEvaluationStart={handleStartEvaluation}
            onEvaluationCancel={handleCancelEvaluation}
            onEvaluationDelete={handleDeleteEvaluation}
            showProgressIndicators={showProgressIndicators}
            compactMode={true}
            views={{
              container: views?.evaluationList,
              evaluationItem: views?.evaluationItem,
              activeEvaluationItem: views?.activeEvaluationItem,
            }}
          />
        ) : (
          // Full mode - tabbed interface
          <View flex={1} display="flex" flexDirection="column">
            {/* Tab Navigation */}
            <View
              display="flex"
              borderBottom="1px solid"
              borderBottomColor="color.gray.200"
              backgroundColor="color.gray.50"
            >
              <Button
                variant={activeTab === 'evaluations' ? 'filled' : 'ghost'}
                onClick={() => setActiveTab('evaluations')}
                borderRadius="0"
                borderBottom={
                  activeTab === 'evaluations' ? '2px solid' : 'none'
                }
                borderBottomColor="color.blue.500"
              >
                Evaluations
              </Button>
              <Button
                variant={activeTab === 'create' ? 'filled' : 'ghost'}
                onClick={() => setActiveTab('create')}
                borderRadius="0"
                borderBottom={activeTab === 'create' ? '2px solid' : 'none'}
                borderBottomColor="color.blue.500"
              >
                Create New
              </Button>
              {selectedEvaluation && (
                <Button
                  variant={activeTab === 'results' ? 'filled' : 'ghost'}
                  onClick={() => setActiveTab('results')}
                  borderRadius="0"
                  borderBottom={activeTab === 'results' ? '2px solid' : 'none'}
                  borderBottomColor="color.blue.500"
                >
                  Results
                </Button>
              )}
              {showMetricsPanel && (
                <Button
                  variant={activeTab === 'metrics' ? 'filled' : 'ghost'}
                  onClick={() => setActiveTab('metrics')}
                  borderRadius="0"
                  borderBottom={activeTab === 'metrics' ? '2px solid' : 'none'}
                  borderBottomColor="color.blue.500"
                >
                  Metrics
                </Button>
              )}
            </View>

            {/* Tab Content */}
            <View flex={1}>
              {activeTab === 'evaluations' && (
                <EvaluationList
                  evaluations={evaluations}
                  selectedEvaluation={selectedEvaluation}
                  onEvaluationSelect={selectEvaluation}
                  onEvaluationStart={handleStartEvaluation}
                  onEvaluationCancel={handleCancelEvaluation}
                  onEvaluationDelete={handleDeleteEvaluation}
                  showProgressIndicators={showProgressIndicators}
                  compactMode={false}
                  views={{
                    container: views?.evaluationList,
                    evaluationItem: views?.evaluationItem,
                    activeEvaluationItem: views?.activeEvaluationItem,
                  }}
                />
              )}

              {activeTab === 'create' && (
                <EvaluationCreator
                  templates={enableTemplates ? templates : []}
                  isCreating={isCreating}
                  canCreate={canStartNewEvaluation}
                  onCreateEvaluation={handleCreateEvaluation}
                  views={{
                    container: views?.createPanel,
                  }}
                />
              )}

              {activeTab === 'results' && selectedEvaluation && (
                <EvaluationResults
                  evaluation={selectedEvaluation}
                  selectedResult={selectedResult}
                  onResultSelect={selectResult}
                  showTestCaseDetails={showTestCaseDetails}
                  views={{
                    container: views?.resultsPanel,
                    testCaseList: views?.testCaseList,
                    testCaseItem: views?.testCaseItem,
                  }}
                />
              )}

              {activeTab === 'metrics' && showMetricsPanel && (
                <EvaluationMetrics
                  evaluations={evaluations}
                  enableComparison={enableMetricsComparison}
                  views={{
                    container: views?.metricsPanel,
                  }}
                />
              )}
            </View>
          </View>
        )}
      </View>

      {/* Loading State */}
      {isLoading && evaluations.length === 0 && (
        <View {...DefaultAgentEvalStyles.loadingState} {...views?.loadingState}>
          <Loader size="md" />
          <Text color="color.gray.600">Loading evaluations...</Text>
        </View>
      )}

      {/* Empty State */}
      {!isLoading && evaluations.length === 0 && (
        <View {...DefaultAgentEvalStyles.emptyState} {...views?.emptyState}>
          <Text fontSize="lg" color="color.gray.500" textAlign="center">
            No evaluations found
          </Text>
          <Text fontSize="sm" color="color.gray.400" textAlign="center">
            Create your first evaluation to get started
          </Text>
          <Button
            variant="filled"
            onClick={() => {
              // Switch to create tab if in tabbed mode
              const createTab = document.querySelector(
                '[data-value="create"]'
              ) as HTMLElement;
              createTab?.click();
            }}
            marginTop={16}
          >
            Create Evaluation
          </Button>
        </View>
      )}
    </View>
  );
};

export default AgentEvalView;
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationCreator.tsx">
import React, { useState } from 'react';
import { Select, TextArea, TextField } from 'src/components/Form/Form';

import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import {
  EvaluationTemplate,
  EvaluationTestCase,
  EvaluationMetric,
} from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationCreatorProps {
  templates: EvaluationTemplate[];
  isCreating: boolean;
  canCreate: boolean;
  onCreateEvaluation: (
    name: string,
    testCases: EvaluationTestCase[],
    metrics: EvaluationMetric[]
  ) => void;
  views?: {
    container?: any;
  };
}

/**
 * EvaluationCreator Component
 *
 * Form for creating new evaluations with test cases and metrics
 */
export const EvaluationCreator: React.FC<EvaluationCreatorProps> = ({
  templates,
  isCreating,
  canCreate,
  onCreateEvaluation,
  views = {},
}) => {
  const [name, setName] = useState('');
  const [selectedTemplate, setSelectedTemplate] = useState<string>('');
  const [testCasesText, setTestCasesText] = useState('');
  const [metricsText, setMetricsText] = useState('');

  /**
   * Handle template selection
   */
  const handleTemplateSelect = (templateId: string) => {
    setSelectedTemplate(templateId);
    const template = templates.find((t) => t.id === templateId);
    if (template) {
      setName(template.name);
      setTestCasesText(JSON.stringify(template.testCases, null, 2));
      setMetricsText(JSON.stringify(template.metrics, null, 2));
    }
  };

  /**
   * Handle form submission
   */
  const handleSubmit = () => {
    if (!name.trim()) {
      alert('Please enter a name for the evaluation');
      return;
    }

    try {
      const testCases = testCasesText ? JSON.parse(testCasesText) : [];
      const metrics = metricsText ? JSON.parse(metricsText) : [];

      onCreateEvaluation(name, testCases, metrics);

      // Reset form
      setName('');
      setSelectedTemplate('');
      setTestCasesText('');
      setMetricsText('');
    } catch (error) {
      alert('Invalid JSON in test cases or metrics');
    }
  };

  /**
   * Load sample data
   */
  const loadSampleData = () => {
    setName('Sample Evaluation');
    setTestCasesText(
      JSON.stringify(
        [
          {
            id: 'test-1',
            name: 'Basic Question',
            description: 'Test basic question answering',
            input: { question: 'What is 2+2?' },
            expectedOutput: { answer: '4' },
            tags: ['math', 'basic'],
          },
          {
            id: 'test-2',
            name: 'Complex Question',
            description: 'Test complex reasoning',
            input: { question: 'Explain the concept of recursion' },
            expectedOutput: { answer: 'A function that calls itself...' },
            tags: ['programming', 'complex'],
          },
        ],
        null,
        2
      )
    );

    setMetricsText(
      JSON.stringify(
        [
          {
            id: 'accuracy',
            name: 'Accuracy',
            description: 'Measures correctness of answers',
            type: 'accuracy',
            threshold: 0.8,
            weight: 1.0,
          },
          {
            id: 'latency',
            name: 'Response Time',
            description: 'Measures response latency',
            type: 'latency',
            threshold: 5000,
            weight: 0.5,
          },
        ],
        null,
        2
      )
    );
  };

  return (
    <View {...DefaultAgentEvalStyles.createPanel} {...views.container}>
      <Vertical gap={24}>
        <Text fontSize="lg" fontWeight="600">
          Create New Evaluation
        </Text>

        {!canCreate && (
          <View
            padding={12}
            backgroundColor="color.yellow.50"
            borderRadius="8px"
            border="1px solid"
            borderColor="color.yellow.200"
          >
            <Text fontSize="sm" color="color.yellow.800">
              ⚠️ Maximum concurrent evaluations reached. Please wait for running
              evaluations to complete.
            </Text>
          </View>
        )}

        {/* Template Selection */}
        {templates.length > 0 && (
          <View {...DefaultAgentEvalStyles.formGroup}>
            <Text {...DefaultAgentEvalStyles.formLabel}>
              Use Template (Optional)
            </Text>
            <Select
              value={selectedTemplate}
              onChange={handleTemplateSelect}
              options={[
                { value: '', label: 'No template' },
                ...templates.map((t) => ({ value: t.id, label: t.name })),
              ]}
              placeholder="Select a template"
            />
          </View>
        )}

        {/* Evaluation Name */}
        <View {...DefaultAgentEvalStyles.formGroup}>
          <Text {...DefaultAgentEvalStyles.formLabel}>Evaluation Name *</Text>
          <TextField
            value={name}
            onChange={setName}
            placeholder="Enter evaluation name"
            disabled={isCreating}
          />
        </View>

        {/* Test Cases */}
        <View {...DefaultAgentEvalStyles.formGroup}>
          <Horizontal
            justifyContent="space-between"
            alignItems="center"
            marginBottom={8}
          >
            <Text {...DefaultAgentEvalStyles.formLabel}>Test Cases (JSON)</Text>
            <Button
              variant="outline"
              size="sm"
              onClick={loadSampleData}
              disabled={isCreating}
            >
              Load Sample
            </Button>
          </Horizontal>
          <TextArea
            value={testCasesText}
            onChange={(e) => setTestCasesText(e.target.value)}
            placeholder="Enter test cases as JSON array"
            disabled={isCreating}
            style={{
              width: '100%',
              minHeight: '200px',
              padding: '8px 12px',
              border: '1px solid',
              borderColor: 'color.gray.300',
              borderRadius: '6px',
              fontSize: '14px',
            }}
          />
          <Text fontSize="xs" color="color.gray.600" marginTop={4}>
            Each test case should have: id, name, input, expectedOutput
            (optional)
          </Text>
        </View>

        {/* Metrics */}
        <View {...DefaultAgentEvalStyles.formGroup}>
          <Text {...DefaultAgentEvalStyles.formLabel}>Metrics (JSON)</Text>
          <TextArea
            value={metricsText}
            onChange={(e) => setMetricsText(e.target.value)}
            placeholder="Enter metrics as JSON array"
            disabled={isCreating}
            style={{
              width: '100%',
              minHeight: '150px',
              padding: '8px 12px',
              border: '1px solid',
              borderColor: 'color.gray.300',
              borderRadius: '6px',
              fontSize: '14px',
            }}
          />
          <Text fontSize="xs" color="color.gray.600" marginTop={4}>
            Each metric should have: id, name, type, threshold (optional),
            weight (optional)
          </Text>
        </View>

        {/* Actions */}
        <Horizontal gap={12}>
          <Button
            variant="filled"
            onClick={handleSubmit}
            disabled={!name.trim() || isCreating || !canCreate}
            loading={isCreating}
          >
            {isCreating ? 'Creating...' : 'Create Evaluation'}
          </Button>

          <Button
            variant="outline"
            onClick={() => {
              setName('');
              setSelectedTemplate('');
              setTestCasesText('');
              setMetricsText('');
            }}
            disabled={isCreating}
          >
            Clear
          </Button>
        </Horizontal>

        {/* Help Text */}
        <View
          padding={16}
          backgroundColor="color.blue.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.blue.200"
        >
          <Text
            fontSize="sm"
            fontWeight="600"
            color="color.blue.800"
            marginBottom={8}
          >
            💡 Tips for Creating Evaluations
          </Text>
          <Vertical gap={4}>
            <Text fontSize="sm" color="color.blue.700">
              • Use descriptive names for test cases to easily identify them
            </Text>
            <Text fontSize="sm" color="color.blue.700">
              • Include diverse test cases to thoroughly evaluate your agent
            </Text>
            <Text fontSize="sm" color="color.blue.700">
              • Set appropriate thresholds for metrics based on your
              requirements
            </Text>
            <Text fontSize="sm" color="color.blue.700">
              • Use tags to categorize and filter test cases
            </Text>
          </Vertical>
        </View>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationList.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { EvaluationRun } from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationListProps {
  evaluations: EvaluationRun[];
  selectedEvaluation?: EvaluationRun | null;
  onEvaluationSelect: (evaluationId: string) => void;
  onEvaluationStart: (evaluationId: string) => void;
  onEvaluationCancel: (evaluationId: string) => void;
  onEvaluationDelete: (evaluationId: string) => void;
  showProgressIndicators?: boolean;
  compactMode?: boolean;
  views?: {
    container?: any;
    evaluationItem?: any;
    activeEvaluationItem?: any;
  };
}

/**
 * EvaluationList Component
 * 
 * Renders a list of evaluations with status, progress, and actions
 */
export const EvaluationList: React.FC<EvaluationListProps> = ({
  evaluations,
  selectedEvaluation,
  onEvaluationSelect,
  onEvaluationStart,
  onEvaluationCancel,
  onEvaluationDelete,
  showProgressIndicators = true,
  compactMode = false,
  views = {},
}) => {
  /**
   * Get status badge style
   */
  const getStatusStyle = (status: string) => {
    const baseStyle = DefaultAgentEvalStyles.statusBadge;
    
    switch (status) {
      case 'pending':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusPending };
      case 'running':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusRunning };
      case 'completed':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusCompleted };
      case 'failed':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusFailed };
      case 'cancelled':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusCancelled };
      default:
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusPending };
    }
  };

  /**
   * Format duration
   */
  const formatDuration = (duration?: number) => {
    if (!duration) return '';
    if (duration < 60000) return `${Math.round(duration / 1000)}s`;
    return `${Math.round(duration / 60000)}m`;
  };

  /**
   * Format timestamp
   */
  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp).toLocaleDateString([], {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <View {...DefaultAgentEvalStyles.evaluationList} {...views.container}>
      <Vertical gap={compactMode ? 8 : 12}>
        {evaluations.map((evaluation) => {
          const isSelected = selectedEvaluation?.id === evaluation.id;
          const containerStyle = isSelected 
            ? { ...DefaultAgentEvalStyles.activeEvaluationItem, ...views.activeEvaluationItem }
            : { ...DefaultAgentEvalStyles.evaluationItem, ...views.evaluationItem };

          return (
            <View
              key={evaluation.id}
              {...containerStyle}
              onClick={() => onEvaluationSelect(evaluation.id)}
            >
              <Vertical gap={compactMode ? 8 : 12}>
                {/* Evaluation Header */}
                <Horizontal justifyContent="space-between" alignItems="flex-start">
                  <Vertical gap={4}>
                    <Text {...DefaultAgentEvalStyles.evaluationTitle}>
                      {evaluation.name}
                    </Text>
                    <Horizontal gap={12} alignItems="center">
                      <View {...getStatusStyle(evaluation.status)}>
                        <Text>{evaluation.status}</Text>
                      </View>
                      <Text {...DefaultAgentEvalStyles.evaluationMeta}>
                        {evaluation.testCases.length} test{evaluation.testCases.length !== 1 ? 's' : ''}
                      </Text>
                      <Text {...DefaultAgentEvalStyles.evaluationMeta}>
                        {formatTimestamp(evaluation.startTime)}
                      </Text>
                      {evaluation.duration && (
                        <Text {...DefaultAgentEvalStyles.evaluationMeta}>
                          {formatDuration(evaluation.duration)}
                        </Text>
                      )}
                    </Horizontal>
                  </Vertical>
                </Horizontal>

                {/* Progress Bar */}
                {showProgressIndicators && evaluation.status === 'running' && (
                  <View>
                    <Horizontal justifyContent="space-between" alignItems="center" marginBottom={4}>
                      <Text fontSize="xs" color="color.gray.600">
                        Progress
                      </Text>
                      <Text fontSize="xs" color="color.gray.600">
                        {evaluation.progress}%
                      </Text>
                    </Horizontal>
                    <View {...DefaultAgentEvalStyles.progressBar}>
                      <View 
                        {...DefaultAgentEvalStyles.progressFill}
                        style={{ width: `${evaluation.progress}%` }}
                      />
                    </View>
                  </View>
                )}

                {/* Summary (for completed evaluations) */}
                {evaluation.summary && !compactMode && (
                  <Horizontal gap={16} alignItems="center">
                    <Text fontSize="sm" color="color.green.700">
                      ✅ {evaluation.summary.passedTests} passed
                    </Text>
                    {evaluation.summary.failedTests > 0 && (
                      <Text fontSize="sm" color="color.red.700">
                        ❌ {evaluation.summary.failedTests} failed
                      </Text>
                    )}
                    <Text fontSize="sm" color="color.gray.600">
                      Avg Score: {evaluation.summary.averageScore.toFixed(1)}
                    </Text>
                    <Text fontSize="sm" color="color.gray.600">
                      Pass Rate: {(evaluation.summary.passRate * 100).toFixed(1)}%
                    </Text>
                  </Horizontal>
                )}

                {/* Error Message */}
                {evaluation.error && (
                  <View 
                    padding={8} 
                    backgroundColor="color.red.50" 
                    borderRadius="4px"
                    border="1px solid"
                    borderColor="color.red.200"
                  >
                    <Text fontSize="sm" color="color.red.700">
                      Error: {evaluation.error}
                    </Text>
                  </View>
                )}

                {/* Actions */}
                <View {...DefaultAgentEvalStyles.evaluationActions}>
                  <Horizontal gap={8}>
                    {evaluation.status === 'pending' && (
                      <Button
                        {...DefaultAgentEvalStyles.actionButton}
                        {...DefaultAgentEvalStyles.startButton}
                        onClick={(e) => {
                          e.stopPropagation();
                          onEvaluationStart(evaluation.id);
                        }}
                        size="sm"
                      >
                        ▶️ Start
                      </Button>
                    )}
                    
                    {evaluation.status === 'running' && (
                      <Button
                        {...DefaultAgentEvalStyles.actionButton}
                        {...DefaultAgentEvalStyles.cancelButton}
                        onClick={(e) => {
                          e.stopPropagation();
                          onEvaluationCancel(evaluation.id);
                        }}
                        size="sm"
                      >
                        ⏹️ Cancel
                      </Button>
                    )}
                    
                    {(evaluation.status === 'completed' || evaluation.status === 'failed' || evaluation.status === 'cancelled') && (
                      <Button
                        {...DefaultAgentEvalStyles.actionButton}
                        {...DefaultAgentEvalStyles.deleteButton}
                        onClick={(e) => {
                          e.stopPropagation();
                          onEvaluationDelete(evaluation.id);
                        }}
                        size="sm"
                      >
                        🗑️ Delete
                      </Button>
                    )}
                  </Horizontal>
                </View>
              </Vertical>
            </View>
          );
        })}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationMetrics.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { EvaluationRun } from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationMetricsProps {
  evaluations: EvaluationRun[];
  enableComparison?: boolean;
  views?: {
    container?: any;
  };
}

/**
 * EvaluationMetrics Component
 * 
 * Displays aggregated metrics and comparisons across evaluations
 */
export const EvaluationMetrics: React.FC<EvaluationMetricsProps> = ({
  evaluations,
  enableComparison = true,
  views = {},
}) => {
  /**
   * Calculate overall metrics
   */
  const calculateOverallMetrics = () => {
    const completedEvaluations = evaluations.filter(e => e.status === 'completed' && e.summary);
    
    if (completedEvaluations.length === 0) {
      return null;
    }

    const totalTests = completedEvaluations.reduce((sum, e) => sum + (e.summary?.totalTests || 0), 0);
    const totalPassed = completedEvaluations.reduce((sum, e) => sum + (e.summary?.passedTests || 0), 0);
    const totalFailed = completedEvaluations.reduce((sum, e) => sum + (e.summary?.failedTests || 0), 0);
    const avgScore = completedEvaluations.reduce((sum, e) => sum + (e.summary?.averageScore || 0), 0) / completedEvaluations.length;
    const avgPassRate = completedEvaluations.reduce((sum, e) => sum + (e.summary?.passRate || 0), 0) / completedEvaluations.length;
    const totalDuration = completedEvaluations.reduce((sum, e) => sum + (e.summary?.totalDuration || 0), 0);

    return {
      totalEvaluations: completedEvaluations.length,
      totalTests,
      totalPassed,
      totalFailed,
      avgScore,
      avgPassRate,
      totalDuration,
    };
  };

  /**
   * Get recent evaluations for trend analysis
   */
  const getRecentEvaluations = (count = 5) => {
    return evaluations
      .filter(e => e.status === 'completed' && e.summary)
      .sort((a, b) => b.startTime - a.startTime)
      .slice(0, count);
  };

  /**
   * Format duration
   */
  const formatDuration = (duration: number) => {
    if (duration < 60000) return `${Math.round(duration / 1000)}s`;
    if (duration < 3600000) return `${Math.round(duration / 60000)}m`;
    return `${Math.round(duration / 3600000)}h`;
  };

  const overallMetrics = calculateOverallMetrics();
  const recentEvaluations = getRecentEvaluations();

  return (
    <View {...DefaultAgentEvalStyles.metricsPanel} {...views.container}>
      <Vertical gap={32}>
        {/* Overall Metrics */}
        {overallMetrics && (
          <View>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Overall Performance
            </Text>
            
            <View {...DefaultAgentEvalStyles.metricsGrid}>
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Total Evaluations
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {overallMetrics.totalEvaluations}
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Total Tests
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {overallMetrics.totalTests}
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Average Score
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {overallMetrics.avgScore.toFixed(1)}
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Pass Rate
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {(overallMetrics.avgPassRate * 100).toFixed(1)}%
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Success Rate
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {((overallMetrics.totalPassed / overallMetrics.totalTests) * 100).toFixed(1)}%
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Total Time
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {formatDuration(overallMetrics.totalDuration)}
                </Text>
              </View>
            </View>
          </View>
        )}

        {/* Recent Evaluations Trend */}
        {recentEvaluations.length > 0 && (
          <View>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Recent Performance Trend
            </Text>
            
            <View 
              padding={16} 
              backgroundColor="color.gray.50" 
              borderRadius="8px"
              border="1px solid"
              borderColor="color.gray.200"
            >
              <Vertical gap={12}>
                {recentEvaluations.map((evaluation, index) => (
                  <Horizontal key={evaluation.id} justifyContent="space-between" alignItems="center">
                    <Vertical gap={2}>
                      <Text fontSize="sm" fontWeight="600">
                        {evaluation.name}
                      </Text>
                      <Text fontSize="xs" color="color.gray.600">
                        {new Date(evaluation.startTime).toLocaleDateString()}
                      </Text>
                    </Vertical>
                    
                    <Horizontal gap={16} alignItems="center">
                      <Text fontSize="sm" color="color.green.700">
                        {evaluation.summary?.passedTests || 0} passed
                      </Text>
                      <Text fontSize="sm" color="color.red.700">
                        {evaluation.summary?.failedTests || 0} failed
                      </Text>
                      <Text fontSize="sm" fontWeight="600">
                        {evaluation.summary?.averageScore.toFixed(1) || 0} avg
                      </Text>
                      <Text fontSize="sm" color="color.gray.600">
                        {((evaluation.summary?.passRate || 0) * 100).toFixed(1)}%
                      </Text>
                    </Horizontal>
                  </Horizontal>
                ))}
              </Vertical>
            </View>
          </View>
        )}

        {/* Evaluation Status Distribution */}
        <View>
          <Text fontSize="lg" fontWeight="600" marginBottom={16}>
            Evaluation Status
          </Text>
          
          <View {...DefaultAgentEvalStyles.metricsGrid}>
            {['completed', 'running', 'failed', 'cancelled', 'pending'].map(status => {
              const count = evaluations.filter(e => e.status === status).length;
              const percentage = evaluations.length > 0 ? (count / evaluations.length) * 100 : 0;
              
              return (
                <View key={status} {...DefaultAgentEvalStyles.metricCard}>
                  <Text {...DefaultAgentEvalStyles.metricTitle} textTransform="capitalize">
                    {status}
                  </Text>
                  <Text {...DefaultAgentEvalStyles.metricValue}>
                    {count}
                  </Text>
                  <Text fontSize="xs" color="color.gray.600">
                    {percentage.toFixed(1)}%
                  </Text>
                </View>
              );
            })}
          </View>
        </View>

        {/* Performance Insights */}
        {overallMetrics && (
          <View>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Performance Insights
            </Text>
            
            <View 
              padding={16} 
              backgroundColor="color.blue.50" 
              borderRadius="8px"
              border="1px solid"
              borderColor="color.blue.200"
            >
              <Vertical gap={8}>
                <Text fontSize="sm" fontWeight="600" color="color.blue.800">
                  📊 Key Insights
                </Text>
                
                {overallMetrics.avgPassRate > 0.9 && (
                  <Text fontSize="sm" color="color.green.700">
                    ✅ Excellent performance with {(overallMetrics.avgPassRate * 100).toFixed(1)}% average pass rate
                  </Text>
                )}
                
                {overallMetrics.avgPassRate < 0.7 && (
                  <Text fontSize="sm" color="color.red.700">
                    ⚠️ Consider reviewing test cases or agent configuration (pass rate: {(overallMetrics.avgPassRate * 100).toFixed(1)}%)
                  </Text>
                )}
                
                {overallMetrics.totalEvaluations >= 10 && (
                  <Text fontSize="sm" color="color.blue.700">
                    📈 Good evaluation coverage with {overallMetrics.totalEvaluations} completed evaluations
                  </Text>
                )}
                
                {overallMetrics.totalEvaluations < 5 && (
                  <Text fontSize="sm" color="color.yellow.700">
                    💡 Consider running more evaluations for better performance insights
                  </Text>
                )}
              </Vertical>
            </View>
          </View>
        )}

        {/* Empty State */}
        {!overallMetrics && (
          <View textAlign="center" padding={32}>
            <Text fontSize="lg" color="color.gray.500">
              No completed evaluations yet
            </Text>
            <Text fontSize="sm" color="color.gray.400" marginTop={8}>
              Run some evaluations to see performance metrics
            </Text>
          </View>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationResults.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { EvaluationRun, EvaluationResult } from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationResultsProps {
  evaluation: EvaluationRun;
  selectedResult?: EvaluationResult | null;
  onResultSelect: (result: EvaluationResult) => void;
  showTestCaseDetails?: boolean;
  views?: {
    container?: any;
    testCaseList?: any;
    testCaseItem?: any;
  };
}

/**
 * EvaluationResults Component
 * 
 * Displays evaluation results with summary and detailed test case results
 */
export const EvaluationResults: React.FC<EvaluationResultsProps> = ({
  evaluation,
  selectedResult,
  onResultSelect,
  showTestCaseDetails = true,
  views = {},
}) => {
  /**
   * Get test case status style
   */
  const getTestCaseStatusStyle = (status: string) => {
    const baseStyle = DefaultAgentEvalStyles.testCaseStatus;
    
    switch (status) {
      case 'pass':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCasePass };
      case 'fail':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCaseFail };
      case 'error':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCaseError };
      case 'skip':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCaseSkip };
      default:
        return baseStyle;
    }
  };

  /**
   * Get status icon
   */
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'pass':
        return '✅';
      case 'fail':
        return '❌';
      case 'error':
        return '⚠️';
      case 'skip':
        return '⏭️';
      default:
        return '❓';
    }
  };

  /**
   * Format duration
   */
  const formatDuration = (duration: number) => {
    if (duration < 1000) return `${duration}ms`;
    return `${(duration / 1000).toFixed(2)}s`;
  };

  return (
    <View {...DefaultAgentEvalStyles.resultsPanel} {...views.container}>
      <Vertical gap={24}>
        {/* Summary */}
        {evaluation.summary && (
          <View {...DefaultAgentEvalStyles.resultsSummary}>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Evaluation Summary
            </Text>
            
            <View {...DefaultAgentEvalStyles.summaryGrid}>
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {evaluation.summary.totalTests}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Total Tests
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text 
                  {...DefaultAgentEvalStyles.summaryValue}
                  color="color.green.600"
                >
                  {evaluation.summary.passedTests}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Passed
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text 
                  {...DefaultAgentEvalStyles.summaryValue}
                  color="color.red.600"
                >
                  {evaluation.summary.failedTests}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Failed
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {evaluation.summary.averageScore.toFixed(1)}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Avg Score
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {(evaluation.summary.passRate * 100).toFixed(1)}%
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Pass Rate
                </Text>
              </View>
              
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {formatDuration(evaluation.summary.totalDuration)}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Total Time
                </Text>
              </View>
            </View>
          </View>
        )}

        {/* Test Case Results */}
        <View>
          <Text fontSize="lg" fontWeight="600" marginBottom={16}>
            Test Case Results
          </Text>
          
          <View {...DefaultAgentEvalStyles.testCaseList} {...views.testCaseList}>
            <Vertical gap={8}>
              {evaluation.testCases.map((testCase) => {
                const result = evaluation.results?.find(r => r.testCaseId === testCase.id);
                const isSelected = selectedResult?.testCaseId === testCase.id;
                
                return (
                  <View
                    key={testCase.id}
                    {...DefaultAgentEvalStyles.testCaseItem}
                    {...views.testCaseItem}
                    onClick={() => result && onResultSelect(result)}
                    style={{
                      borderColor: isSelected ? '#3b82f6' : undefined,
                      backgroundColor: isSelected ? '#eff6ff' : undefined,
                    }}
                  >
                    <Vertical gap={8}>
                      {/* Test Case Header */}
                      <Horizontal justifyContent="space-between" alignItems="center">
                        <Horizontal gap={8} alignItems="center">
                          <Text fontSize="16px">
                            {result ? getStatusIcon(result.status) : '⏳'}
                          </Text>
                          <Text {...DefaultAgentEvalStyles.testCaseName}>
                            {testCase.name}
                          </Text>
                          {result && (
                            <Text {...getTestCaseStatusStyle(result.status)}>
                              {result.status}
                            </Text>
                          )}
                        </Horizontal>
                        
                        <Horizontal gap={12} alignItems="center">
                          {result?.score !== undefined && (
                            <Text fontSize="sm" fontWeight="600" color="color.gray.700">
                              Score: {result.score.toFixed(2)}
                            </Text>
                          )}
                          {result?.duration && (
                            <Text fontSize="sm" color="color.gray.600">
                              {formatDuration(result.duration)}
                            </Text>
                          )}
                        </Horizontal>
                      </Horizontal>

                      {/* Test Case Description */}
                      {testCase.description && (
                        <Text fontSize="sm" color="color.gray.600">
                          {testCase.description}
                        </Text>
                      )}

                      {/* Tags */}
                      {testCase.tags && testCase.tags.length > 0 && (
                        <Horizontal gap={4} flexWrap="wrap">
                          {testCase.tags.map((tag, index) => (
                            <View
                              key={index}
                              padding="2px 6px"
                              backgroundColor="color.blue.100"
                              borderRadius="4px"
                              border="1px solid"
                              borderColor="color.blue.200"
                            >
                              <Text fontSize="10px" color="color.blue.800">
                                {tag}
                              </Text>
                            </View>
                          ))}
                        </Horizontal>
                      )}

                      {/* Error Message */}
                      {result?.error && (
                        <View 
                          padding={8} 
                          backgroundColor="color.red.50" 
                          borderRadius="4px"
                          border="1px solid"
                          borderColor="color.red.200"
                        >
                          <Text fontSize="sm" color="color.red.700">
                            Error: {result.error}
                          </Text>
                        </View>
                      )}

                      {/* Detailed Results (when selected) */}
                      {isSelected && result && showTestCaseDetails && (
                        <View 
                          padding={12} 
                          backgroundColor="color.gray.50" 
                          borderRadius="6px"
                          marginTop={8}
                        >
                          <Vertical gap={12}>
                            <Text fontSize="sm" fontWeight="600" color="color.gray.700">
                              Test Case Details
                            </Text>
                            
                            {/* Input */}
                            <View>
                              <Text fontSize="xs" fontWeight="600" color="color.gray.700" marginBottom={4}>
                                Input
                              </Text>
                              <View 
                                padding={8} 
                                backgroundColor="color.white" 
                                borderRadius="4px"
                                border="1px solid"
                                borderColor="color.gray.200"
                              >
                                <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                                  {JSON.stringify(testCase.input, null, 2)}
                                </Text>
                              </View>
                            </View>

                            {/* Expected Output */}
                            {testCase.expectedOutput && (
                              <View>
                                <Text fontSize="xs" fontWeight="600" color="color.gray.700" marginBottom={4}>
                                  Expected Output
                                </Text>
                                <View 
                                  padding={8} 
                                  backgroundColor="color.white" 
                                  borderRadius="4px"
                                  border="1px solid"
                                  borderColor="color.gray.200"
                                >
                                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                                    {JSON.stringify(testCase.expectedOutput, null, 2)}
                                  </Text>
                                </View>
                              </View>
                            )}

                            {/* Actual Output */}
                            {result.actualOutput && (
                              <View>
                                <Text fontSize="xs" fontWeight="600" color="color.gray.700" marginBottom={4}>
                                  Actual Output
                                </Text>
                                <View 
                                  padding={8} 
                                  backgroundColor="color.white" 
                                  borderRadius="4px"
                                  border="1px solid"
                                  borderColor="color.gray.200"
                                >
                                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                                    {JSON.stringify(result.actualOutput, null, 2)}
                                  </Text>
                                </View>
                              </View>
                            )}

                            {/* Metrics */}
                            {Object.keys(result.metrics).length > 0 && (
                              <View>
                                <Text fontSize="xs" fontWeight="600" color="color.gray.700" marginBottom={4}>
                                  Metrics
                                </Text>
                                <Horizontal gap={8} flexWrap="wrap">
                                  {Object.entries(result.metrics).map(([metric, value]) => (
                                    <View
                                      key={metric}
                                      padding="4px 8px"
                                      backgroundColor="color.blue.50"
                                      borderRadius="4px"
                                      border="1px solid"
                                      borderColor="color.blue.200"
                                    >
                                      <Text fontSize="xs" color="color.blue.800">
                                        {metric}: {value.toFixed(3)}
                                      </Text>
                                    </View>
                                  ))}
                                </Horizontal>
                              </View>
                            )}
                          </Vertical>
                        </View>
                      )}
                    </Vertical>
                  </View>
                );
              })}
            </Vertical>
          </View>
        </View>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text } from 'app-studio';
import { AgentEval } from '../AgentEval';
import { EvaluationRun } from '../AgentEval/AgentEval.props';

/**
 * Default AgentEval Example
 *
 * Demonstrates basic usage of the AgentEval component
 */
export const DefaultDemo = () => {
  const [selectedEvaluation, setSelectedEvaluation] =
    useState<EvaluationRun | null>(null);

  const handleEvaluationCreate = (evaluation: EvaluationRun) => {
    console.log('Evaluation created:', evaluation);
    setSelectedEvaluation(evaluation);
  };

  const handleEvaluationComplete = (evaluation: EvaluationRun) => {
    console.log('Evaluation completed:', evaluation);
  };

  const handleError = (error: Error) => {
    console.error('AgentEval error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentEval Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A comprehensive evaluation component for ADK agents. Handles evaluation
        creation, execution, monitoring, and results analysis.
      </Text>

      {/* Selected Evaluation Info */}
      {selectedEvaluation && (
        <View
          padding={16}
          backgroundColor="color.green.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.green.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.green.800">
            Active Evaluation
          </Text>
          <Text fontSize={12} color="color.green.600">
            Name: {selectedEvaluation.name}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Status: {selectedEvaluation.status}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Progress: {selectedEvaluation.progress}%
          </Text>
        </View>
      )}

      {/* AgentEval Component */}
      <View
        height="700px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentEval
          appName="demo-agent"
          userId="demo-user"
          apiBaseUrl="http://localhost:3000/adk"
          enableBatchEvaluation={true}
          enableMetricsComparison={true}
          enableResultExport={true}
          enableTemplates={true}
          showEvaluationHistory={true}
          showMetricsPanel={true}
          showTestCaseDetails={true}
          showProgressIndicators={true}
          maxConcurrentEvals={3}
          enableAutoRefresh={false}
          onEvaluationCreate={handleEvaluationCreate}
          onEvaluationComplete={handleEvaluationComplete}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * AgentEval with Mock Data Example
 *
 * Shows the component with sample evaluation data
 */
export const MockDataDemo = () => {
  const mockEvaluations: EvaluationRun[] = [
    {
      id: 'eval-1',
      name: 'Customer Support Evaluation',
      appName: 'support-agent',
      userId: 'user123',
      status: 'completed',
      progress: 100,
      startTime: Date.now() - 3600000,
      endTime: Date.now() - 3000000,
      duration: 600000,
      testCases: [
        {
          id: 'test-1',
          name: 'Basic Greeting',
          description: 'Test agent greeting response',
          input: { message: 'Hello' },
          expectedOutput: { response: 'Hello! How can I help you today?' },
          tags: ['greeting', 'basic'],
        },
        {
          id: 'test-2',
          name: 'Product Question',
          description: 'Test product information query',
          input: { message: 'Tell me about your pricing' },
          expectedOutput: { response: 'Our pricing starts at...' },
          tags: ['product', 'pricing'],
        },
      ],
      metrics: [
        {
          id: 'accuracy',
          name: 'Response Accuracy',
          description: 'Measures correctness of responses',
          type: 'accuracy',
          threshold: 0.8,
          weight: 1.0,
        },
        {
          id: 'latency',
          name: 'Response Time',
          description: 'Measures response latency',
          type: 'latency',
          threshold: 3000,
          weight: 0.5,
        },
      ],
      results: [
        {
          id: 'result-1',
          evaluationId: 'eval-1',
          testCaseId: 'test-1',
          status: 'pass',
          score: 0.95,
          actualOutput: { response: 'Hello! How can I help you today?' },
          metrics: { accuracy: 0.95, latency: 1200 },
          duration: 1200,
          timestamp: Date.now() - 3500000,
        },
        {
          id: 'result-2',
          evaluationId: 'eval-1',
          testCaseId: 'test-2',
          status: 'pass',
          score: 0.88,
          actualOutput: { response: 'Our pricing starts at $29/month...' },
          metrics: { accuracy: 0.88, latency: 2100 },
          duration: 2100,
          timestamp: Date.now() - 3400000,
        },
      ],
      summary: {
        totalTests: 2,
        passedTests: 2,
        failedTests: 0,
        errorTests: 0,
        skippedTests: 0,
        averageScore: 0.915,
        totalDuration: 3300,
        metricsAverages: { accuracy: 0.915, latency: 1650 },
        passRate: 1.0,
      },
    },
    {
      id: 'eval-2',
      name: 'Code Review Assistant',
      appName: 'code-agent',
      userId: 'user123',
      status: 'running',
      progress: 60,
      startTime: Date.now() - 1800000,
      testCases: [
        {
          id: 'test-3',
          name: 'Python Code Review',
          description: 'Review Python code for best practices',
          input: { code: 'def hello(): print("world")' },
          expectedOutput: {
            suggestions: ['Add type hints', 'Use more descriptive names'],
          },
          tags: ['python', 'review'],
        },
      ],
      metrics: [
        {
          id: 'quality',
          name: 'Review Quality',
          description: 'Quality of code review suggestions',
          type: 'quality',
          threshold: 0.7,
          weight: 1.0,
        },
      ],
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentEval with Mock Data
      </Text>

      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentEval
          appName="demo-agent"
          userId="demo-user"
          initialEvaluations={mockEvaluations}
          selectedEvaluationId="eval-1"
          enableMetricsComparison={true}
          showMetricsPanel={true}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Compact AgentEval Example
 *
 * Shows the component in compact mode
 */
export const CompactDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Compact AgentEval Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentEval
          appName="compact-agent"
          userId="user123"
          compactMode={true}
          showMetricsPanel={false}
          enableTemplates={false}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentEval Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentEval Example
      </Text>

      <View
        height="600px"
        border="1px solid"
        borderColor="color.purple.200"
        borderRadius="12px"
      >
        <AgentEval
          appName="custom-agent"
          userId="user123"
          enableBatchEvaluation={true}
          enableResultExport={true}
          maxConcurrentEvals={5}
          views={{
            container: {
              backgroundColor: 'color.purple.25',
              height: '100%',
            },
            header: {
              backgroundColor: 'color.purple.500',
              color: 'white',
            },
            evaluationList: {
              backgroundColor: 'color.white',
            },
            activeEvaluationItem: {
              backgroundColor: 'color.purple.100',
              borderColor: 'color.purple.500',
            },
            createPanel: {
              backgroundColor: 'color.purple.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Real-time AgentEval Example
 *
 * Demonstrates real-time updates and monitoring
 */
export const RealTimeDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Real-time AgentEval Example
      </Text>

      <Text fontSize={14} color="color.gray.600">
        This example shows real-time evaluation monitoring with auto-refresh
        enabled.
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentEval
          appName="realtime-agent"
          userId="user123"
          enableAutoRefresh={true}
          enableRealTimeUpdates={true}
          refreshInterval={10000}
          showProgressIndicators={true}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval.tsx">
import React from 'react';
import { AgentEvalProps } from './AgentEval/AgentEval.props';
import AgentEvalView from './AgentEval/AgentEval.view';
import { useAgentEval } from './AgentEval/AgentEval.state';

/**
 * AgentEval Component
 * 
 * A comprehensive evaluation component for ADK agents.
 * Handles evaluation creation, execution, monitoring, and results analysis.
 * 
 * @example
 * ```tsx
 * <AgentEval
 *   appName="my-agent"
 *   userId="user123"
 *   onEvaluationComplete={(result) => console.log('Evaluation complete:', result)}
 * />
 * ```
 * 
 * @example
 * ```tsx
 * // With custom evaluation configuration
 * <AgentEval
 *   appName="my-agent"
 *   userId="user123"
 *   enableBatchEvaluation={true}
 *   enableMetricsComparison={true}
 *   enableResultExport={true}
 *   maxConcurrentEvals={5}
 *   autoRefresh={true}
 *   refreshInterval={10000}
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     evaluationList: { maxHeight: '400px' },
 *     resultsPanel: { minHeight: '300px' }
 *   }}
 * />
 * ```
 */
const AgentEval: React.FC<AgentEvalProps> = (props) => {
  const evalState = useAgentEval(props);

  return <AgentEvalView {...props} {...evalState} />;
};

export default AgentEval;
export { AgentEval };
export type { AgentEvalProps };
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.props.ts">
import React from 'react';
import { ViewProps } from 'app-studio';

/**
 * Core ADK Session Types
 */
export interface AgentSession {
  id: string;
  userId: string;
  appName: string;
  state: any;
  events: AgentEvent[];
  createdAt: number;
  updatedAt: number;
  metadata?: {
    title?: string;
    description?: string;
    tags?: string[];
    messageCount?: number;
    lastActivity?: number;
  };
}

export interface AgentEvent {
  id: string;
  sessionId: string;
  type: string;
  data: any;
  timestamp: number;
  title?: string;
  author?: 'user' | 'bot' | 'system';
  content?: {
    parts?: any[];
  };
}

export interface SessionSummary {
  id: string;
  title: string;
  lastMessage: string;
  messageCount: number;
  createdAt: number;
  updatedAt: number;
  isActive: boolean;
}

/**
 * Component View Customization
 */
export interface AgentSessionViews {
  container?: ViewProps;
  header?: ViewProps;
  sessionList?: ViewProps;
  sessionItem?: ViewProps;
  activeSessionItem?: ViewProps;
  sessionInfo?: ViewProps;
  sessionActions?: ViewProps;
  createButton?: ViewProps;
  deleteButton?: ViewProps;
  exportButton?: ViewProps;
  importButton?: ViewProps;
  refreshButton?: ViewProps;
  searchInput?: ViewProps;
  emptyState?: ViewProps;
  loadingState?: ViewProps;
  errorState?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentSessionEventHandlers {
  onSessionSelect?: (session: AgentSession) => void;
  onSessionCreate?: (session: AgentSession) => void;
  onSessionUpdate?: (session: AgentSession) => void;
  onSessionDelete?: (sessionId: string) => void;
  onSessionImport?: (session: AgentSession) => void;
  onSessionExport?: (session: AgentSession) => void;
  onError?: (error: Error) => void;
  onRefresh?: () => void;
}

/**
 * Session Filter and Sort Options
 */
export interface SessionFilters {
  searchQuery?: string;
  dateRange?: {
    start: Date;
    end: Date;
  };
  tags?: string[];
  messageCountRange?: {
    min: number;
    max: number;
  };
  isActive?: boolean;
}

export interface SessionSortOptions {
  field: 'createdAt' | 'updatedAt' | 'messageCount' | 'title';
  direction: 'asc' | 'desc';
}

/**
 * Main AgentSession Props Interface
 */
export interface AgentSessionProps extends ViewProps, AgentSessionEventHandlers {
  // Required props
  appName: string;
  userId: string;

  // Optional configuration
  apiBaseUrl?: string;
  
  // Feature toggles
  showSessionHistory?: boolean;
  enableSessionImport?: boolean;
  enableSessionExport?: boolean;
  enableSessionDelete?: boolean;
  enableSessionSearch?: boolean;
  enableAutoRefresh?: boolean;
  
  // Limits and constraints
  maxSessions?: number;
  refreshInterval?: number; // in milliseconds
  
  // UI customization
  showSessionInfo?: boolean;
  showSessionActions?: boolean;
  showCreateButton?: boolean;
  showRefreshButton?: boolean;
  compactMode?: boolean;
  
  // Styling
  views?: AgentSessionViews;
  
  // Initial state
  initialSessions?: AgentSession[];
  selectedSessionId?: string;
  
  // Filtering and sorting
  defaultFilters?: SessionFilters;
  defaultSort?: SessionSortOptions;
  
  // Advanced features
  enableSessionTags?: boolean;
  enableSessionMetadata?: boolean;
  enableBulkOperations?: boolean;
  
  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

/**
 * Session Action Types
 */
export type SessionAction = 
  | 'create'
  | 'select'
  | 'delete'
  | 'export'
  | 'import'
  | 'refresh'
  | 'search'
  | 'filter'
  | 'sort';

/**
 * Session Status Types
 */
export type SessionStatus = 
  | 'active'
  | 'inactive'
  | 'archived'
  | 'error';

/**
 * Session Import/Export Format
 */
export interface SessionExportData {
  session: AgentSession;
  exportedAt: number;
  exportedBy: string;
  version: string;
}

export interface SessionImportOptions {
  overwriteExisting?: boolean;
  preserveIds?: boolean;
  updateTimestamps?: boolean;
}
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentSessionProps,
  AgentSession,
  SessionFilters,
  SessionSortOptions,
  SessionExportData,
  SessionImportOptions,
} from './AgentSession.props';
import { generateId } from '../../../../utils/generateId';

/**
 * Custom hook for managing AgentSession state and operations
 */
export const useAgentSession = (props: AgentSessionProps) => {
  const {
    appName,
    userId,
    apiBaseUrl = '',
    maxSessions = 100,
    refreshInterval = 30000,
    enableAutoRefresh = false,
    initialSessions = [],
    selectedSessionId,
    defaultFilters = {},
    defaultSort = { field: 'updatedAt', direction: 'desc' },
    onSessionSelect,
    onSessionCreate,
    onSessionUpdate,
    onSessionDelete,
    onSessionImport,
    onSessionExport,
    onError,
    onRefresh,
  } = props;

  // Core state
  const [sessions, setSessions] = useState<AgentSession[]>(initialSessions);
  const [selectedSession, setSelectedSession] = useState<AgentSession | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState(
    defaultFilters.searchQuery || ''
  );
  const [filters, setFilters] = useState<SessionFilters>(defaultFilters);
  const [sortOptions, setSortOptions] =
    useState<SessionSortOptions>(defaultSort);

  // Refs
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  /**
   * Fetch sessions from API
   */
  const fetchSessions = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(
        `${apiBaseUrl}/sessions?userId=${userId}&appName=${appName}&limit=${maxSessions}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch sessions: ${response.statusText}`);
      }

      const data: AgentSession[] = await response.json();
      setSessions(data);
      onRefresh?.();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl, userId, appName, maxSessions, onRefresh, onError]);

  /**
   * Create a new session
   */
  const createSession = useCallback(
    async (metadata?: {
      title?: string;
      description?: string;
      tags?: string[];
    }) => {
      try {
        setIsCreating(true);
        setError(null);

        const response = await fetch(`${apiBaseUrl}/sessions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId,
            appName,
            metadata,
          }),
        });

        if (!response.ok) {
          throw new Error(`Failed to create session: ${response.statusText}`);
        }

        const newSession: AgentSession = await response.json();
        setSessions((prev) => [newSession, ...prev]);
        setSelectedSession(newSession);
        onSessionCreate?.(newSession);
        onSessionSelect?.(newSession);

        return newSession;
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
        throw error;
      } finally {
        setIsCreating(false);
      }
    },
    [apiBaseUrl, userId, appName, onSessionCreate, onSessionSelect, onError]
  );

  /**
   * Select a session
   */
  const selectSession = useCallback(
    async (sessionId: string) => {
      try {
        setIsLoading(true);
        setError(null);

        // First try to find in current sessions
        let session = sessions.find((s) => s.id === sessionId);

        // If not found, fetch from API
        if (!session) {
          const response = await fetch(`${apiBaseUrl}/sessions/${sessionId}`);
          if (!response.ok) {
            throw new Error(`Failed to fetch session: ${response.statusText}`);
          }
          session = await response.json();
        }

        if (session) {
          setSelectedSession(session);
          onSessionSelect?.(session);
        }
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [sessions, apiBaseUrl, onSessionSelect, onError]
  );

  /**
   * Delete a session
   */
  const deleteSession = useCallback(
    async (sessionId: string) => {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch(`${apiBaseUrl}/sessions/${sessionId}`, {
          method: 'DELETE',
        });

        if (!response.ok) {
          throw new Error(`Failed to delete session: ${response.statusText}`);
        }

        setSessions((prev) => prev.filter((s) => s.id !== sessionId));

        if (selectedSession?.id === sessionId) {
          setSelectedSession(null);
        }

        onSessionDelete?.(sessionId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [apiBaseUrl, selectedSession, onSessionDelete, onError]
  );

  /**
   * Export session to JSON
   */
  const exportSession = useCallback(
    (session: AgentSession) => {
      try {
        const exportData: SessionExportData = {
          session,
          exportedAt: Date.now(),
          exportedBy: userId,
          version: '1.0.0',
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `session-${session.id}-${
          new Date().toISOString().split('T')[0]
        }.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
        onSessionExport?.(session);
      } catch (err) {
        const error =
          err instanceof Error ? err : new Error('Failed to export session');
        setError(error.message);
        onError?.(error);
      }
    },
    [userId, onSessionExport, onError]
  );

  /**
   * Import session from JSON file
   */
  const importSession = useCallback(
    async (file: File, options: SessionImportOptions = {}) => {
      try {
        setIsLoading(true);
        setError(null);

        const text = await file.text();
        const importData: SessionExportData = JSON.parse(text);

        if (!importData.session) {
          throw new Error('Invalid session file format');
        }

        let session = importData.session;

        // Generate new ID if not preserving
        if (!options.preserveIds) {
          session = { ...session, id: generateId() };
        }

        // Update timestamps if requested
        if (options.updateTimestamps) {
          const now = Date.now();
          session = { ...session, createdAt: now, updatedAt: now };
        }

        // Check if session already exists
        const existingSession = sessions.find((s) => s.id === session.id);
        if (existingSession && !options.overwriteExisting) {
          throw new Error(
            'Session already exists. Enable overwrite to replace it.'
          );
        }

        // Import via API
        const response = await fetch(`${apiBaseUrl}/sessions/import`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session, options }),
        });

        if (!response.ok) {
          throw new Error(`Failed to import session: ${response.statusText}`);
        }

        const importedSession: AgentSession = await response.json();

        if (existingSession) {
          setSessions((prev) =>
            prev.map((s) => (s.id === importedSession.id ? importedSession : s))
          );
        } else {
          setSessions((prev) => [importedSession, ...prev]);
        }

        onSessionImport?.(importedSession);
      } catch (err) {
        const error =
          err instanceof Error ? err : new Error('Failed to import session');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [sessions, apiBaseUrl, onSessionImport, onError]
  );

  /**
   * Filter and sort sessions
   */
  const getFilteredAndSortedSessions = useCallback(() => {
    let filtered = [...sessions];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (session) =>
          session.metadata?.title?.toLowerCase().includes(query) ||
          session.metadata?.description?.toLowerCase().includes(query) ||
          session.metadata?.tags?.some((tag) =>
            tag.toLowerCase().includes(query)
          ) ||
          session.id.toLowerCase().includes(query)
      );
    }

    // Apply other filters
    if (filters.dateRange) {
      filtered = filtered.filter(
        (session) =>
          session.createdAt >= filters.dateRange!.start.getTime() &&
          session.createdAt <= filters.dateRange!.end.getTime()
      );
    }

    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter((session) =>
        session.metadata?.tags?.some((tag) => filters.tags!.includes(tag))
      );
    }

    if (filters.messageCountRange) {
      filtered = filtered.filter((session) => {
        const count = session.metadata?.messageCount || 0;
        return (
          count >= filters.messageCountRange!.min &&
          count <= filters.messageCountRange!.max
        );
      });
    }

    // Apply sorting
    filtered.sort((a, b) => {
      let aValue: any, bValue: any;

      switch (sortOptions.field) {
        case 'title':
          aValue = a.metadata?.title || '';
          bValue = b.metadata?.title || '';
          break;
        case 'messageCount':
          aValue = a.metadata?.messageCount || 0;
          bValue = b.metadata?.messageCount || 0;
          break;
        case 'createdAt':
          aValue = a.createdAt;
          bValue = b.createdAt;
          break;
        case 'updatedAt':
        default:
          aValue = a.updatedAt;
          bValue = b.updatedAt;
          break;
      }

      if (sortOptions.direction === 'asc') {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return filtered;
  }, [sessions, searchQuery, filters, sortOptions]);

  /**
   * Handle file import
   */
  const handleFileImport = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleFileSelect = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file) {
        importSession(file);
      }
      // Reset input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    },
    [importSession]
  );

  /**
   * Initialize sessions on mount
   */
  useEffect(() => {
    fetchSessions();
  }, [fetchSessions]);

  /**
   * Set up auto-refresh
   */
  useEffect(() => {
    if (enableAutoRefresh && refreshInterval > 0) {
      refreshIntervalRef.current = setInterval(fetchSessions, refreshInterval);
      return () => {
        if (refreshIntervalRef.current) {
          clearInterval(refreshIntervalRef.current);
        }
      };
    }
    return undefined;
  }, [enableAutoRefresh, refreshInterval, fetchSessions]);

  /**
   * Select initial session
   */
  useEffect(() => {
    if (selectedSessionId && sessions.length > 0 && !selectedSession) {
      selectSession(selectedSessionId);
    }
  }, [selectedSessionId, sessions, selectedSession, selectSession]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
    };
  }, []);

  return {
    // State
    sessions: getFilteredAndSortedSessions(),
    selectedSession,
    isLoading,
    isCreating,
    error,
    searchQuery,
    filters,
    sortOptions,

    // Actions
    fetchSessions,
    createSession,
    selectSession,
    deleteSession,
    exportSession,
    importSession,
    handleFileImport,
    setSearchQuery,
    setFilters,
    setSortOptions,
    setError,

    // Refs
    fileInputRef,

    // Event handlers
    handleFileSelect,
  };
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentSession component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentSessionStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  sessionList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    minHeight: '200px',
  } as ViewProps,

  sessionItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  activeSessionItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '2px solid',
    borderColor: 'color.blue.500',
    backgroundColor: 'color.blue.50',
    cursor: 'pointer',
  } as ViewProps,

  compactSessionItem: {
    padding: '8px 12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  sessionInfo: {
    flex: 1,
  } as ViewProps,

  sessionTitle: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  sessionDescription: {
    fontSize: '12px',
    color: 'color.gray.600',
    marginBottom: '8px',
  } as ViewProps,

  sessionMeta: {
    fontSize: '11px',
    color: 'color.gray.500',
  } as ViewProps,

  sessionActions: {
    padding: '12px 16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.100',
    flexShrink: 0,
  } as ViewProps,

  actionButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    backgroundColor: 'color.white',
    color: 'color.gray.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.700',
    },
  } as ViewProps,

  deleteButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.red.300',
    backgroundColor: 'color.white',
    color: 'color.red.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.red.400',
      backgroundColor: 'color.red.50',
      color: 'color.red.800',
    },
  } as ViewProps,

  exportButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.green.300',
    backgroundColor: 'color.white',
    color: 'color.green.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  importButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.purple.300',
    backgroundColor: 'color.white',
    color: 'color.purple.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.purple.400',
      backgroundColor: 'color.purple.50',
      color: 'color.purple.800',
    },
  } as ViewProps,

  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '200px',
    padding: '32px',
  } as ViewProps,

  loadingState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '200px',
    padding: '32px',
    gap: '16px',
  } as ViewProps,

  errorState: {
    padding: '16px',
    backgroundColor: 'color.red.50',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    margin: '16px',
  } as ViewProps,

  searchInput: {
    width: '100%',
  } as ViewProps,

  filterContainer: {
    padding: '12px',
    backgroundColor: 'color.gray.50',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  filterGroup: {
    marginBottom: '12px',
  } as ViewProps,

  filterLabel: {
    fontSize: '12px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '4px',
  } as ViewProps,

  tagContainer: {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '4px',
    marginTop: '4px',
  } as ViewProps,

  tag: {
    padding: '2px 6px',
    fontSize: '10px',
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
    borderRadius: '4px',
    border: '1px solid',
    borderColor: 'color.blue.200',
  } as ViewProps,

  statusIndicator: {
    width: '8px',
    height: '8px',
    borderRadius: '50%',
    flexShrink: 0,
  } as ViewProps,

  activeStatus: {
    backgroundColor: 'color.green.500',
  } as ViewProps,

  inactiveStatus: {
    backgroundColor: 'color.gray.400',
  } as ViewProps,

  errorStatus: {
    backgroundColor: 'color.red.500',
  } as ViewProps,
};

/**
 * Size variants for AgentSession
 */
export const AgentSessionSizes = {
  sm: {
    container: { height: '300px' },
    sessionList: { minHeight: '150px' },
  },
  md: {
    container: { height: '400px' },
    sessionList: { minHeight: '200px' },
  },
  lg: {
    container: { height: '500px' },
    sessionList: { minHeight: '300px' },
  },
  xl: {
    container: { height: '600px' },
    sessionList: { minHeight: '400px' },
  },
};

/**
 * Theme variants for AgentSession
 */
export const AgentSessionThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    sessionList: { backgroundColor: 'color.white' },
    sessionActions: { backgroundColor: 'color.gray.100' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    sessionList: { backgroundColor: 'color.gray.900' },
    sessionActions: { backgroundColor: 'color.gray.800' },
  },
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.view.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { AgentSessionProps } from './AgentSession.props';
import { useAgentSession } from './AgentSession.state';
import { DefaultAgentSessionStyles } from './AgentSession.style';
import { SessionListItem } from './SessionListItem';
import { SessionActions } from './SessionActions';
import { SessionFilters } from './SessionFilters';
import { Alert } from 'src/components/Alert/Alert';
import { Loader } from 'src/components/Loader/Loader';
import { TextField } from 'src/components/Form/Form';

export interface AgentSessionViewProps
  extends AgentSessionProps,
    ReturnType<typeof useAgentSession> {}

/**
 * AgentSession View Component
 *
 * Renders the complete session management interface with session list, actions, and filters
 */
const AgentSessionView: React.FC<AgentSessionViewProps> = ({
  // Props
  showSessionHistory = true,
  enableSessionImport = true,
  enableSessionExport = true,
  enableSessionDelete = true,
  enableSessionSearch = true,
  showSessionInfo = true,
  showSessionActions = true,
  showCreateButton = true,
  showRefreshButton = true,
  compactMode = false,
  views,
  ariaLabel = 'Agent Session Manager',
  ariaDescribedBy,

  // State from hook
  sessions,
  selectedSession,
  isLoading,
  isCreating,
  error,
  searchQuery,
  filters,
  sortOptions,
  fetchSessions,
  createSession,
  selectSession,
  deleteSession,
  exportSession,
  handleFileImport,
  setSearchQuery,
  setFilters,
  setSortOptions,
  setError,
  fileInputRef,
  handleFileSelect,

  ...props
}) => {
  /**
   * Handle session creation
   */
  const handleCreateSession = async () => {
    try {
      await createSession({
        title: `Session ${new Date().toLocaleString()}`,
        description: 'New agent session',
      });
    } catch (error) {
      // Error is handled in the hook
    }
  };

  /**
   * Handle session selection
   */
  const handleSessionSelect = (sessionId: string) => {
    selectSession(sessionId);
  };

  /**
   * Handle session deletion
   */
  const handleSessionDelete = async (sessionId: string) => {
    if (window.confirm('Are you sure you want to delete this session?')) {
      await deleteSession(sessionId);
    }
  };

  /**
   * Handle session export
   */
  const handleSessionExport = (sessionId: string) => {
    const session = sessions.find((s) => s.id === sessionId);
    if (session) {
      exportSession(session);
    }
  };

  /**
   * Format session date
   */
  const formatDate = (timestamp: number) => {
    return new Date(timestamp).toLocaleDateString([], {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <View
      {...DefaultAgentSessionStyles.container}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentSessionStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Sessions
            </Text>
            <Text fontSize="sm" color="color.gray.600">
              {sessions.length} session{sessions.length !== 1 ? 's' : ''}
            </Text>
          </Vertical>

          <Horizontal gap={8}>
            {showRefreshButton && (
              <Button
                variant="outline"
                size="sm"
                onClick={fetchSessions}
                disabled={isLoading}
                aria-label="Refresh sessions"
              >
                🔄
              </Button>
            )}

            {showCreateButton && (
              <Button
                variant="filled"
                size="sm"
                onClick={handleCreateSession}
                disabled={isCreating}
                aria-label="Create new session"
              >
                {isCreating ? <Loader size="xs" /> : '+ New Session'}
              </Button>
            )}
          </Horizontal>
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Alert variant="error" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {/* Search and Filters */}
      {enableSessionSearch && (
        <View
          padding={16}
          borderBottom="1px solid"
          borderBottomColor="color.gray.200"
        >
          <Vertical gap={12}>
            <TextField
              placeholder="Search sessions..."
              value={searchQuery}
              onChange={setSearchQuery}
              views={{
                container: views?.searchInput,
              }}
            />

            <SessionFilters
              filters={filters}
              sortOptions={sortOptions}
              onFiltersChange={setFilters}
              onSortChange={setSortOptions}
            />
          </Vertical>
        </View>
      )}

      {/* Session Actions */}
      {showSessionActions && (
        <SessionActions
          enableImport={enableSessionImport}
          enableExport={enableSessionExport}
          selectedSession={selectedSession}
          onImport={handleFileImport}
          onExport={handleSessionExport}
          views={{
            container: views?.sessionActions,
            importButton: views?.importButton,
            exportButton: views?.exportButton,
          }}
        />
      )}

      {/* Session List */}
      <View {...DefaultAgentSessionStyles.sessionList} {...views?.sessionList}>
        {isLoading && sessions.length === 0 ? (
          <View
            {...DefaultAgentSessionStyles.loadingState}
            {...views?.loadingState}
          >
            <Loader size="md" />
            <Text color="color.gray.600">Loading sessions...</Text>
          </View>
        ) : sessions.length === 0 ? (
          <View
            {...DefaultAgentSessionStyles.emptyState}
            {...views?.emptyState}
          >
            <Text fontSize="lg" color="color.gray.500" textAlign="center">
              No sessions found
            </Text>
            <Text fontSize="sm" color="color.gray.400" textAlign="center">
              Create a new session to get started
            </Text>
          </View>
        ) : (
          <Vertical gap={8} padding={16}>
            {sessions.map((session) => (
              <SessionListItem
                key={session.id}
                session={session}
                isSelected={selectedSession?.id === session.id}
                compactMode={compactMode}
                showInfo={showSessionInfo}
                enableDelete={enableSessionDelete}
                enableExport={enableSessionExport}
                onSelect={() => handleSessionSelect(session.id)}
                onDelete={() => handleSessionDelete(session.id)}
                onExport={() => handleSessionExport(session.id)}
                formatDate={formatDate}
                views={{
                  container:
                    selectedSession?.id === session.id
                      ? views?.activeSessionItem
                      : views?.sessionItem,
                  info: views?.sessionInfo,
                  deleteButton: views?.deleteButton,
                  exportButton: views?.exportButton,
                }}
              />
            ))}
          </Vertical>
        )}
      </View>

      {/* Hidden file input for import */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        style={{ display: 'none' }}
        onChange={handleFileSelect}
      />
    </View>
  );
};

export default AgentSessionView;
</file>

<file path="src/components/adk/AgentSession/AgentSession/SessionActions.tsx">
import React from 'react';
import { View, Horizontal, Button } from 'app-studio';
import { AgentSession } from './AgentSession.props';
import { DefaultAgentSessionStyles } from './AgentSession.style';

export interface SessionActionsProps {
  enableImport?: boolean;
  enableExport?: boolean;
  selectedSession?: AgentSession | null;
  onImport: () => void;
  onExport: (sessionId: string) => void;
  views?: {
    container?: any;
    importButton?: any;
    exportButton?: any;
  };
}

/**
 * SessionActions Component
 * 
 * Renders action buttons for session management (import, export, etc.)
 */
export const SessionActions: React.FC<SessionActionsProps> = ({
  enableImport = true,
  enableExport = true,
  selectedSession,
  onImport,
  onExport,
  views = {},
}) => {
  const handleExport = () => {
    if (selectedSession) {
      onExport(selectedSession.id);
    }
  };

  return (
    <View {...DefaultAgentSessionStyles.sessionActions} {...views.container}>
      <Horizontal gap={8} alignItems="center">
        {enableImport && (
          <Button
            {...DefaultAgentSessionStyles.importButton}
            {...views.importButton}
            onClick={onImport}
            aria-label="Import session from file"
            title="Import session from JSON file"
          >
            📥 Import
          </Button>
        )}
        
        {enableExport && (
          <Button
            {...DefaultAgentSessionStyles.exportButton}
            {...views.exportButton}
            onClick={handleExport}
            disabled={!selectedSession}
            aria-label="Export selected session"
            title="Export selected session to JSON file"
          >
            📤 Export
          </Button>
        )}
      </Horizontal>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/SessionFilters.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import {
  SessionFilters as SessionFiltersType,
  SessionSortOptions,
} from './AgentSession.props';
import { DefaultAgentSessionStyles } from './AgentSession.style';
import { Select, TextField } from 'src/components/Form/Form';

export interface SessionFiltersProps {
  filters: SessionFiltersType;
  sortOptions: SessionSortOptions;
  onFiltersChange: (filters: SessionFiltersType) => void;
  onSortChange: (sortOptions: SessionSortOptions) => void;
}

/**
 * SessionFilters Component
 *
 * Renders filter and sort controls for the session list
 */
export const SessionFilters: React.FC<SessionFiltersProps> = ({
  filters,
  sortOptions,
  onFiltersChange,
  onSortChange,
}) => {
  const handleSortFieldChange = (field: string) => {
    onSortChange({
      ...sortOptions,
      field: field as SessionSortOptions['field'],
    });
  };

  const handleSortDirectionChange = (direction: string) => {
    onSortChange({
      ...sortOptions,
      direction: direction as SessionSortOptions['direction'],
    });
  };

  const handleTagsChange = (tagsString: string) => {
    const tags = tagsString
      .split(',')
      .map((tag) => tag.trim())
      .filter((tag) => tag.length > 0);
    onFiltersChange({
      ...filters,
      tags: tags.length > 0 ? tags : undefined,
    });
  };

  const handleMessageCountMinChange = (value: string) => {
    const min = parseInt(value) || 0;
    onFiltersChange({
      ...filters,
      messageCountRange: {
        min,
        max: filters.messageCountRange?.max || 1000,
      },
    });
  };

  const handleMessageCountMaxChange = (value: string) => {
    const max = parseInt(value) || 1000;
    onFiltersChange({
      ...filters,
      messageCountRange: {
        min: filters.messageCountRange?.min || 0,
        max,
      },
    });
  };

  return (
    <View {...DefaultAgentSessionStyles.filterContainer}>
      <Vertical gap={12}>
        {/* Sort Options */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>Sort By</Text>
          <Horizontal gap={8}>
            <Select
              value={sortOptions.field}
              onChange={handleSortFieldChange}
              options={[
                { value: 'updatedAt', label: 'Last Updated' },
                { value: 'createdAt', label: 'Created Date' },
                { value: 'title', label: 'Title' },
                { value: 'messageCount', label: 'Message Count' },
              ]}
              placeholder="Sort field"
            />
            <Select
              value={sortOptions.direction}
              onChange={handleSortDirectionChange}
              options={[
                { value: 'desc', label: 'Descending' },
                { value: 'asc', label: 'Ascending' },
              ]}
              placeholder="Sort direction"
            />
          </Horizontal>
        </View>

        {/* Tag Filter */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>Filter by Tags</Text>
          <TextField
            placeholder="Enter tags separated by commas"
            value={filters.tags?.join(', ') || ''}
            onChange={handleTagsChange}
          />
        </View>

        {/* Message Count Range */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>
            Message Count Range
          </Text>
          <Horizontal gap={8} alignItems="center">
            <TextField
              placeholder="Min"
              type="number"
              value={filters.messageCountRange?.min?.toString() || ''}
              onChange={handleMessageCountMinChange}
              style={{ width: '80px' }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <TextField
              placeholder="Max"
              type="number"
              value={filters.messageCountRange?.max?.toString() || ''}
              onChange={handleMessageCountMaxChange}
              style={{ width: '80px' }}
            />
          </Horizontal>
        </View>

        {/* Date Range Filter */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>Date Range</Text>
          <Horizontal gap={8} alignItems="center">
            <input
              type="date"
              value={
                filters.dateRange?.start
                  ? filters.dateRange.start.toISOString().split('T')[0]
                  : ''
              }
              onChange={(e) => {
                const start = e.target.value
                  ? new Date(e.target.value)
                  : undefined;
                onFiltersChange({
                  ...filters,
                  dateRange: start
                    ? {
                        start,
                        end: filters.dateRange?.end || new Date(),
                      }
                    : undefined,
                });
              }}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <input
              type="date"
              value={
                filters.dateRange?.end
                  ? filters.dateRange.end.toISOString().split('T')[0]
                  : ''
              }
              onChange={(e) => {
                const end = e.target.value
                  ? new Date(e.target.value)
                  : undefined;
                onFiltersChange({
                  ...filters,
                  dateRange: end
                    ? {
                        start: filters.dateRange?.start || new Date(0),
                        end,
                      }
                    : undefined,
                });
              }}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </Horizontal>
        </View>

        {/* Clear Filters */}
        {(filters.tags || filters.dateRange || filters.messageCountRange) && (
          <Horizontal justifyContent="flex-end">
            <button
              onClick={() => onFiltersChange({})}
              style={{
                padding: '4px 8px',
                fontSize: '11px',
                color: '#6b7280',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                textDecoration: 'underline',
              }}
            >
              Clear all filters
            </button>
          </Horizontal>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/SessionListItem.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text, Button } from 'app-studio';
import { AgentSession } from './AgentSession.props';
import { DefaultAgentSessionStyles } from './AgentSession.style';

export interface SessionListItemProps {
  session: AgentSession;
  isSelected: boolean;
  compactMode?: boolean;
  showInfo?: boolean;
  enableDelete?: boolean;
  enableExport?: boolean;
  onSelect: () => void;
  onDelete: () => void;
  onExport: () => void;
  formatDate: (timestamp: number) => string;
  views?: {
    container?: any;
    info?: any;
    deleteButton?: any;
    exportButton?: any;
  };
}

/**
 * SessionListItem Component
 * 
 * Renders individual session items in the session list
 */
export const SessionListItem: React.FC<SessionListItemProps> = ({
  session,
  isSelected,
  compactMode = false,
  showInfo = true,
  enableDelete = true,
  enableExport = true,
  onSelect,
  onDelete,
  onExport,
  formatDate,
  views = {},
}) => {
  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    onDelete();
  };

  const handleExport = (e: React.MouseEvent) => {
    e.stopPropagation();
    onExport();
  };

  const containerStyles = compactMode 
    ? DefaultAgentSessionStyles.compactSessionItem 
    : isSelected 
      ? DefaultAgentSessionStyles.activeSessionItem 
      : DefaultAgentSessionStyles.sessionItem;

  return (
    <View
      {...containerStyles}
      {...views.container}
      onClick={onSelect}
    >
      <Horizontal gap={12} alignItems="flex-start">
        {/* Status Indicator */}
        <View
          {...DefaultAgentSessionStyles.statusIndicator}
          {...DefaultAgentSessionStyles.activeStatus}
          marginTop="4px"
        />

        {/* Session Info */}
        <View {...DefaultAgentSessionStyles.sessionInfo} {...views.info}>
          <Vertical gap={compactMode ? 2 : 4}>
            {/* Title */}
            <Text {...DefaultAgentSessionStyles.sessionTitle}>
              {session.metadata?.title || `Session ${session.id.slice(0, 8)}`}
            </Text>

            {/* Description (if not compact) */}
            {!compactMode && session.metadata?.description && (
              <Text {...DefaultAgentSessionStyles.sessionDescription}>
                {session.metadata.description}
              </Text>
            )}

            {/* Tags */}
            {session.metadata?.tags && session.metadata.tags.length > 0 && (
              <View {...DefaultAgentSessionStyles.tagContainer}>
                {session.metadata.tags.slice(0, compactMode ? 2 : 5).map((tag, index) => (
                  <View key={index} {...DefaultAgentSessionStyles.tag}>
                    <Text fontSize="10px">{tag}</Text>
                  </View>
                ))}
                {session.metadata.tags.length > (compactMode ? 2 : 5) && (
                  <View {...DefaultAgentSessionStyles.tag}>
                    <Text fontSize="10px">+{session.metadata.tags.length - (compactMode ? 2 : 5)}</Text>
                  </View>
                )}
              </View>
            )}

            {/* Metadata */}
            {showInfo && (
              <Horizontal gap={16} alignItems="center">
                <Text {...DefaultAgentSessionStyles.sessionMeta}>
                  {formatDate(session.updatedAt)}
                </Text>
                {session.metadata?.messageCount !== undefined && (
                  <Text {...DefaultAgentSessionStyles.sessionMeta}>
                    {session.metadata.messageCount} message{session.metadata.messageCount !== 1 ? 's' : ''}
                  </Text>
                )}
                <Text {...DefaultAgentSessionStyles.sessionMeta}>
                  ID: {session.id.slice(0, 8)}...
                </Text>
              </Horizontal>
            )}
          </Vertical>
        </View>

        {/* Actions */}
        <Horizontal gap={4} alignItems="center">
          {enableExport && (
            <Button
              {...DefaultAgentSessionStyles.exportButton}
              {...views.exportButton}
              onClick={handleExport}
              aria-label={`Export session ${session.id}`}
              title="Export session"
            >
              📤
            </Button>
          )}
          
          {enableDelete && (
            <Button
              {...DefaultAgentSessionStyles.deleteButton}
              {...views.deleteButton}
              onClick={handleDelete}
              aria-label={`Delete session ${session.id}`}
              title="Delete session"
            >
              🗑️
            </Button>
          )}
        </Horizontal>
      </Horizontal>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentSession/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text } from 'app-studio';
import { AgentSession } from '../AgentSession';
import { AgentSession as AgentSessionType } from '../AgentSession/AgentSession.props';

/**
 * Default AgentSession Example
 *
 * Demonstrates basic usage of the AgentSession component
 */
export const DefaultDemo = () => {
  const [selectedSession, setSelectedSession] =
    useState<AgentSessionType | null>(null);

  const handleSessionSelect = (session: AgentSessionType) => {
    console.log('Session selected:', session);
    setSelectedSession(session);
  };

  const handleSessionCreate = (session: AgentSessionType) => {
    console.log('Session created:', session);
    setSelectedSession(session);
  };

  const handleSessionDelete = (sessionId: string) => {
    console.log('Session deleted:', sessionId);
    if (selectedSession?.id === sessionId) {
      setSelectedSession(null);
    }
  };

  const handleError = (error: Error) => {
    console.error('AgentSession error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentSession Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A comprehensive session management interface for ADK agents. Handles
        session creation, listing, selection, deletion, and import/export.
      </Text>

      {/* Selected Session Info */}
      {selectedSession && (
        <View
          padding={16}
          backgroundColor="color.green.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.green.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.green.800">
            Selected Session
          </Text>
          <Text fontSize={12} color="color.green.600">
            ID: {selectedSession.id}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Title: {selectedSession.metadata?.title || 'Untitled'}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Messages: {selectedSession.metadata?.messageCount || 0}
          </Text>
        </View>
      )}

      {/* AgentSession Component */}
      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentSession
          appName="demo-agent"
          userId="demo-user"
          apiBaseUrl="http://localhost:3000/adk"
          showSessionHistory={true}
          enableSessionImport={true}
          enableSessionExport={true}
          enableSessionDelete={true}
          enableSessionSearch={true}
          showSessionInfo={true}
          showSessionActions={true}
          showCreateButton={true}
          showRefreshButton={true}
          maxSessions={50}
          enableAutoRefresh={false}
          onSessionSelect={handleSessionSelect}
          onSessionCreate={handleSessionCreate}
          onSessionDelete={handleSessionDelete}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
            sessionList: {
              backgroundColor: 'color.gray.100',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Compact AgentSession Example
 *
 * Shows the component in compact mode
 */
export const CompactDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Compact AgentSession Example
      </Text>

      <View
        height="300px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentSession
          appName="compact-agent"
          userId="user123"
          compactMode={true}
          showSessionInfo={false}
          enableSessionSearch={false}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentSession Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentSession Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.purple.200"
        borderRadius="12px"
      >
        <AgentSession
          appName="custom-agent"
          userId="user123"
          enableSessionTags={true}
          enableSessionMetadata={true}
          maxSessions={25}
          views={{
            container: {
              backgroundColor: 'color.purple.25',
              height: '100%',
            },
            header: {
              backgroundColor: 'color.purple.500',
              color: 'white',
            },
            sessionList: {
              backgroundColor: 'color.white',
            },
            activeSessionItem: {
              backgroundColor: 'color.purple.100',
              borderColor: 'color.purple.500',
            },
            sessionActions: {
              backgroundColor: 'color.purple.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Session with Mock Data Example
 *
 * Demonstrates the component with initial session data
 */
export const MockDataDemo = () => {
  const mockSessions: AgentSessionType[] = [
    {
      id: 'session-1',
      userId: 'user123',
      appName: 'demo-agent',
      state: {},
      events: [],
      createdAt: Date.now() - 86400000, // 1 day ago
      updatedAt: Date.now() - 3600000, // 1 hour ago
      metadata: {
        title: 'Customer Support Chat',
        description: 'Helping customer with product questions',
        tags: ['support', 'product', 'urgent'],
        messageCount: 15,
        lastActivity: Date.now() - 3600000,
      },
    },
    {
      id: 'session-2',
      userId: 'user123',
      appName: 'demo-agent',
      state: {},
      events: [],
      createdAt: Date.now() - 172800000, // 2 days ago
      updatedAt: Date.now() - 7200000, // 2 hours ago
      metadata: {
        title: 'Code Review Assistant',
        description: 'Reviewing pull request and suggesting improvements',
        tags: ['code-review', 'development'],
        messageCount: 8,
        lastActivity: Date.now() - 7200000,
      },
    },
    {
      id: 'session-3',
      userId: 'user123',
      appName: 'demo-agent',
      state: {},
      events: [],
      createdAt: Date.now() - 259200000, // 3 days ago
      updatedAt: Date.now() - 10800000, // 3 hours ago
      metadata: {
        title: 'Data Analysis Session',
        description: 'Analyzing sales data and generating insights',
        tags: ['analytics', 'data', 'sales'],
        messageCount: 23,
        lastActivity: Date.now() - 10800000,
      },
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentSession with Mock Data
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentSession
          appName="demo-agent"
          userId="user123"
          initialSessions={mockSessions}
          selectedSessionId="session-1"
          enableSessionSearch={true}
          enableSessionTags={true}
          defaultSort={{ field: 'updatedAt', direction: 'desc' }}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Session Management Features Example
 *
 * Demonstrates import/export and advanced features
 */
export const FeaturesDemo = () => {
  const [importedSessions, setImportedSessions] = useState<AgentSessionType[]>(
    []
  );

  const handleSessionImport = (session: AgentSessionType) => {
    console.log('Session imported:', session);
    setImportedSessions((prev) => [...prev, session]);
  };

  const handleSessionExport = (session: AgentSessionType) => {
    console.log('Session exported:', session);
  };

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentSession Management Features
      </Text>

      {importedSessions.length > 0 && (
        <View
          padding={12}
          backgroundColor="color.blue.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.blue.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.blue.800">
            Imported Sessions ({importedSessions.length})
          </Text>
          {importedSessions.map((session) => (
            <Text key={session.id} fontSize={12} color="color.blue.600">
              • {session.metadata?.title || session.id}
            </Text>
          ))}
        </View>
      )}

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentSession
          appName="features-agent"
          userId="user123"
          enableSessionImport={true}
          enableSessionExport={true}
          enableSessionDelete={true}
          enableBulkOperations={true}
          onSessionImport={handleSessionImport}
          onSessionExport={handleSessionExport}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession.tsx">
import React from 'react';
import { AgentSessionProps } from './AgentSession/AgentSession.props';
import AgentSessionView from './AgentSession/AgentSession.view';
import { useAgentSession } from './AgentSession/AgentSession.state';

/**
 * AgentSession Component
 * 
 * A comprehensive session management component for ADK agents.
 * Handles session creation, listing, selection, deletion, and state management.
 * 
 * @example
 * ```tsx
 * <AgentSession
 *   appName="my-agent"
 *   userId="user123"
 *   onSessionSelect={(session) => console.log('Selected:', session)}
 *   onSessionCreate={(session) => console.log('Created:', session)}
 * />
 * ```
 * 
 * @example
 * ```tsx
 * // With custom styling and features
 * <AgentSession
 *   appName="my-agent"
 *   userId="user123"
 *   showSessionHistory={true}
 *   enableSessionImport={true}
 *   enableSessionExport={true}
 *   maxSessions={50}
 *   autoRefresh={true}
 *   refreshInterval={30000}
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     sessionList: { maxHeight: '400px' },
 *     sessionItem: { borderRadius: '8px' }
 *   }}
 * />
 * ```
 */
const AgentSession: React.FC<AgentSessionProps> = (props) => {
  const sessionState = useAgentSession(props);

  return <AgentSessionView {...props} {...sessionState} />;
};

export default AgentSession;
export { AgentSession };
export type { AgentSessionProps };
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Trace Types
 */
export interface TraceEvent {
  id: string;
  sessionId: string;
  type:
    | 'llm_request'
    | 'llm_response'
    | 'function_call'
    | 'function_response'
    | 'user_input'
    | 'agent_output'
    | 'error'
    | 'system';
  timestamp: number;
  duration?: number;
  data: any;
  metadata?: {
    title?: string;
    description?: string;
    level?: 'info' | 'warning' | 'error' | 'debug';
    tags?: string[];
  };
  parentId?: string;
  children?: TraceEvent[];
  attributes?: Record<string, any>;
}

export interface TraceSpan {
  id: string;
  name: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  status: 'running' | 'completed' | 'error' | 'cancelled';
  events: TraceEvent[];
  attributes: Record<string, any>;
  parentId?: string;
  children?: TraceSpan[];
}

export interface TraceMetrics {
  totalEvents: number;
  totalDuration: number;
  averageResponseTime: number;
  errorCount: number;
  successCount: number;
  functionCallCount: number;
  llmRequestCount: number;
  eventsByType: Record<string, number>;
  performanceMetrics: {
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
}

export interface TraceFilter {
  eventTypes?: string[];
  timeRange?: {
    start: Date;
    end: Date;
  };
  searchQuery?: string;
  level?: ('info' | 'warning' | 'error' | 'debug')[];
  tags?: string[];
  minDuration?: number;
  maxDuration?: number;
}

/**
 * Component View Customization
 */
export interface AgentTraceViews {
  container?: ViewProps;
  header?: ViewProps;
  timeline?: ViewProps;
  eventList?: ViewProps;
  eventItem?: ViewProps;
  selectedEventItem?: ViewProps;
  metrics?: ViewProps;
  filters?: ViewProps;
  visualization?: ViewProps;
  exportButton?: ViewProps;
  refreshButton?: ViewProps;
  searchInput?: ViewProps;
  emptyState?: ViewProps;
  loadingState?: ViewProps;
  errorState?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentTraceEventHandlers {
  onEventSelect?: (event: TraceEvent) => void;
  onSpanSelect?: (span: TraceSpan) => void;
  onFilterChange?: (filter: TraceFilter) => void;
  onExport?: (format: 'json' | 'csv' | 'svg') => void;
  onRefresh?: () => void;
  onError?: (error: Error) => void;
}

/**
 * Visualization Options
 */
export type VisualizationType =
  | 'timeline'
  | 'tree'
  | 'graph'
  | 'table'
  | 'flamegraph';

export interface VisualizationConfig {
  type: VisualizationType;
  showDuration?: boolean;
  showMetadata?: boolean;
  groupBy?: 'type' | 'level' | 'parent' | 'none';
  sortBy?: 'timestamp' | 'duration' | 'type' | 'name';
  sortDirection?: 'asc' | 'desc';
  maxDepth?: number;
  collapsible?: boolean;
}

/**
 * Main AgentTrace Props Interface
 */
export interface AgentTraceProps extends ViewProps, AgentTraceEventHandlers {
  // Required props
  sessionId: string;
  userId: string;
  appName: string;

  // Optional configuration
  apiBaseUrl?: string;

  // Feature toggles
  showTimeline?: boolean;
  showMetrics?: boolean;
  showVisualization?: boolean;
  enableFiltering?: boolean;
  enableExport?: boolean;
  enableSearch?: boolean;
  enableAutoRefresh?: boolean;

  // Visualization options
  visualizationType?: VisualizationType;
  visualizationConfig?: VisualizationConfig;

  // Limits and constraints
  maxEvents?: number;
  refreshInterval?: number; // in milliseconds

  // UI customization
  showEventDetails?: boolean;
  showPerformanceMetrics?: boolean;
  compactMode?: boolean;

  // Styling
  views?: AgentTraceViews;

  // Initial state
  initialEvents?: TraceEvent[];
  initialFilter?: TraceFilter;
  selectedEventId?: string;

  // Advanced features
  enableRealTimeUpdates?: boolean;
  enableEventGrouping?: boolean;
  enableSpanVisualization?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

/**
 * Export Formats
 */
export interface TraceExportOptions {
  format: 'json' | 'csv' | 'svg' | 'png';
  includeMetadata?: boolean;
  includeMetrics?: boolean;
  timeRange?: {
    start: Date;
    end: Date;
  };
  eventTypes?: string[];
}

/**
 * Real-time Update Types
 */
export interface TraceUpdate {
  type: 'event_added' | 'event_updated' | 'span_completed' | 'metrics_updated';
  data: TraceEvent | TraceSpan | TraceMetrics;
  timestamp: number;
}
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentTraceProps,
  TraceEvent,
  TraceSpan,
  TraceMetrics,
  TraceFilter,
  TraceExportOptions,
  VisualizationType,
} from './AgentTrace.props';

/**
 * Custom hook for managing AgentTrace state and operations
 */
export const useAgentTrace = (props: AgentTraceProps) => {
  const {
    sessionId,
    userId,
    appName,
    apiBaseUrl = '',
    maxEvents = 1000,
    refreshInterval = 5000,
    enableAutoRefresh = false,
    visualizationType = 'timeline',
    initialEvents = [],
    initialFilter = {},
    selectedEventId,
    onEventSelect,
    onSpanSelect,
    onFilterChange,
    onExport,
    onRefresh,
    onError,
  } = props;

  // Core state
  const [events, setEvents] = useState<TraceEvent[]>(initialEvents);
  const [spans, setSpans] = useState<TraceSpan[]>([]);
  const [selectedEvent, setSelectedEvent] = useState<TraceEvent | null>(null);
  const [selectedSpan, setSelectedSpan] = useState<TraceSpan | null>(null);
  const [metrics, setMetrics] = useState<TraceMetrics | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [filter, setFilter] = useState<TraceFilter>(initialFilter);
  const [searchQuery, setSearchQuery] = useState(
    initialFilter.searchQuery || ''
  );
  const [currentVisualization, setCurrentVisualization] =
    useState<VisualizationType>(visualizationType);

  // Refs
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  /**
   * Fetch trace events from API
   */
  const fetchTraceEvents = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const params = new URLSearchParams({
        sessionId,
        userId,
        appName,
        limit: maxEvents.toString(),
      });

      // Add filter parameters
      if (filter.eventTypes?.length) {
        params.append('eventTypes', filter.eventTypes.join(','));
      }
      if (filter.timeRange) {
        params.append('startTime', filter.timeRange.start.toISOString());
        params.append('endTime', filter.timeRange.end.toISOString());
      }
      if (filter.searchQuery) {
        params.append('search', filter.searchQuery);
      }

      const response = await fetch(`${apiBaseUrl}/trace/events?${params}`);

      if (!response.ok) {
        throw new Error(`Failed to fetch trace events: ${response.statusText}`);
      }

      const data: TraceEvent[] = await response.json();
      setEvents(data);

      // Calculate metrics
      const calculatedMetrics = calculateMetrics(data);
      setMetrics(calculatedMetrics);

      onRefresh?.();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [
    sessionId,
    userId,
    appName,
    apiBaseUrl,
    maxEvents,
    filter,
    onRefresh,
    onError,
  ]);

  /**
   * Fetch trace spans from API
   */
  const fetchTraceSpans = useCallback(async () => {
    try {
      const response = await fetch(
        `${apiBaseUrl}/trace/spans?sessionId=${sessionId}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch trace spans: ${response.statusText}`);
      }

      const data: TraceSpan[] = await response.json();
      setSpans(data);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    }
  }, [sessionId, apiBaseUrl, onError]);

  /**
   * Calculate metrics from events
   */
  const calculateMetrics = useCallback((events: TraceEvent[]): TraceMetrics => {
    const totalEvents = events.length;
    const durations = events.filter((e) => e.duration).map((e) => e.duration!);
    const totalDuration = durations.reduce((sum, d) => sum + d, 0);
    const averageResponseTime =
      durations.length > 0 ? totalDuration / durations.length : 0;

    const errorCount = events.filter(
      (e) => e.metadata?.level === 'error'
    ).length;
    const successCount = totalEvents - errorCount;
    const functionCallCount = events.filter(
      (e) => e.type === 'function_call'
    ).length;
    const llmRequestCount = events.filter(
      (e) => e.type === 'llm_request'
    ).length;

    const eventsByType = events.reduce((acc, event) => {
      acc[event.type] = (acc[event.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Calculate percentiles
    const sortedDurations = durations.sort((a, b) => a - b);
    const getPercentile = (p: number) => {
      const index = Math.ceil((p / 100) * sortedDurations.length) - 1;
      return sortedDurations[index] || 0;
    };

    return {
      totalEvents,
      totalDuration,
      averageResponseTime,
      errorCount,
      successCount,
      functionCallCount,
      llmRequestCount,
      eventsByType,
      performanceMetrics: {
        p50: getPercentile(50),
        p90: getPercentile(90),
        p95: getPercentile(95),
        p99: getPercentile(99),
      },
    };
  }, []);

  /**
   * Select an event
   */
  const selectEvent = useCallback(
    (eventId: string) => {
      const event = events.find((e) => e.id === eventId);
      if (event) {
        setSelectedEvent(event);
        onEventSelect?.(event);
      }
    },
    [events, onEventSelect]
  );

  /**
   * Select a span
   */
  const selectSpan = useCallback(
    (spanId: string) => {
      const span = spans.find((s) => s.id === spanId);
      if (span) {
        setSelectedSpan(span);
        onSpanSelect?.(span);
      }
    },
    [spans, onSpanSelect]
  );

  /**
   * Update filter
   */
  const updateFilter = useCallback(
    (newFilter: TraceFilter) => {
      setFilter(newFilter);
      onFilterChange?.(newFilter);
    },
    [onFilterChange]
  );

  /**
   * Export trace data
   */
  const exportTrace = useCallback(
    async (options: TraceExportOptions) => {
      try {
        let filteredEvents = events;

        // Apply export filters
        if (options.timeRange) {
          filteredEvents = filteredEvents.filter(
            (event) =>
              event.timestamp >= options.timeRange!.start.getTime() &&
              event.timestamp <= options.timeRange!.end.getTime()
          );
        }

        if (options.eventTypes?.length) {
          filteredEvents = filteredEvents.filter((event) =>
            options.eventTypes!.includes(event.type)
          );
        }

        let exportData: any;
        let filename: string;
        let mimeType: string;

        switch (options.format) {
          case 'json':
            exportData = {
              events: filteredEvents,
              ...(options.includeMetrics && { metrics }),
              ...(options.includeMetadata && {
                sessionId,
                userId,
                appName,
                exportedAt: new Date().toISOString(),
              }),
            };
            filename = `trace-${sessionId}-${
              new Date().toISOString().split('T')[0]
            }.json`;
            mimeType = 'application/json';
            break;

          case 'csv':
            const csvHeaders = [
              'id',
              'type',
              'timestamp',
              'duration',
              'level',
              'title',
            ];
            const csvRows = filteredEvents.map((event) => [
              event.id,
              event.type,
              new Date(event.timestamp).toISOString(),
              event.duration || '',
              event.metadata?.level || '',
              event.metadata?.title || '',
            ]);
            exportData = [csvHeaders, ...csvRows]
              .map((row) => row.join(','))
              .join('\n');
            filename = `trace-${sessionId}-${
              new Date().toISOString().split('T')[0]
            }.csv`;
            mimeType = 'text/csv';
            break;

          default:
            throw new Error(`Export format ${options.format} not supported`);
        }

        // Create and download file
        const blob = new Blob(
          [
            typeof exportData === 'string'
              ? exportData
              : JSON.stringify(exportData, null, 2),
          ],
          {
            type: mimeType,
          }
        );
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
        onExport?.(options.format);
      } catch (err) {
        const error =
          err instanceof Error ? err : new Error('Failed to export trace');
        setError(error.message);
        onError?.(error);
      }
    },
    [events, metrics, sessionId, userId, appName, onExport, onError]
  );

  /**
   * Filter and search events
   */
  const getFilteredEvents = useCallback(() => {
    let filtered = [...events];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (event) =>
          event.id.toLowerCase().includes(query) ||
          event.type.toLowerCase().includes(query) ||
          event.metadata?.title?.toLowerCase().includes(query) ||
          event.metadata?.description?.toLowerCase().includes(query) ||
          JSON.stringify(event.data).toLowerCase().includes(query)
      );
    }

    // Apply type filter
    if (filter.eventTypes?.length) {
      filtered = filtered.filter((event) =>
        filter.eventTypes!.includes(event.type)
      );
    }

    // Apply level filter
    if (filter.level?.length) {
      filtered = filtered.filter(
        (event) =>
          event.metadata?.level && filter.level!.includes(event.metadata.level)
      );
    }

    // Apply time range filter
    if (filter.timeRange) {
      filtered = filtered.filter(
        (event) =>
          event.timestamp >= filter.timeRange!.start.getTime() &&
          event.timestamp <= filter.timeRange!.end.getTime()
      );
    }

    // Apply duration filter
    if (filter.minDuration !== undefined) {
      filtered = filtered.filter(
        (event) => (event.duration || 0) >= filter.minDuration!
      );
    }
    if (filter.maxDuration !== undefined) {
      filtered = filtered.filter(
        (event) => (event.duration || 0) <= filter.maxDuration!
      );
    }

    // Apply tags filter
    if (filter.tags?.length) {
      filtered = filtered.filter((event) =>
        event.metadata?.tags?.some((tag) => filter.tags!.includes(tag))
      );
    }

    return filtered;
  }, [events, searchQuery, filter]);

  /**
   * Set up real-time updates via WebSocket
   */
  const setupRealTimeUpdates = useCallback(() => {
    if (!props.enableRealTimeUpdates) return;

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${apiBaseUrl.replace(
      /^https?:\/\//,
      ''
    )}/trace/ws?sessionId=${sessionId}`;

    wsRef.current = new WebSocket(wsUrl);

    wsRef.current.onmessage = (event) => {
      try {
        const update = JSON.parse(event.data);

        switch (update.type) {
          case 'event_added':
            setEvents((prev) => [...prev, update.data]);
            break;
          case 'event_updated':
            setEvents((prev) =>
              prev.map((e) => (e.id === update.data.id ? update.data : e))
            );
            break;
          case 'metrics_updated':
            setMetrics(update.data);
            break;
        }
      } catch (err) {
        console.error('Error parsing WebSocket message:', err);
      }
    };

    wsRef.current.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }, [props.enableRealTimeUpdates, apiBaseUrl, sessionId]);

  /**
   * Initialize trace data on mount
   */
  useEffect(() => {
    fetchTraceEvents();
    fetchTraceSpans();
    setupRealTimeUpdates();
  }, [fetchTraceEvents, fetchTraceSpans, setupRealTimeUpdates]);

  /**
   * Set up auto-refresh
   */
  useEffect(() => {
    if (enableAutoRefresh && refreshInterval > 0) {
      refreshIntervalRef.current = setInterval(() => {
        fetchTraceEvents();
        fetchTraceSpans();
      }, refreshInterval);

      return () => {
        if (refreshIntervalRef.current) {
          clearInterval(refreshIntervalRef.current);
        }
      };
    }
    return undefined;
  }, [enableAutoRefresh, refreshInterval, fetchTraceEvents, fetchTraceSpans]);

  /**
   * Select initial event
   */
  useEffect(() => {
    if (selectedEventId && events.length > 0 && !selectedEvent) {
      selectEvent(selectedEventId);
    }
  }, [selectedEventId, events, selectedEvent, selectEvent]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  return {
    // State
    events: getFilteredEvents(),
    spans,
    selectedEvent,
    selectedSpan,
    metrics,
    isLoading,
    error,
    filter,
    searchQuery,
    currentVisualization,

    // Actions
    fetchTraceEvents,
    fetchTraceSpans,
    selectEvent,
    selectSpan,
    updateFilter,
    exportTrace,
    setSearchQuery,
    setCurrentVisualization,
    setError,

    // Computed
    filteredEvents: getFilteredEvents(),
  };
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentTrace component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentTraceStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  timeline: {
    height: '200px',
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.white',
    overflowX: 'auto',
    overflowY: 'hidden',
  } as ViewProps,

  eventList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    padding: '16px',
  } as ViewProps,

  eventItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginBottom: '8px',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  selectedEventItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '2px solid',
    borderColor: 'color.blue.500',
    backgroundColor: 'color.blue.50',
    cursor: 'pointer',
    marginBottom: '8px',
  } as ViewProps,

  eventHeader: {
    marginBottom: '8px',
  } as ViewProps,

  eventType: {
    padding: '2px 8px',
    fontSize: '11px',
    fontWeight: '600',
    borderRadius: '12px',
    textTransform: 'uppercase',
  } as ViewProps,

  eventTypeRequest: {
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
  } as ViewProps,

  eventTypeResponse: {
    backgroundColor: 'color.green.100',
    color: 'color.green.800',
  } as ViewProps,

  eventTypeError: {
    backgroundColor: 'color.red.100',
    color: 'color.red.800',
  } as ViewProps,

  eventTypeFunction: {
    backgroundColor: 'color.purple.100',
    color: 'color.purple.800',
  } as ViewProps,

  eventTypeSystem: {
    backgroundColor: 'color.gray.100',
    color: 'color.gray.800',
  } as ViewProps,

  eventContent: {
    fontSize: '14px',
    lineHeight: 1.5,
    color: 'color.gray.700',
  } as ViewProps,

  eventMetadata: {
    marginTop: '8px',
    padding: '8px',
    backgroundColor: 'color.gray.50',
    borderRadius: '6px',
    fontSize: '12px',
    color: 'color.gray.600',
  } as ViewProps,

  eventDuration: {
    fontSize: '11px',
    color: 'color.gray.500',
    fontFamily: 'Monaco, Consolas, monospace',
  } as ViewProps,

  eventTimestamp: {
    fontSize: '11px',
    color: 'color.gray.500',
    fontFamily: 'Monaco, Consolas, monospace',
  } as ViewProps,

  metrics: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.100',
    flexShrink: 0,
  } as ViewProps,

  metricsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
    gap: '16px',
  } as ViewProps,

  metricCard: {
    padding: '12px',
    backgroundColor: 'color.white',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    textAlign: 'center',
  } as ViewProps,

  metricValue: {
    fontSize: '20px',
    fontWeight: '700',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  metricLabel: {
    fontSize: '12px',
    color: 'color.gray.600',
    textTransform: 'uppercase',
    fontWeight: '600',
  } as ViewProps,

  visualization: {
    flex: 1,
    padding: '16px',
    backgroundColor: 'color.white',
    overflow: 'auto',
  } as ViewProps,

  timelineContainer: {
    position: 'relative',
    height: '100%',
    minWidth: '800px',
  } as ViewProps,

  timelineAxis: {
    position: 'absolute',
    bottom: '0',
    left: '0',
    right: '0',
    height: '30px',
    borderTop: '1px solid',
    borderTopColor: 'color.gray.300',
  } as ViewProps,

  timelineEvent: {
    position: 'absolute',
    height: '20px',
    borderRadius: '4px',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '10px',
    fontWeight: '600',
    color: 'white',
    transition: 'all 0.2s ease',
    ':hover': {
      transform: 'scale(1.05)',
      zIndex: 10,
    },
  } as ViewProps,

  timelineSpan: {
    position: 'absolute',
    height: '30px',
    borderRadius: '6px',
    border: '2px solid',
    backgroundColor: 'transparent',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    paddingLeft: '8px',
    fontSize: '11px',
    fontWeight: '600',
    transition: 'all 0.2s ease',
    ':hover': {
      backgroundColor: 'rgba(59, 130, 246, 0.1)',
    },
  } as ViewProps,

  filters: {
    padding: '12px',
    backgroundColor: 'color.gray.50',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  filterGroup: {
    marginBottom: '12px',
  } as ViewProps,

  filterLabel: {
    fontSize: '12px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '4px',
  } as ViewProps,

  tagContainer: {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '4px',
    marginTop: '4px',
  } as ViewProps,

  tag: {
    padding: '2px 6px',
    fontSize: '10px',
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
    borderRadius: '4px',
    border: '1px solid',
    borderColor: 'color.blue.200',
  } as ViewProps,

  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
  } as ViewProps,

  loadingState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
    gap: '16px',
  } as ViewProps,

  errorState: {
    padding: '16px',
    backgroundColor: 'color.red.50',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    margin: '16px',
  } as ViewProps,

  searchInput: {
    width: '100%',
  } as ViewProps,

  exportButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.green.300',
    backgroundColor: 'color.white',
    color: 'color.green.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  refreshButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.blue.300',
    backgroundColor: 'color.white',
    color: 'color.blue.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.800',
    },
  } as ViewProps,
};

/**
 * Event type color mapping
 */
export const EventTypeColors = {
  llm_request: 'color.blue.500',
  llm_response: 'color.green.500',
  function_call: 'color.purple.500',
  function_response: 'color.purple.300',
  user_input: 'color.orange.500',
  agent_output: 'color.teal.500',
  error: 'color.red.500',
  system: 'color.gray.500',
};

/**
 * Size variants for AgentTrace
 */
export const AgentTraceSizes = {
  sm: {
    container: { height: '400px' },
    timeline: { height: '120px' },
    eventList: { minHeight: '200px' },
  },
  md: {
    container: { height: '600px' },
    timeline: { height: '200px' },
    eventList: { minHeight: '300px' },
  },
  lg: {
    container: { height: '800px' },
    timeline: { height: '250px' },
    eventList: { minHeight: '400px' },
  },
  xl: {
    container: { height: '1000px' },
    timeline: { height: '300px' },
    eventList: { minHeight: '500px' },
  },
};

/**
 * Theme variants for AgentTrace
 */
export const AgentTraceThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    timeline: { backgroundColor: 'color.white' },
    eventList: { backgroundColor: 'color.white' },
    metrics: { backgroundColor: 'color.gray.100' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    timeline: { backgroundColor: 'color.gray.900' },
    eventList: { backgroundColor: 'color.gray.900' },
    metrics: { backgroundColor: 'color.gray.800' },
  },
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.view.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { AgentTraceProps } from './AgentTrace.props';
import { useAgentTrace } from './AgentTrace.state';
import { DefaultAgentTraceStyles } from './AgentTrace.style';
import { TraceTimeline } from './TraceTimeline';
import { TraceEventList } from './TraceEventList';
import { TraceMetrics } from './TraceMetrics';
import { TraceFilters } from './TraceFilters';
import { TraceVisualization } from './TraceVisualization';
import { Alert } from 'src/components/Alert/Alert';
import { Tabs } from 'src/components/Tabs/Tabs';
import { Loader } from 'src/components/Loader/Loader';
import { TextField } from 'src/components/Form/Form';

export interface AgentTraceViewProps
  extends Omit<AgentTraceProps, 'filter'>,
    ReturnType<typeof useAgentTrace> {}

/**
 * AgentTrace View Component
 *
 * Renders the complete trace visualization interface with timeline, events, and metrics
 */
const AgentTraceView: React.FC<AgentTraceViewProps> = ({
  // Props
  showTimeline = true,
  showMetrics = true,
  showVisualization = true,
  enableFiltering = true,
  enableExport = true,
  enableSearch = true,
  showEventDetails = true,
  showPerformanceMetrics = true,
  compactMode = false,
  views,
  ariaLabel = 'Agent Trace Visualization',
  ariaDescribedBy,

  // State from hook
  events,
  spans,
  selectedEvent,
  selectedSpan,
  metrics,
  isLoading,
  error,
  filter,
  searchQuery,
  currentVisualization,
  fetchTraceEvents,
  selectEvent,
  selectSpan,
  updateFilter,
  exportTrace,
  setSearchQuery,
  setCurrentVisualization,
  setError,

  ...props
}) => {
  /**
   * Handle event selection
   */
  const handleEventSelect = (eventId: string) => {
    selectEvent(eventId);
  };

  /**
   * Handle span selection
   */
  const handleSpanSelect = (spanId: string) => {
    selectSpan(spanId);
  };

  /**
   * Handle export
   */
  const handleExport = (format: 'json' | 'csv' | 'svg') => {
    exportTrace({
      format,
      includeMetadata: true,
      includeMetrics: true,
    });
  };

  /**
   * Handle refresh
   */
  const handleRefresh = () => {
    fetchTraceEvents();
  };

  return (
    <View
      {...DefaultAgentTraceStyles.container}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentTraceStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Trace
            </Text>
            <Text fontSize="sm" color="color.gray.600">
              {events.length} event{events.length !== 1 ? 's' : ''} • Session:{' '}
              {props.sessionId.slice(0, 8)}...
            </Text>
          </Vertical>

          <Horizontal gap={8}>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isLoading}
              aria-label="Refresh trace data"
            >
              {isLoading ? <Loader size="xs" /> : '🔄'}
            </Button>

            {enableExport && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleExport('json')}
                aria-label="Export trace data"
              >
                📤 Export
              </Button>
            )}
          </Horizontal>
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Alert variant="error" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {/* Search and Filters */}
      {enableSearch && (
        <View
          padding={16}
          borderBottom="1px solid"
          borderBottomColor="color.gray.200"
        >
          <Vertical gap={12}>
            <TextField
              placeholder="Search events..."
              value={searchQuery}
              onChange={setSearchQuery}
              views={{
                container: views?.searchInput,
              }}
            />

            {enableFiltering && (
              <TraceFilters
                filter={filter}
                onFilterChange={updateFilter}
                eventTypes={Array.from(new Set(events.map((e) => e.type)))}
              />
            )}
          </Vertical>
        </View>
      )}

      {/* Metrics */}
      {showMetrics && metrics && (
        <TraceMetrics
          metrics={metrics}
          showPerformanceMetrics={showPerformanceMetrics}
          compactMode={compactMode}
          views={{
            container: views?.metrics,
          }}
        />
      )}

      {/* Main Content */}
      <View flex={1} display="flex" flexDirection="column">
        {compactMode ? (
          // Compact mode - single view
          <TraceEventList
            events={events}
            selectedEvent={selectedEvent}
            onEventSelect={handleEventSelect}
            showDetails={showEventDetails}
            compactMode={true}
            views={{
              container: views?.eventList,
              eventItem: views?.eventItem,
              selectedEventItem: views?.selectedEventItem,
            }}
          />
        ) : (
          // Full mode - tabbed interface
          <Tabs defaultValue="timeline">
            <Tabs.List>
              {showTimeline && (
                <Tabs.Trigger value="timeline">Timeline</Tabs.Trigger>
              )}
              <Tabs.Trigger value="events">Events</Tabs.Trigger>
              {showVisualization && (
                <Tabs.Trigger value="visualization">Visualization</Tabs.Trigger>
              )}
            </Tabs.List>

            {showTimeline && (
              <Tabs.Content value="timeline">
                <TraceTimeline
                  events={events}
                  spans={spans}
                  selectedEvent={selectedEvent}
                  selectedSpan={selectedSpan}
                  onEventSelect={handleEventSelect}
                  onSpanSelect={handleSpanSelect}
                  views={{
                    container: views?.timeline,
                  }}
                />
              </Tabs.Content>
            )}

            <Tabs.Content value="events">
              <TraceEventList
                events={events}
                selectedEvent={selectedEvent}
                onEventSelect={handleEventSelect}
                showDetails={showEventDetails}
                compactMode={false}
                views={{
                  container: views?.eventList,
                  eventItem: views?.eventItem,
                  selectedEventItem: views?.selectedEventItem,
                }}
              />
            </Tabs.Content>

            {showVisualization && (
              <Tabs.Content value="visualization">
                <TraceVisualization
                  events={events}
                  spans={spans}
                  selectedEvent={selectedEvent}
                  visualizationType={currentVisualization}
                  onVisualizationChange={setCurrentVisualization}
                  onEventSelect={handleEventSelect}
                  views={{
                    container: views?.visualization,
                  }}
                />
              </Tabs.Content>
            )}
          </Tabs>
        )}
      </View>

      {/* Loading State */}
      {isLoading && events.length === 0 && (
        <View
          {...DefaultAgentTraceStyles.loadingState}
          {...views?.loadingState}
        >
          <Loader size="md" />
          <Text color="color.gray.600">Loading trace data...</Text>
        </View>
      )}

      {/* Empty State */}
      {!isLoading && events.length === 0 && (
        <View {...DefaultAgentTraceStyles.emptyState} {...views?.emptyState}>
          <Text fontSize="lg" color="color.gray.500" textAlign="center">
            No trace events found
          </Text>
          <Text fontSize="sm" color="color.gray.400" textAlign="center">
            Start interacting with the agent to see trace data
          </Text>
        </View>
      )}
    </View>
  );
};

export default AgentTraceView;
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceEventList.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { TraceEvent } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';

export interface TraceEventListProps {
  events: TraceEvent[];
  selectedEvent?: TraceEvent | null;
  onEventSelect: (eventId: string) => void;
  showDetails?: boolean;
  compactMode?: boolean;
  views?: {
    container?: any;
    eventItem?: any;
    selectedEventItem?: any;
  };
}

/**
 * TraceEventList Component
 *
 * Renders a list of trace events with selection and detail display
 */
export const TraceEventList: React.FC<TraceEventListProps> = ({
  events,
  selectedEvent,
  onEventSelect,
  showDetails = true,
  compactMode = false,
  views = {},
}) => {
  /**
   * Get event type badge style
   */
  const getEventTypeStyle = (type: string) => {
    const baseStyle = DefaultAgentTraceStyles.eventType;

    switch (type) {
      case 'llm_request':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeRequest };
      case 'llm_response':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeResponse };
      case 'function_call':
      case 'function_response':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeFunction };
      case 'error':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeError };
      default:
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeSystem };
    }
  };

  /**
   * Format timestamp
   */
  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3,
    });
  };

  /**
   * Format duration
   */
  const formatDuration = (duration?: number) => {
    if (!duration) return '';
    if (duration < 1000) return `${duration.toFixed(1)}ms`;
    return `${(duration / 1000).toFixed(2)}s`;
  };

  /**
   * Get event icon
   */
  const getEventIcon = (type: string) => {
    switch (type) {
      case 'llm_request':
        return '🤖';
      case 'llm_response':
        return '💬';
      case 'function_call':
        return '🔧';
      case 'function_response':
        return '✅';
      case 'user_input':
        return '👤';
      case 'agent_output':
        return '🎯';
      case 'error':
        return '❌';
      case 'system':
        return '⚙️';
      default:
        return '📝';
    }
  };

  /**
   * Render event data preview
   */
  const renderEventDataPreview = (event: TraceEvent) => {
    if (!showDetails) return null;

    let preview = '';
    try {
      if (typeof event.data === 'string') {
        preview =
          event.data.length > 100
            ? event.data.substring(0, 100) + '...'
            : event.data;
      } else if (event.data) {
        const dataStr = JSON.stringify(event.data);
        preview =
          dataStr.length > 100 ? dataStr.substring(0, 100) + '...' : dataStr;
      }
    } catch (err) {
      preview = '[Complex data structure]';
    }

    return preview;
  };

  return (
    <View {...DefaultAgentTraceStyles.eventList} {...views.container}>
      <Vertical gap={compactMode ? 4 : 8}>
        {events.map((event) => {
          const isSelected = selectedEvent?.id === event.id;
          const containerStyle = isSelected
            ? {
                ...DefaultAgentTraceStyles.selectedEventItem,
                ...views.selectedEventItem,
              }
            : { ...DefaultAgentTraceStyles.eventItem, ...views.eventItem };

          return (
            <View
              key={event.id}
              {...containerStyle}
              onClick={() => onEventSelect(event.id)}
            >
              <Vertical gap={compactMode ? 4 : 8}>
                {/* Event Header */}
                <Horizontal justifyContent="space-between" alignItems="center">
                  <Horizontal gap={8} alignItems="center">
                    <Text fontSize="16px">{getEventIcon(event.type)}</Text>
                    <View {...getEventTypeStyle(event.type)}>
                      <Text>{event.type.replace('_', ' ')}</Text>
                    </View>
                    {event.metadata?.title && (
                      <Text
                        fontSize="sm"
                        fontWeight="600"
                        color="color.gray.900"
                      >
                        {event.metadata.title}
                      </Text>
                    )}
                  </Horizontal>

                  <Horizontal gap={8} alignItems="center">
                    {event.duration && (
                      <Text {...DefaultAgentTraceStyles.eventDuration}>
                        {formatDuration(event.duration)}
                      </Text>
                    )}
                    <Text {...DefaultAgentTraceStyles.eventTimestamp}>
                      {formatTimestamp(event.timestamp)}
                    </Text>
                  </Horizontal>
                </Horizontal>

                {/* Event Description */}
                {event.metadata?.description && !compactMode && (
                  <Text fontSize="sm" color="color.gray.600">
                    {event.metadata.description}
                  </Text>
                )}

                {/* Event Data Preview */}
                {showDetails && !compactMode && (
                  <View {...DefaultAgentTraceStyles.eventContent}>
                    <Text
                      fontSize="sm"
                      fontFamily="Monaco, Consolas, monospace"
                    >
                      {renderEventDataPreview(event)}
                    </Text>
                  </View>
                )}

                {/* Event Tags */}
                {event.metadata?.tags &&
                  event.metadata.tags.length > 0 &&
                  !compactMode && (
                    <Horizontal gap={4} flexWrap="wrap">
                      {event.metadata.tags.map((tag, index) => (
                        <View key={index} {...DefaultAgentTraceStyles.tag}>
                          <Text fontSize="10px">{tag}</Text>
                        </View>
                      ))}
                    </Horizontal>
                  )}

                {/* Event Level Indicator */}
                {event.metadata?.level && event.metadata.level !== 'info' && (
                  <Horizontal alignItems="center" gap={4}>
                    <View
                      width="8px"
                      height="8px"
                      borderRadius="50%"
                      backgroundColor={
                        event.metadata.level === 'error'
                          ? 'color.red.500'
                          : event.metadata.level === 'warning'
                          ? 'color.yellow.500'
                          : 'color.blue.500'
                      }
                    />
                    <Text
                      fontSize="xs"
                      color="color.gray.600"
                      textTransform="uppercase"
                    >
                      {event.metadata.level}
                    </Text>
                  </Horizontal>
                )}

                {/* Expanded Details for Selected Event */}
                {isSelected && showDetails && (
                  <View {...DefaultAgentTraceStyles.eventMetadata}>
                    <Vertical gap={8}>
                      <Text
                        fontSize="xs"
                        fontWeight="600"
                        color="color.gray.700"
                      >
                        Event Details
                      </Text>

                      <Horizontal gap={16}>
                        <Text fontSize="xs" color="color.gray.600">
                          ID: {event.id}
                        </Text>
                        {event.parentId && (
                          <Text fontSize="xs" color="color.gray.600">
                            Parent: {event.parentId.slice(0, 8)}...
                          </Text>
                        )}
                      </Horizontal>

                      {event.attributes &&
                        Object.keys(event.attributes).length > 0 && (
                          <View>
                            <Text
                              fontSize="xs"
                              fontWeight="600"
                              color="color.gray.700"
                              marginBottom={4}
                            >
                              Attributes
                            </Text>
                            <View
                              padding={8}
                              backgroundColor="color.gray.100"
                              borderRadius="4px"
                              maxHeight="100px"
                              overflowY="auto"
                            >
                              <Text
                                fontSize="xs"
                                fontFamily="Monaco, Consolas, monospace"
                              >
                                {JSON.stringify(event.attributes, null, 2)}
                              </Text>
                            </View>
                          </View>
                        )}

                      <View>
                        <Text
                          fontSize="xs"
                          fontWeight="600"
                          color="color.gray.700"
                          marginBottom={4}
                        >
                          Data
                        </Text>
                        <View
                          padding={8}
                          backgroundColor="color.gray.100"
                          borderRadius="4px"
                          maxHeight="150px"
                          overflowY="auto"
                        >
                          <Text
                            fontSize="xs"
                            fontFamily="Monaco, Consolas, monospace"
                          >
                            {typeof event.data === 'string'
                              ? event.data
                              : JSON.stringify(event.data, null, 2)}
                          </Text>
                        </View>
                      </View>
                    </Vertical>
                  </View>
                )}
              </Vertical>
            </View>
          );
        })}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceFilters.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { TraceFilter } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';
import { Checkbox, TextField } from 'src/components/Form/Form';

export interface TraceFiltersProps {
  filter: TraceFilter;
  onFilterChange: (filter: TraceFilter) => void;
  eventTypes: string[];
}

/**
 * TraceFilters Component
 *
 * Renders filter controls for trace events
 */
export const TraceFilters: React.FC<TraceFiltersProps> = ({
  filter,
  onFilterChange,
  eventTypes,
}) => {
  const handleEventTypesChange = (selectedTypes: string[]) => {
    onFilterChange({
      ...filter,
      eventTypes: selectedTypes.length > 0 ? selectedTypes : undefined,
    });
  };

  const handleLevelChange = (selectedLevels: string[]) => {
    onFilterChange({
      ...filter,
      level: selectedLevels.length > 0 ? (selectedLevels as any) : undefined,
    });
  };

  const handleMinDurationChange = (value: string) => {
    const minDuration = parseFloat(value) || undefined;
    onFilterChange({
      ...filter,
      minDuration,
    });
  };

  const handleMaxDurationChange = (value: string) => {
    const maxDuration = parseFloat(value) || undefined;
    onFilterChange({
      ...filter,
      maxDuration,
    });
  };

  const handleTagsChange = (tagsString: string) => {
    const tags = tagsString
      .split(',')
      .map((tag) => tag.trim())
      .filter((tag) => tag.length > 0);
    onFilterChange({
      ...filter,
      tags: tags.length > 0 ? tags : undefined,
    });
  };

  const handleTimeRangeStartChange = (value: string) => {
    const start = value ? new Date(value) : undefined;
    onFilterChange({
      ...filter,
      timeRange: start
        ? {
            start,
            end: filter.timeRange?.end || new Date(),
          }
        : undefined,
    });
  };

  const handleTimeRangeEndChange = (value: string) => {
    const end = value ? new Date(value) : undefined;
    onFilterChange({
      ...filter,
      timeRange: end
        ? {
            start: filter.timeRange?.start || new Date(0),
            end,
          }
        : undefined,
    });
  };

  return (
    <View {...DefaultAgentTraceStyles.filters}>
      <Vertical gap={12}>
        {/* Event Types Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Event Types</Text>
          <Horizontal gap={8} flexWrap="wrap">
            {eventTypes.map((type) => (
              <Checkbox
                key={type}
                checked={filter.eventTypes?.includes(type) || false}
                onChange={(checked) => {
                  const currentTypes = filter.eventTypes || [];
                  const newTypes = checked
                    ? [...currentTypes, type]
                    : currentTypes.filter((t) => t !== type);
                  handleEventTypesChange(newTypes);
                }}
                label={type.replace('_', ' ')}
              />
            ))}
          </Horizontal>
        </View>

        {/* Level Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Log Levels</Text>
          <Horizontal gap={8}>
            {['info', 'warning', 'error', 'debug'].map((level) => (
              <Checkbox
                key={level}
                checked={filter.level?.includes(level as any) || false}
                onChange={(checked) => {
                  const currentLevels = filter.level || [];
                  const newLevels = checked
                    ? [...currentLevels, level]
                    : currentLevels.filter((l) => l !== level);
                  handleLevelChange(newLevels);
                }}
                label={level}
              />
            ))}
          </Horizontal>
        </View>

        {/* Duration Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>
            Duration Range (ms)
          </Text>
          <Horizontal gap={8} alignItems="center">
            <TextField
              placeholder="Min"
              type="number"
              value={filter.minDuration?.toString() || ''}
              onChange={handleMinDurationChange}
              style={{ width: '100px' }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <TextField
              placeholder="Max"
              type="number"
              value={filter.maxDuration?.toString() || ''}
              onChange={handleMaxDurationChange}
              style={{ width: '100px' }}
            />
          </Horizontal>
        </View>

        {/* Tags Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Filter by Tags</Text>
          <TextField
            placeholder="Enter tags separated by commas"
            value={filter.tags?.join(', ') || ''}
            onChange={handleTagsChange}
          />
        </View>

        {/* Time Range Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Time Range</Text>
          <Horizontal gap={8} alignItems="center">
            <input
              type="datetime-local"
              value={
                filter.timeRange?.start
                  ? new Date(
                      filter.timeRange.start.getTime() -
                        filter.timeRange.start.getTimezoneOffset() * 60000
                    )
                      .toISOString()
                      .slice(0, 16)
                  : ''
              }
              onChange={(e) => handleTimeRangeStartChange(e.target.value)}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <input
              type="datetime-local"
              value={
                filter.timeRange?.end
                  ? new Date(
                      filter.timeRange.end.getTime() -
                        filter.timeRange.end.getTimezoneOffset() * 60000
                    )
                      .toISOString()
                      .slice(0, 16)
                  : ''
              }
              onChange={(e) => handleTimeRangeEndChange(e.target.value)}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </Horizontal>
        </View>

        {/* Clear Filters */}
        {(filter.eventTypes ||
          filter.level ||
          filter.timeRange ||
          filter.tags ||
          filter.minDuration !== undefined ||
          filter.maxDuration !== undefined) && (
          <Horizontal justifyContent="flex-end">
            <button
              onClick={() => onFilterChange({})}
              style={{
                padding: '4px 8px',
                fontSize: '11px',
                color: '#6b7280',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                textDecoration: 'underline',
              }}
            >
              Clear all filters
            </button>
          </Horizontal>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceMetrics.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { TraceMetrics as TraceMetricsType } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';

export interface TraceMetricsProps {
  metrics: TraceMetricsType;
  showPerformanceMetrics?: boolean;
  compactMode?: boolean;
  views?: {
    container?: any;
  };
}

/**
 * TraceMetrics Component
 * 
 * Displays performance metrics and statistics for trace events
 */
export const TraceMetrics: React.FC<TraceMetricsProps> = ({
  metrics,
  showPerformanceMetrics = true,
  compactMode = false,
  views = {},
}) => {
  /**
   * Format duration
   */
  const formatDuration = (duration: number) => {
    if (duration < 1000) return `${duration.toFixed(1)}ms`;
    return `${(duration / 1000).toFixed(2)}s`;
  };

  /**
   * Format percentage
   */
  const formatPercentage = (value: number, total: number) => {
    if (total === 0) return '0%';
    return `${((value / total) * 100).toFixed(1)}%`;
  };

  /**
   * Get success rate color
   */
  const getSuccessRateColor = (successCount: number, totalCount: number) => {
    const rate = totalCount > 0 ? (successCount / totalCount) * 100 : 0;
    if (rate >= 95) return 'color.green.600';
    if (rate >= 80) return 'color.yellow.600';
    return 'color.red.600';
  };

  return (
    <View {...DefaultAgentTraceStyles.metrics} {...views.container}>
      <Vertical gap={compactMode ? 12 : 16}>
        {/* Main Metrics */}
        <View {...DefaultAgentTraceStyles.metricsGrid}>
          {/* Total Events */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text {...DefaultAgentTraceStyles.metricValue}>
              {metrics.totalEvents.toLocaleString()}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>
              Total Events
            </Text>
          </View>

          {/* Success Rate */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text 
              {...DefaultAgentTraceStyles.metricValue}
              color={getSuccessRateColor(metrics.successCount, metrics.totalEvents)}
            >
              {formatPercentage(metrics.successCount, metrics.totalEvents)}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>
              Success Rate
            </Text>
          </View>

          {/* Average Response Time */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text {...DefaultAgentTraceStyles.metricValue}>
              {formatDuration(metrics.averageResponseTime)}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>
              Avg Response
            </Text>
          </View>

          {/* Total Duration */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text {...DefaultAgentTraceStyles.metricValue}>
              {formatDuration(metrics.totalDuration)}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>
              Total Duration
            </Text>
          </View>

          {/* Error Count */}
          {metrics.errorCount > 0 && (
            <View {...DefaultAgentTraceStyles.metricCard}>
              <Text 
                {...DefaultAgentTraceStyles.metricValue}
                color="color.red.600"
              >
                {metrics.errorCount}
              </Text>
              <Text {...DefaultAgentTraceStyles.metricLabel}>
                Errors
              </Text>
            </View>
          )}

          {/* Function Calls */}
          {metrics.functionCallCount > 0 && (
            <View {...DefaultAgentTraceStyles.metricCard}>
              <Text {...DefaultAgentTraceStyles.metricValue}>
                {metrics.functionCallCount}
              </Text>
              <Text {...DefaultAgentTraceStyles.metricLabel}>
                Function Calls
              </Text>
            </View>
          )}

          {/* LLM Requests */}
          {metrics.llmRequestCount > 0 && (
            <View {...DefaultAgentTraceStyles.metricCard}>
              <Text {...DefaultAgentTraceStyles.metricValue}>
                {metrics.llmRequestCount}
              </Text>
              <Text {...DefaultAgentTraceStyles.metricLabel}>
                LLM Requests
              </Text>
            </View>
          )}
        </View>

        {/* Performance Metrics */}
        {showPerformanceMetrics && !compactMode && (
          <View>
            <Text fontSize="sm" fontWeight="600" color="color.gray.700" marginBottom={12}>
              Response Time Percentiles
            </Text>
            <Horizontal gap={16}>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p50)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>
                  P50
                </Text>
              </View>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p90)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>
                  P90
                </Text>
              </View>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p95)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>
                  P95
                </Text>
              </View>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p99)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>
                  P99
                </Text>
              </View>
            </Horizontal>
          </View>
        )}

        {/* Event Type Breakdown */}
        {!compactMode && Object.keys(metrics.eventsByType).length > 0 && (
          <View>
            <Text fontSize="sm" fontWeight="600" color="color.gray.700" marginBottom={12}>
              Events by Type
            </Text>
            <Horizontal gap={8} flexWrap="wrap">
              {Object.entries(metrics.eventsByType).map(([type, count]) => (
                <View 
                  key={type}
                  padding="6px 12px"
                  backgroundColor="color.blue.50"
                  borderRadius="6px"
                  border="1px solid"
                  borderColor="color.blue.200"
                >
                  <Horizontal gap={8} alignItems="center">
                    <Text fontSize="sm" fontWeight="600" color="color.blue.800">
                      {type.replace('_', ' ')}
                    </Text>
                    <Text fontSize="sm" color="color.blue.600">
                      {count}
                    </Text>
                    <Text fontSize="xs" color="color.blue.500">
                      ({formatPercentage(count, metrics.totalEvents)})
                    </Text>
                  </Horizontal>
                </View>
              ))}
            </Horizontal>
          </View>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceTimeline.tsx">
import React from 'react';
import { View, Horizontal, Text } from 'app-studio';
import { TraceEvent, TraceSpan } from './AgentTrace.props';
import { DefaultAgentTraceStyles, EventTypeColors } from './AgentTrace.style';

export interface TraceTimelineProps {
  events: TraceEvent[];
  spans: TraceSpan[];
  selectedEvent?: TraceEvent | null;
  selectedSpan?: TraceSpan | null;
  onEventSelect: (eventId: string) => void;
  onSpanSelect: (spanId: string) => void;
  views?: {
    container?: any;
  };
}

/**
 * TraceTimeline Component
 *
 * Renders a timeline visualization of trace events and spans
 */
export const TraceTimeline: React.FC<TraceTimelineProps> = ({
  events,
  spans,
  selectedEvent,
  selectedSpan,
  onEventSelect,
  onSpanSelect,
  views = {},
}) => {
  // Calculate timeline bounds
  const allTimestamps = events.map((e) => e.timestamp);
  const minTime = Math.min(...allTimestamps);
  const maxTime = Math.max(...allTimestamps);
  const timeRange = maxTime - minTime || 1000; // Fallback to 1 second

  /**
   * Convert timestamp to timeline position (0-100%)
   */
  const getTimelinePosition = (timestamp: number) => {
    return ((timestamp - minTime) / timeRange) * 100;
  };

  /**
   * Get event color based on type
   */
  const getEventColor = (type: string) => {
    return (
      EventTypeColors[type as keyof typeof EventTypeColors] || 'color.gray.500'
    );
  };

  /**
   * Format time for display
   */
  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3,
    });
  };

  /**
   * Generate time axis labels
   */
  const generateTimeLabels = () => {
    const labelCount = 5;
    const labels: Array<{
      timestamp: number;
      position: number;
      label: string;
    }> = [];

    for (let i = 0; i <= labelCount; i++) {
      const timestamp = minTime + (timeRange * i) / labelCount;
      const position = (i / labelCount) * 100;
      labels.push({
        timestamp,
        position,
        label: formatTime(timestamp),
      });
    }

    return labels;
  };

  const timeLabels = generateTimeLabels();

  return (
    <View {...DefaultAgentTraceStyles.timeline} {...views.container}>
      <View {...DefaultAgentTraceStyles.timelineContainer}>
        {/* Spans */}
        {spans.map((span, index) => {
          const startPos = getTimelinePosition(span.startTime);
          const endPos = span.endTime ? getTimelinePosition(span.endTime) : 100;
          const width = Math.max(endPos - startPos, 2); // Minimum 2% width
          const top = 20 + index * 35; // Stack spans vertically

          return (
            <View
              key={span.id}
              {...DefaultAgentTraceStyles.timelineSpan}
              style={{
                left: `${startPos}%`,
                width: `${width}%`,
                top: `${top}px`,
                borderColor:
                  span.status === 'error' ? 'color.red.500' : 'color.blue.500',
                color:
                  span.status === 'error' ? 'color.red.700' : 'color.blue.700',
              }}
              onClick={() => onSpanSelect(span.id)}
              title={`${span.name} (${
                span.duration ? `${span.duration}ms` : 'running'
              })`}
            >
              <Text fontSize="10px" fontWeight="600">
                {span.name}
              </Text>
            </View>
          );
        })}

        {/* Events */}
        {events.map((event, index) => {
          const position = getTimelinePosition(event.timestamp);
          const isSelected = selectedEvent?.id === event.id;
          const color = getEventColor(event.type);

          // Calculate vertical position to avoid overlap
          const eventsAtSameTime = events.filter(
            (e) => Math.abs(e.timestamp - event.timestamp) < timeRange * 0.01
          );
          const eventIndex = eventsAtSameTime.findIndex(
            (e) => e.id === event.id
          );
          const top = 100 + spans.length * 35 + eventIndex * 25;

          return (
            <View
              key={event.id}
              {...DefaultAgentTraceStyles.timelineEvent}
              style={{
                left: `${Math.max(0, position - 1)}%`, // Center the event
                width: '20px',
                top: `${top}px`,
                backgroundColor: color,
                border: isSelected ? '2px solid white' : 'none',
                boxShadow: isSelected ? '0 0 0 2px #3b82f6' : 'none',
                zIndex: isSelected ? 20 : 10,
              }}
              onClick={() => onEventSelect(event.id)}
              title={`${event.type} - ${formatTime(event.timestamp)}`}
            >
              <Text fontSize="8px" color="white">
                {event.type.charAt(0).toUpperCase()}
              </Text>
            </View>
          );
        })}

        {/* Time Axis */}
        <View {...DefaultAgentTraceStyles.timelineAxis}>
          {timeLabels.map((label, index) => (
            <View
              key={index}
              position="absolute"
              left={`${label.position}%`}
              top="0"
              transform="translateX(-50%)"
            >
              <View
                width="1px"
                height="10px"
                backgroundColor="color.gray.400"
                marginBottom="4px"
              />
              <Text fontSize="9px" color="color.gray.600" textAlign="center">
                {label.label}
              </Text>
            </View>
          ))}
        </View>

        {/* Legend */}
        <View
          position="absolute"
          top="10px"
          right="10px"
          padding="8px"
          backgroundColor="color.white"
          borderRadius="6px"
          border="1px solid"
          borderColor="color.gray.200"
          boxShadow="0 2px 4px rgba(0,0,0,0.1)"
        >
          <Text
            fontSize="10px"
            fontWeight="600"
            color="color.gray.700"
            marginBottom="4px"
          >
            Legend
          </Text>
          <View>
            {Object.entries(EventTypeColors).map(([type, color]) => {
              const eventCount = events.filter((e) => e.type === type).length;
              if (eventCount === 0) return null;

              return (
                <Horizontal
                  key={type}
                  gap={4}
                  alignItems="center"
                  marginBottom="2px"
                >
                  <View
                    width="8px"
                    height="8px"
                    borderRadius="2px"
                    backgroundColor={color}
                  />
                  <Text fontSize="9px" color="color.gray.600">
                    {type.replace('_', ' ')} ({eventCount})
                  </Text>
                </Horizontal>
              );
            })}
          </View>
        </View>
      </View>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceVisualization.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { TraceEvent, TraceSpan, VisualizationType } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';
import { Select } from 'src/components';

export interface TraceVisualizationProps {
  events: TraceEvent[];
  spans: TraceSpan[];
  selectedEvent?: TraceEvent | null;
  visualizationType: VisualizationType;
  onVisualizationChange: (type: VisualizationType) => void;
  onEventSelect: (eventId: string) => void;
  views?: {
    container?: any;
  };
}

/**
 * TraceVisualization Component
 *
 * Renders different visualization types for trace data
 */
export const TraceVisualization: React.FC<TraceVisualizationProps> = ({
  events,
  spans,
  selectedEvent,
  visualizationType,
  onVisualizationChange,
  onEventSelect,
  views = {},
}) => {
  /**
   * Build tree structure from events
   */
  const buildEventTree = () => {
    const eventMap = new Map(
      events.map((e) => [e.id, { ...e, children: [] as TraceEvent[] }])
    );
    const roots: TraceEvent[] = [];

    events.forEach((event) => {
      const eventWithChildren = eventMap.get(event.id)!;
      if (event.parentId && eventMap.has(event.parentId)) {
        eventMap.get(event.parentId)!.children.push(eventWithChildren);
      } else {
        roots.push(eventWithChildren);
      }
    });

    return roots;
  };

  /**
   * Render tree visualization
   */
  const renderTreeVisualization = () => {
    const tree = buildEventTree();

    const renderTreeNode = (event: TraceEvent, depth = 0) => {
      const isSelected = selectedEvent?.id === event.id;
      const indent = depth * 20;

      return (
        <View key={event.id}>
          <View
            padding="8px"
            marginLeft={`${indent}px`}
            backgroundColor={isSelected ? 'color.blue.50' : 'color.white'}
            border={isSelected ? '1px solid' : 'none'}
            borderColor={isSelected ? 'color.blue.300' : 'transparent'}
            borderRadius="4px"
            cursor="pointer"
            onClick={() => onEventSelect(event.id)}
          >
            <Horizontal gap={8} alignItems="center">
              <Text fontSize="12px">
                {event.type === 'llm_request'
                  ? '🤖'
                  : event.type === 'llm_response'
                  ? '💬'
                  : event.type === 'function_call'
                  ? '🔧'
                  : event.type === 'function_response'
                  ? '✅'
                  : event.type === 'error'
                  ? '❌'
                  : '📝'}
              </Text>
              <Text fontSize="sm" fontWeight="500">
                {event.metadata?.title || event.type}
              </Text>
              {event.duration && (
                <Text fontSize="xs" color="color.gray.500">
                  ({event.duration}ms)
                </Text>
              )}
            </Horizontal>
          </View>
          {event.children &&
            event.children.map((child) => renderTreeNode(child, depth + 1))}
        </View>
      );
    };

    return (
      <Vertical gap={4}>{tree.map((root) => renderTreeNode(root))}</Vertical>
    );
  };

  /**
   * Render table visualization
   */
  const renderTableVisualization = () => {
    return (
      <View overflowX="auto">
        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
          <thead>
            <tr
              style={{
                backgroundColor: '#f9fafb',
                borderBottom: '1px solid #e5e7eb',
              }}
            >
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Type
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Title
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Timestamp
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Duration
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Level
              </th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => {
              const isSelected = selectedEvent?.id === event.id;
              return (
                <tr
                  key={event.id}
                  style={{
                    backgroundColor: isSelected ? '#eff6ff' : 'white',
                    borderBottom: '1px solid #f3f4f6',
                    cursor: 'pointer',
                  }}
                  onClick={() => onEventSelect(event.id)}
                >
                  <td style={{ padding: '8px', fontSize: '12px' }}>
                    <Horizontal gap={4} alignItems="center">
                      <Text fontSize="12px">
                        {event.type === 'llm_request'
                          ? '🤖'
                          : event.type === 'llm_response'
                          ? '💬'
                          : event.type === 'function_call'
                          ? '🔧'
                          : event.type === 'function_response'
                          ? '✅'
                          : event.type === 'error'
                          ? '❌'
                          : '📝'}
                      </Text>
                      <Text fontSize="12px">{event.type}</Text>
                    </Horizontal>
                  </td>
                  <td style={{ padding: '8px', fontSize: '12px' }}>
                    {event.metadata?.title || '-'}
                  </td>
                  <td
                    style={{
                      padding: '8px',
                      fontSize: '12px',
                      fontFamily: 'Monaco, Consolas, monospace',
                    }}
                  >
                    {new Date(event.timestamp).toLocaleTimeString()}
                  </td>
                  <td
                    style={{
                      padding: '8px',
                      fontSize: '12px',
                      fontFamily: 'Monaco, Consolas, monospace',
                    }}
                  >
                    {event.duration ? `${event.duration}ms` : '-'}
                  </td>
                  <td style={{ padding: '8px', fontSize: '12px' }}>
                    {event.metadata?.level ? (
                      <View
                        padding="2px 6px"
                        borderRadius="4px"
                        backgroundColor={
                          event.metadata.level === 'error'
                            ? 'color.red.100'
                            : event.metadata.level === 'warning'
                            ? 'color.yellow.100'
                            : 'color.blue.100'
                        }
                        color={
                          event.metadata.level === 'error'
                            ? 'color.red.800'
                            : event.metadata.level === 'warning'
                            ? 'color.yellow.800'
                            : 'color.blue.800'
                        }
                        display="inline-block"
                      >
                        <Text
                          fontSize="10px"
                          fontWeight="600"
                          textTransform="uppercase"
                        >
                          {event.metadata.level}
                        </Text>
                      </View>
                    ) : (
                      '-'
                    )}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </View>
    );
  };

  /**
   * Render flamegraph visualization (simplified)
   */
  const renderFlamegraphVisualization = () => {
    const sortedEvents = [...events].sort((a, b) => a.timestamp - b.timestamp);
    const maxDuration = Math.max(
      ...events.filter((e) => e.duration).map((e) => e.duration!)
    );

    return (
      <Vertical gap={2}>
        {sortedEvents.map((event, index) => {
          const width = event.duration
            ? (event.duration / maxDuration) * 100
            : 10;
          const isSelected = selectedEvent?.id === event.id;

          return (
            <View
              key={event.id}
              height="24px"
              width={`${width}%`}
              backgroundColor={
                event.type === 'llm_request'
                  ? 'color.blue.500'
                  : event.type === 'llm_response'
                  ? 'color.green.500'
                  : event.type === 'function_call'
                  ? 'color.purple.500'
                  : event.type === 'error'
                  ? 'color.red.500'
                  : 'color.gray.500'
              }
              borderRadius="2px"
              cursor="pointer"
              display="flex"
              alignItems="center"
              paddingLeft="8px"
              border={isSelected ? '2px solid white' : 'none'}
              boxShadow={isSelected ? '0 0 0 2px #3b82f6' : 'none'}
              onClick={() => onEventSelect(event.id)}
              title={`${event.type} - ${event.duration || 0}ms`}
            >
              <Text fontSize="10px" color="white" fontWeight="600">
                {event.metadata?.title || event.type} ({event.duration || 0}ms)
              </Text>
            </View>
          );
        })}
      </Vertical>
    );
  };

  /**
   * Render current visualization
   */
  const renderVisualization = () => {
    switch (visualizationType) {
      case 'tree':
        return renderTreeVisualization();
      case 'table':
        return renderTableVisualization();
      case 'flamegraph':
        return renderFlamegraphVisualization();
      case 'graph':
        return (
          <View padding={32} textAlign="center">
            <Text color="color.gray.500">
              Graph visualization coming soon...
            </Text>
          </View>
        );
      default:
        return renderTreeVisualization();
    }
  };

  return (
    <View {...DefaultAgentTraceStyles.visualization} {...views.container}>
      <Vertical gap={16}>
        {/* Visualization Type Selector */}
        <Horizontal justifyContent="space-between" alignItems="center">
          <Text fontSize="sm" fontWeight="600" color="color.gray.700">
            Visualization Type
          </Text>
          <Select
            value={visualizationType}
            onChange={onVisualizationChange}
            options={[
              { value: 'tree', label: 'Tree View' },
              { value: 'table', label: 'Table View' },
              { value: 'flamegraph', label: 'Flamegraph' },
              { value: 'graph', label: 'Graph (Coming Soon)' },
            ]}
          />
        </Horizontal>

        {/* Visualization Content */}
        <View flex={1} overflowY="auto">
          {renderVisualization()}
        </View>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text } from 'app-studio';
import { AgentTrace } from '../AgentTrace';
import { TraceEvent } from '../AgentTrace/AgentTrace.props';

/**
 * Default AgentTrace Example
 *
 * Demonstrates basic usage of the AgentTrace component
 */
export const DefaultDemo = () => {
  const [selectedEvent, setSelectedEvent] = useState<TraceEvent | null>(null);

  const handleEventSelect = (event: TraceEvent) => {
    console.log('Event selected:', event);
    setSelectedEvent(event);
  };

  const handleError = (error: Error) => {
    console.error('AgentTrace error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentTrace Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A comprehensive trace visualization component for ADK agents. Displays
        execution traces, events, and performance metrics in an interactive
        format.
      </Text>

      {/* Selected Event Info */}
      {selectedEvent && (
        <View
          padding={16}
          backgroundColor="color.purple.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.purple.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.purple.800">
            Selected Event
          </Text>
          <Text fontSize={12} color="color.purple.600">
            ID: {selectedEvent.id}
          </Text>
          <Text fontSize={12} color="color.purple.600">
            Type: {selectedEvent.type}
          </Text>
          <Text fontSize={12} color="color.purple.600">
            Duration:{' '}
            {selectedEvent.duration ? `${selectedEvent.duration}ms` : 'N/A'}
          </Text>
        </View>
      )}

      {/* AgentTrace Component */}
      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="demo-user"
          appName="demo-agent"
          apiBaseUrl="http://localhost:3000/adk"
          showTimeline={true}
          showMetrics={true}
          showVisualization={true}
          enableFiltering={true}
          enableExport={true}
          enableSearch={true}
          enableAutoRefresh={false}
          visualizationType="timeline"
          onEventSelect={handleEventSelect}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * AgentTrace with Mock Data Example
 *
 * Shows the component with sample trace data
 */
export const MockDataDemo = () => {
  const mockEvents: TraceEvent[] = [
    {
      id: 'event-1',
      sessionId: 'session-123',
      type: 'user_input',
      timestamp: Date.now() - 10000,
      duration: 50,
      data: { message: 'Hello, can you help me with my code?' },
      metadata: {
        title: 'User Message',
        description: 'User asks for coding help',
        level: 'info',
        tags: ['user', 'input'],
      },
    },
    {
      id: 'event-2',
      sessionId: 'session-123',
      type: 'llm_request',
      timestamp: Date.now() - 9000,
      duration: 1200,
      data: {
        model: 'gpt-4',
        prompt: 'Help user with coding question',
        tokens: 150,
      },
      metadata: {
        title: 'LLM Request',
        description: 'Sending request to language model',
        level: 'info',
        tags: ['llm', 'request'],
      },
      parentId: 'event-1',
    },
    {
      id: 'event-3',
      sessionId: 'session-123',
      type: 'function_call',
      timestamp: Date.now() - 8000,
      duration: 800,
      data: {
        function: 'analyze_code',
        arguments: { language: 'python', code: 'def hello(): print("world")' },
      },
      metadata: {
        title: 'Code Analysis',
        description: 'Analyzing user code for improvements',
        level: 'info',
        tags: ['function', 'analysis'],
      },
      parentId: 'event-2',
    },
    {
      id: 'event-4',
      sessionId: 'session-123',
      type: 'function_response',
      timestamp: Date.now() - 7000,
      duration: 100,
      data: {
        result: {
          suggestions: [
            'Add type hints',
            'Use more descriptive variable names',
          ],
          score: 85,
        },
      },
      metadata: {
        title: 'Analysis Result',
        description: 'Code analysis completed successfully',
        level: 'info',
        tags: ['function', 'response'],
      },
      parentId: 'event-3',
    },
    {
      id: 'event-5',
      sessionId: 'session-123',
      type: 'llm_response',
      timestamp: Date.now() - 6000,
      duration: 300,
      data: {
        response: 'I analyzed your code and have some suggestions...',
        tokens: 200,
      },
      metadata: {
        title: 'LLM Response',
        description: 'Language model provides response',
        level: 'info',
        tags: ['llm', 'response'],
      },
      parentId: 'event-2',
    },
    {
      id: 'event-6',
      sessionId: 'session-123',
      type: 'agent_output',
      timestamp: Date.now() - 5000,
      duration: 150,
      data: {
        message: 'Here are some suggestions to improve your code...',
        suggestions: ['Add type hints', 'Use more descriptive variable names'],
      },
      metadata: {
        title: 'Agent Response',
        description: 'Final response sent to user',
        level: 'info',
        tags: ['agent', 'output'],
      },
      parentId: 'event-1',
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentTrace with Mock Data
      </Text>

      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="demo-user"
          appName="demo-agent"
          initialEvents={mockEvents}
          showTimeline={true}
          showMetrics={true}
          enableFiltering={true}
          visualizationType="timeline"
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Compact AgentTrace Example
 *
 * Shows the component in compact mode
 */
export const CompactDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Compact AgentTrace Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="user123"
          appName="compact-agent"
          compactMode={true}
          showTimeline={false}
          showVisualization={false}
          enableFiltering={false}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Real-time AgentTrace Example
 *
 * Demonstrates real-time updates and auto-refresh
 */
export const RealTimeDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Real-time AgentTrace Example
      </Text>

      <Text fontSize={14} color="color.gray.600">
        This example shows real-time trace updates with auto-refresh enabled.
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="user123"
          appName="realtime-agent"
          enableAutoRefresh={true}
          enableRealTimeUpdates={true}
          refreshInterval={5000}
          showTimeline={true}
          showMetrics={true}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentTrace Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentTrace Example
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.orange.200"
        borderRadius="12px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="user123"
          appName="custom-agent"
          visualizationType="tree"
          showPerformanceMetrics={true}
          enableExport={true}
          views={{
            container: {
              backgroundColor: 'color.orange.25',
              height: '100%',
            },
            header: {
              backgroundColor: 'color.orange.500',
              color: 'white',
            },
            timeline: {
              backgroundColor: 'color.white',
            },
            eventList: {
              backgroundColor: 'color.white',
            },
            metrics: {
              backgroundColor: 'color.orange.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace.tsx">
import React from 'react';
import { AgentTraceProps } from './AgentTrace/AgentTrace.props';
import AgentTraceView from './AgentTrace/AgentTrace.view';
import { useAgentTrace } from './AgentTrace/AgentTrace.state';

/**
 * AgentTrace Component
 * 
 * A comprehensive trace visualization component for ADK agents.
 * Displays execution traces, events, and performance metrics in an interactive format.
 * 
 * @example
 * ```tsx
 * <AgentTrace
 *   sessionId="session-123"
 *   userId="user123"
 *   appName="my-agent"
 *   onEventSelect={(event) => console.log('Event selected:', event)}
 * />
 * ```
 * 
 * @example
 * ```tsx
 * // With custom visualization and filtering
 * <AgentTrace
 *   sessionId="session-123"
 *   userId="user123"
 *   appName="my-agent"
 *   showTimeline={true}
 *   showMetrics={true}
 *   enableFiltering={true}
 *   enableExport={true}
 *   visualizationType="tree"
 *   autoRefresh={true}
 *   refreshInterval={5000}
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     timeline: { height: '200px' },
 *     eventList: { maxHeight: '400px' }
 *   }}
 * />
 * ```
 */
const AgentTrace: React.FC<AgentTraceProps> = (props) => {
  const traceState = useAgentTrace(props);

  return <AgentTraceView {...props} {...traceState} />;
};

export default AgentTrace;
export { AgentTrace };
export type { AgentTraceProps };
</file>

<file path="README-ADK.md">
# ADK Agent Components for React

[![TypeScript](https://img.shields.io/badge/TypeScript-Ready-blue.svg)](https://www.typescriptlang.org/)
[![React](https://img.shields.io/badge/React-18+-61DAFB.svg)](https://reactjs.org/)
[![ADK Compatible](https://img.shields.io/badge/ADK-Compatible-green.svg)](https://github.com/your-org/adk)

A comprehensive React component library for building applications with the Agent Development Kit (ADK). These components provide seamless integration with ADK agents while maintaining full compatibility with the existing ADK ecosystem.

## 🚀 Features

- **🤖 Complete Agent Interface**: Chat, session management, tracing, and evaluation
- **⚡ Real-time Communication**: WebSocket and SSE support for live updates
- **📁 File Handling**: Upload and preview images, videos, audio, and documents
- **🔧 Function Calls**: Visualize and execute agent function calls
- **💻 Code Execution**: Display and run code with syntax highlighting
- **📊 Performance Monitoring**: Comprehensive tracing and metrics
- **🧪 Evaluation Framework**: Test and validate agent performance
- **🎨 Fully Customizable**: Extensive styling and theming options
- **♿ Accessibility First**: WCAG 2.1 compliant with full keyboard navigation
- **📱 Responsive Design**: Works seamlessly across all device sizes
- **🔒 TypeScript Support**: Complete type definitions included

## 📦 Installation

```bash
npm install @app-studio/web
```

## 🏃‍♂️ Quick Start

```tsx
import React from 'react';
import { AgentChat, AgentServiceProvider } from '@app-studio/web';

function App() {
  return (
    <AgentServiceProvider config={{ baseUrl: 'https://your-adk-api.com' }}>
      <AgentChat
        appName="my-agent"
        userId="user123"
        enableFileUpload={true}
        enableStreaming={true}
      />
    </AgentServiceProvider>
  );
}

export default App;
```

## 🧩 Components

### AgentChat
Real-time chat interface with comprehensive agent interaction capabilities.

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  enableFileUpload={true}
  enableStreaming={true}
  enableThoughts={true}
  onMessageSent={(message) => console.log(message)}
/>
```

**Key Features:**
- Real-time messaging with streaming responses
- File upload with drag & drop support
- Function call visualization and execution
- Code execution with syntax highlighting
- Agent thought process display
- Message history and session management

### AgentSession
Comprehensive session management for organizing agent interactions.

```tsx
<AgentSession
  appName="my-agent"
  userId="user123"
  showSessionHistory={true}
  enableSessionImport={true}
  enableSessionExport={true}
/>
```

**Key Features:**
- Create, list, and manage sessions
- Import/export sessions in JSON format
- Search and filter capabilities
- Session metadata and tagging
- Real-time session updates

### AgentTrace
Advanced tracing and monitoring for agent execution analysis.

```tsx
<AgentTrace
  sessionId="session-123"
  userId="user123"
  appName="my-agent"
  showTimeline={true}
  showMetrics={true}
  enableFiltering={true}
/>
```

**Key Features:**
- Timeline visualization of execution traces
- Performance metrics and analytics
- Event filtering and search
- Multiple visualization types (timeline, tree, table, flamegraph)
- Real-time trace updates
- Export functionality (JSON, CSV, SVG)

### AgentEval
Comprehensive evaluation framework for testing agent performance.

```tsx
<AgentEval
  appName="my-agent"
  userId="user123"
  enableBatchEvaluation={true}
  enableMetricsComparison={true}
  enableResultExport={true}
/>
```

**Key Features:**
- Create and manage evaluations
- Test case execution and monitoring
- Results analysis and comparison
- Metrics calculation and visualization
- Batch evaluation support
- Template system for reusable evaluations

## 🔧 Service Integration

The components include a powerful service layer for backend communication:

```tsx
import { AgentServiceProvider, useAgentService } from '@app-studio/web';

// Wrap your app
<AgentServiceProvider config={{ baseUrl: 'https://api.example.com' }}>
  <App />
</AgentServiceProvider>

// Use in components
const { service, isConnected } = useAgentService();
```

**Service Features:**
- Automatic connection management
- Error handling and retry logic
- Real-time updates via WebSocket/SSE
- Connection status monitoring
- Utility functions for common operations

## 🎨 Customization

All components support extensive customization through the `views` prop:

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  views={{
    container: { backgroundColor: 'color.blue.50' },
    userMessage: { backgroundColor: 'color.blue.500' },
    botMessage: { backgroundColor: 'color.green.100' },
    input: { borderColor: 'color.blue.300' },
  }}
/>
```

## 🏗️ Architecture

### Component Structure
```
ComponentName/
├── ComponentName.tsx                 # Main component
├── ComponentName/                    # Core implementation
│   ├── ComponentName.props.ts        # TypeScript definitions
│   ├── ComponentName.state.ts        # State management hook
│   ├── ComponentName.view.tsx        # Presentational component
│   ├── ComponentName.style.ts        # Style constants
│   └── [SupportingComponents].tsx    # Sub-components
└── examples/                         # Usage examples
    └── default.tsx                   # Demo implementations
```

### ADK Compatibility
- **Same API patterns** as original adk-web Angular application
- **Compatible message formats** and data structures
- **Identical backend endpoints** and protocols
- **Session management** following ADK specifications

## 📋 Backend Requirements

Your ADK backend should provide these endpoints:

```
POST /sessions              # Create session
GET /sessions               # List sessions
POST /run                   # Send message (non-streaming)
POST /run_sse              # Send message (streaming)
GET /trace/events          # Get trace events (optional)
POST /evaluations          # Create evaluation (optional)
```

## 📖 Documentation

- **[Complete Documentation](./docs/adk-components.md)** - Comprehensive guide
- **[Quick Start Guide](./docs/adk-quick-start.md)** - Get started in minutes
- **[Demo Page](./src/pages/adkComponents.page.tsx)** - Interactive examples
- **Component Examples** - Available in each component's `examples/` directory

## 🔍 Examples

### Complete Agent Interface
```tsx
import { Tabs } from 'app-studio';

function AgentInterface() {
  return (
    <Tabs defaultValue="chat">
      <Tabs.List>
        <Tabs.Trigger value="chat">Chat</Tabs.Trigger>
        <Tabs.Trigger value="sessions">Sessions</Tabs.Trigger>
        <Tabs.Trigger value="trace">Trace</Tabs.Trigger>
        <Tabs.Trigger value="eval">Evaluation</Tabs.Trigger>
      </Tabs.List>

      <Tabs.Content value="chat">
        <AgentChat appName="my-agent" userId="user123" />
      </Tabs.Content>
      
      <Tabs.Content value="sessions">
        <AgentSession appName="my-agent" userId="user123" />
      </Tabs.Content>
      
      <Tabs.Content value="trace">
        <AgentTrace sessionId="current" userId="user123" appName="my-agent" />
      </Tabs.Content>
      
      <Tabs.Content value="eval">
        <AgentEval appName="my-agent" userId="user123" />
      </Tabs.Content>
    </Tabs>
  );
}
```

### Custom Service Configuration
```tsx
<AgentServiceProvider 
  config={{
    baseUrl: 'https://api.example.com',
    timeout: 30000,
    retryCount: 3,
    enableLogging: true,
    apiKey: 'your-api-key',
  }}
>
  <App />
</AgentServiceProvider>
```

## 🧪 Development

```bash
# Install dependencies
npm install

# Start development server
npm start

# Run tests
npm test

# Build for production
npm run build
```

## 🤝 Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- Built with [React](https://reactjs.org/) and [TypeScript](https://www.typescriptlang.org/)
- Styled with [app-studio](https://github.com/your-org/app-studio) design system
- Compatible with [ADK](https://github.com/your-org/adk) ecosystem

## 📞 Support

- 📚 [Documentation](./docs/adk-components.md)
- 🐛 [Issue Tracker](https://github.com/your-org/adk-components/issues)
- 💬 [Discussions](https://github.com/your-org/adk-components/discussions)
- 📧 [Email Support](mailto:support@your-org.com)
</file>

</files>
