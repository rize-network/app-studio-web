This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/adk-components.md, docs/adk-quick-start.md, src/components/adk, src/components/ChatInput
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  adk-components.md
  adk-quick-start.md
src/
  components/
    adk/
      AgentChat/
        AgentChat/
          AgentChat.props.ts
          AgentChat.state.ts
          AgentChat.style.ts
          AgentChat.view.tsx
          AgentMessage.tsx
          AgentRunProgress.tsx
          AgentTypingIndicator.tsx
          MessageAttachmentPreview.tsx
        examples/
          default.tsx
        AgentChat.tsx
      AgentEval/
        AgentEval/
          AgentEval.props.ts
          AgentEval.state.ts
          AgentEval.style.ts
          AgentEval.view.tsx
          EvaluationCreator.tsx
          EvaluationList.tsx
          EvaluationMetrics.tsx
          EvaluationResults.tsx
        examples/
          default.tsx
        AgentEval.tsx
      AgentSession/
        AgentSession/
          AgentSession.props.ts
          AgentSession.state.ts
          AgentSession.style.ts
          AgentSession.view.tsx
          SessionActions.tsx
          SessionFilters.tsx
          SessionListItem.tsx
        examples/
          default.tsx
        AgentSession.tsx
      AgentTrace/
        AgentTrace/
          AgentTrace.props.ts
          AgentTrace.state.ts
          AgentTrace.style.ts
          AgentTrace.view.tsx
          TraceEventList.tsx
          TraceFilters.tsx
          TraceMetrics.tsx
          TraceTimeline.tsx
          TraceVisualization.tsx
        examples/
          default.tsx
        AgentTrace.tsx
      useAdk.ts
    ChatInput/
      ChatInput/
        ChatInput.props.ts
        ChatInput.state.ts
        ChatInput.style.ts
        ChatInput.type.ts
        ChatInput.view.tsx
      examples/
        AudioWaveformChatInput.tsx
        EnhancedEditableInput.tsx
        index.ts
        MentionEditableInput.tsx
      AttachmentGroup.tsx
      AudioRecorder.tsx
      ChatInput.tsx
      ChatUploader.tsx
      EditableInput.tsx
      GuideTip.tsx
      index.ts
      MessageInput.tsx
      PromptExamples.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/adk/useAdk.ts">
import { useState, useEffect, useCallback } from 'react';
import {
  useAdkControllerCreateSessionService,
  useAdkControllerListSessionsService,
  useAdkControllerGetSessionService,
  useAdkControllerDeleteSessionService,
  useAdkControllerRunAgentService,
  useAdkControllerRunAgentStreamingService,
  useAdkControllerHealthCheckService,
  useAdkControllerGetServiceInfoService,
} from '../../services/api/services/AdkService';
import { useAuthStore } from '../../stores/AuthStore';
import type {
  CreateSessionParams,
  AgentRunRequest,
  SessionResponse,
} from '../../services/api';

/**
 * Custom hook for ADK operations
 * Integrates with the existing ADK service and auth store
 */
export const useAdk = () => {
  const { isAuthentificated, user } = useAuthStore();
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [sessions, setSessions] = useState<SessionResponse[]>([]);

  // Health check service
  const healthCheckService = useAdkControllerHealthCheckService({
    onSuccess: (data) => {
      console.log('ADK service is healthy:', data);
    },
    onError: (error) => {
      console.error('ADK health check failed:', error);
    },
  });

  // Service info service
  const serviceInfoService = useAdkControllerGetServiceInfoService({
    onSuccess: (data) => {
      console.log('ADK service info:', data);
    },
    onError: (error) => {
      console.error('Failed to get ADK service info:', error);
    },
  });

  // Create session service
  const createSessionService = useAdkControllerCreateSessionService({
    onSuccess: (data) => {
      console.log('Session created:', data);
      setCurrentSessionId(data.id);
      // Refresh sessions list
      listSessionsService.run();
    },
    onError: (error) => {
      console.error('Failed to create session:', error);
    },
  });

  // List sessions service
  const listSessionsService = useAdkControllerListSessionsService({
    onSuccess: (data) => {
      console.log('Sessions loaded:', data);
      setSessions(data);
    },
    onError: (error) => {
      console.error('Failed to list sessions:', error);
    },
  });

  // Get session service
  const getSessionService = useAdkControllerGetSessionService({
    onSuccess: (data) => {
      console.log('Session loaded:', data);
    },
    onError: (error) => {
      console.error('Failed to get session:', error);
    },
  });

  // Delete session service
  const deleteSessionService = useAdkControllerDeleteSessionService({
    onSuccess: () => {
      console.log('Session deleted');
      // Clear current session if it was deleted
      if (currentSessionId) {
        setCurrentSessionId(null);
      }
      // Refresh sessions list
      listSessionsService.run();
    },
    onError: (error) => {
      console.error('Failed to delete session:', error);
    },
  });

  // Run agent service (non-streaming)
  const runAgentService = useAdkControllerRunAgentService({
    onSuccess: (data) => {
      console.log('Agent response:', data);
    },
    onError: (error) => {
      console.error('Agent run failed:', error);
    },
  });

  // Run agent streaming service
  const runAgentStreamingService = useAdkControllerRunAgentStreamingService({
    onSuccess: (data) => {
      console.log('Agent streaming response:', data);
    },
    onError: (error) => {
      console.error('Agent streaming failed:', error);
    },
  });

  // Initialize ADK services when authenticated
  useEffect(() => {
    if (isAuthentificated && user) {
      // Check health and get service info
      healthCheckService.run();
      serviceInfoService.run();
      // Load user sessions
      listSessionsService.run();
    }
  }, [isAuthentificated, user]);

  // Helper functions
  const createSession = useCallback(
    (params: CreateSessionParams) => {
      if (!isAuthentificated) {
        console.error('User must be authenticated to create session');
        return;
      }
      createSessionService.run(params);
    },
    [isAuthentificated, createSessionService]
  );

  const loadSessions = useCallback(
    (appName?: string) => {
      if (!isAuthentificated) {
        console.error('User must be authenticated to load sessions');
        return;
      }
      listSessionsService.run(appName);
    },
    [isAuthentificated, listSessionsService]
  );

  const loadSession = useCallback(
    (sessionId: string) => {
      if (!isAuthentificated) {
        console.error('User must be authenticated to load session');
        return;
      }
      getSessionService.run(sessionId);
      setCurrentSessionId(sessionId);
    },
    [isAuthentificated, getSessionService]
  );

  const deleteSession = useCallback(
    (sessionId: string) => {
      if (!isAuthentificated) {
        console.error('User must be authenticated to delete session');
        return;
      }
      deleteSessionService.run(sessionId);
    },
    [isAuthentificated, deleteSessionService]
  );

  const runAgent = useCallback(
    (request: AgentRunRequest) => {
      if (!isAuthentificated) {
        console.error('User must be authenticated to run agent');
        return;
      }
      runAgentService.run(request);
    },
    [isAuthentificated, runAgentService]
  );

  const runAgentStreaming = useCallback(
    (request: AgentRunRequest) => {
      if (!isAuthentificated) {
        console.error('User must be authenticated to run agent streaming');
        return;
      }
      runAgentStreamingService.run(request);
    },
    [isAuthentificated, runAgentStreamingService]
  );

  const checkHealth = useCallback(() => {
    healthCheckService.run();
  }, [healthCheckService]);

  const getServiceInfo = useCallback(() => {
    serviceInfoService.run();
  }, [serviceInfoService]);

  return {
    // State
    isAuthenticated: isAuthentificated,
    user,
    currentSessionId,
    sessions,

    // Actions
    createSession,
    loadSessions,
    loadSession,
    deleteSession,
    runAgent,
    runAgentStreaming,
    checkHealth,
    getServiceInfo,
    setCurrentSessionId,

    // Service states
    isCreatingSession: createSessionService.loading,
    isLoadingSessions: listSessionsService.loading,
    isLoadingSession: getSessionService.loading,
    isDeletingSession: deleteSessionService.loading,
    isRunningAgent: runAgentService.loading,
    isRunningAgentStreaming: runAgentStreamingService.loading,
    isCheckingHealth: healthCheckService.loading,
    isLoadingServiceInfo: serviceInfoService.loading,

    // Service data
    sessionData: getSessionService.data,
    agentResponse: runAgentService.data,
    agentStreamingResponse: runAgentStreamingService.data,
    healthData: healthCheckService.data,
    serviceInfo: serviceInfoService.data,

    // Service errors
    createSessionError: createSessionService.error,
    listSessionsError: listSessionsService.error,
    getSessionError: getSessionService.error,
    deleteSessionError: deleteSessionService.error,
    runAgentError: runAgentService.error,
    runAgentStreamingError: runAgentStreamingService.error,
    healthError: healthCheckService.error,
    serviceInfoError: serviceInfoService.error,
  };
};
</file>

<file path="docs/adk-components.md">
# ADK Agent Components

This document provides an overview of the React components created for compatibility with the ADK (Agent Development Kit) system.

## Overview

The ADK Agent Components are a collection of React components designed to work seamlessly with ADK agents. These components are self-contained, handling their own state and API communications, providing a complete interface for agent interaction, session management, and more.

## Components

### 1. AgentChat Component

**Location**: `src/components/adk/AgentChat/`

A comprehensive chat interface for interacting with ADK agents.

#### Key Features:
- ✅ Real-time messaging via Server-Sent Events (SSE)
- ✅ File upload support (images, videos, audio, documents)
- ✅ Audio recording with live waveform visualization
- ✅ Function call visualization and execution
- ✅ Code execution and result display
- ✅ Agent thought process visualization
- ✅ Evaluation and scoring support
- ✅ Streaming and non-streaming responses
- ✅ Fully customizable styling and theming
- ✅ Accessibility-first design

#### Usage:
```tsx
import { AgentChat } from '@app-studio/web';

<AgentChat
  appName="my-agent"
  userId="user123"
  apiBaseUrl="https://your-adk-api.com"
  enableFileUpload={true}
  enableAudioRecording={true}
  enableStreaming={true}
  enableThoughts={true}
  onSessionCreate={(session) => console.log('Session created:', session)}
  onMessageSent={(message) => console.log('Message sent:', message)}
/>
```

#### Props:
- `appName` (required): Name of the ADK agent application.
- `userId` (required): Unique identifier for the user.
- `sessionId`: Existing session ID to resume.
- `apiBaseUrl`: Base URL for ADK API endpoints.
- `enableFileUpload`: Enable file attachment functionality.
- `enableAudioRecording`: Enable audio recording from the microphone.
- `enableStreaming`: Enable real-time streaming responses.
- `enableThoughts`: Show agent thought processes.
- `views`: Custom styling options.

### 2. AgentSession Component

**Location**: `src/components/adk/AgentSession/`

A comprehensive session management component for ADK agents.

#### Key Features:
- ✅ Session creation, listing, and selection
- ✅ Session deletion and management
- ✅ Import/export functionality
- ✅ Search and filtering capabilities
- ✅ Auto-refresh and real-time updates
- ✅ Session metadata and tagging
- ✅ Compact and full display modes
- ✅ Bulk operations support

#### Usage:
```tsx
import { AgentSession } from '@app-studio/web';

<AgentSession
  appName="my-agent"
  userId="user123"
  apiBaseUrl="https://your-adk-api.com"
  showSessionHistory={true}
  enableSessionImport={true}
  enableSessionExport={true}
  onSessionSelect={(session) => console.log('Selected:', session)}
  onSessionCreate={(session) => console.log('Created:', session)}
/>
```

#### Props:
- `appName` (required): Name of the ADK agent application.
- `userId` (required): Unique identifier for the user.
- `apiBaseUrl`: Base URL for ADK API endpoints.
- `showSessionHistory`: Show session history list.
- `enableSessionImport`: Enable session import from JSON.
- `enableSessionExport`: Enable session export to JSON.
- `enableSessionSearch`: Enable search functionality.
- `maxSessions`: Maximum number of sessions to display.
- `views`: Custom styling options.

## Architecture

### Component Structure

Each component follows the established app-studio pattern:

```
ComponentName/
├── ComponentName.tsx                 # Main component file
├── ComponentName/                    # Inner folder for core files
│   ├── ComponentName.props.ts        # Props interface definitions
│   ├── ComponentName.state.ts        # Custom state hook
│   ├── ComponentName.view.tsx        # Presentational component
│   ├── ComponentName.style.ts        # Style constants
│   └── [SupportingComponents].tsx    # Additional components
└── examples/                         # Usage examples
    └── default.tsx                   # Default usage examples
```

### ADK Integration

The components are self-contained and integrate directly with an ADK backend using `fetch`. You can specify the backend URL via the `apiBaseUrl` prop.

#### Required Backend Endpoints:
- `POST /sessions` - Create new agent session
- `POST /run_sse` - Send message with streaming response
- `POST /run` - Send message with regular response
- `GET /sessions/:id` - Get session details
- `DELETE /sessions/:id` - Delete session
- `POST /sessions/import` - Import session

#### Message Format:
The components use the same message format as the original ADK system:

```typescript
interface AgentRunRequest {
  appName: string;
  userId: string;
  sessionId: string;
  newMessage: {
    role: string;
    parts: MessagePart[];
  };
  streaming?: boolean;
}
```

### Direct API Interaction (`useAdk` Hook)
For developers who need to interact with the ADK API without using the pre-built UI components, a `useAdk` hook is available. This hook provides functions for all core ADK operations like creating sessions, running agents, and managing responses.

**Location**: `src/components/adk/useAdk.ts`

```tsx
import { useAdk } from '@app-studio/web';

const { createSession, runAgent, sessions, isLoadingSessions } = useAdk();
```

### Design System Compliance

All components follow the app-studio design system:

- **Typography**: Inter/Geist font family with standardized sizes (xs:10, sm:12, md:14, lg:16, xl:20)
- **Spacing**: 4px grid system for consistent spacing
- **Colors**: app-studio color system (color.[color].[number]) instead of hardcoded values
- **Shapes**: Consistent border radius and rounded corners
- **Animations**: Using app-studio Animation object with proper duration and timing

### Reusability

The components are designed to be:

- **Modular**: Each component can be used independently
- **Customizable**: Extensive styling options via the `views` prop
- **Accessible**: ARIA labels, keyboard navigation, and screen reader support
- **Responsive**: Works across mobile, tablet, and desktop breakpoints
- **Themeable**: Support for light/dark themes and custom color schemes

## Examples and Documentation

### Demo Pages

- **AgentChat Demo**: `src/pages/agentChat.page.tsx`
- **Component Examples**: Available in each component's `examples/` directory

### Usage Examples

Each component includes multiple usage examples:

1. **Default Usage**: Basic implementation with minimal configuration
2. **Minimal Usage**: Simplest possible setup
3. **Customized Usage**: Advanced styling and configuration options
4. **Feature Demos**: Showcasing specific features like function calls, file uploads, etc.

## Integration Guide

### 1. Installation

The components are part of the app-studio component library and can be imported directly:

```tsx
import { AgentChat, AgentSession } from '@app-studio/web';
```

### 2. Backend Setup

Ensure your ADK backend provides the required endpoints and follows the expected API format.

### 3. Basic Implementation

```tsx
import React from 'react';
import { AgentChat, AgentSession } from '@app-studio/web';
import { View, Horizontal } from 'app-studio';

const MyAgentApp = () => {
  return (
    <View height="100vh" padding={20}>
      <Horizontal gap={20} height="100%">
        {/* Session Management */}
        <View width="300px">
          <AgentSession
            appName="my-agent"
            userId="user123"
            apiBaseUrl="https://api.example.com"
          />
        </View>
        
        {/* Chat Interface */}
        <View flex={1}>
          <AgentChat
            appName="my-agent"
            userId="user123"
            apiBaseUrl="https://api.example.com"
          />
        </View>
      </Horizontal>
    </View>
  );
};
```

### 4. Advanced Configuration

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  apiBaseUrl="https://api.example.com"
  enableFileUpload={true}
  enableStreaming={true}
  enableThoughts={true}
  maxFileSize={10 * 1024 * 1024}
  allowedFileTypes={['image/*', 'video/*', 'application/pdf']}
  onSessionCreate={(session) => {
    console.log('New session:', session);
  }}
  onMessageSent={(message) => {
    console.log('Message sent:', message);
  }}
  onError={(error) => {
    console.error('Chat error:', error);
  }}
  views={{
    container: { backgroundColor: 'color.gray.50' },
    userMessage: { backgroundColor: 'color.blue.500' },
    botMessage: { backgroundColor: 'color.green.100' },
  }}
/>
```

## Complete Component Library

All planned components have been successfully implemented:

### ✅ **AgentTrace Component**
- **Timeline visualization** of agent execution traces
- **Event filtering and search** capabilities
- **Performance metrics** and analytics
- **Real-time trace updates** via WebSocket
- **Multiple visualization types** (timeline, tree, table, flamegraph)
- **Export functionality** (JSON, CSV, SVG)

### ✅ **AgentEval Component**
- **Evaluation creation and management** interface
- **Test case execution** and monitoring
- **Results analysis** and comparison
- **Metrics calculation** and visualization
- **Batch evaluation** support
- **Template system** for reusable evaluations

### ✅ **Agent Service Integration**
- **Enhanced service layer** for backend communication
- **React Provider pattern** for service management
- **Utility functions** for common operations
- **Real-time updates** via WebSocket and SSE
- **Error handling and retry logic**
- **Connection status monitoring**

## Demo Page

A comprehensive demo page showcasing all components is available at:
- **File**: `src/pages/adkComponents.page.tsx`
- **Features**: Interactive demos, customization examples, integration guides

## Support

For questions, issues, or contributions related to the ADK Agent Components, please refer to the main app-studio documentation or create an issue in the repository.

## Production Ready

All ADK Agent Components are **production-ready** and provide:
- ✅ Full ADK backend compatibility
- ✅ TypeScript support with comprehensive type definitions
- ✅ Accessibility compliance (ARIA labels, keyboard navigation)
- ✅ Responsive design for mobile, tablet, and desktop
- ✅ Comprehensive error handling and loading states
- ✅ Real-time updates and streaming support
- ✅ Extensive customization options
- ✅ Complete documentation and examples
</file>

<file path="docs/adk-quick-start.md">
# ADK Components Quick Start Guide

Get up and running with ADK Agent Components in minutes.

## Installation

The ADK components are part of the app-studio component library:

```bash
npm install @app-studio/web
```

## Basic Setup

### 1. Import Components

```tsx
import { 
  AgentChat, 
  AgentSession, 
  AgentTrace, 
  AgentEval 
} from '@app-studio/web';
```

### 2. Use Components

The ADK components are self-contained and handle their own API communications. Simply add them to your application and provide the necessary props.

```tsx
function YourApp() {
  return (
    <div style={{ display: 'flex', height: '100vh' }}>
      {/* Session Management */}
      <div style={{ width: '300px' }}>
        <AgentSession
          appName="my-agent"
          userId="user123"
          apiBaseUrl="https://your-adk-api.com"
        />
      </div>
      
      {/* Chat Interface */}
      <div style={{ flex: 1 }}>
        <AgentChat
          appName="my-agent"
          userId="user123"
          apiBaseUrl="https://your-adk-api.com"
          enableFileUpload={true}
          enableStreaming={true}
        />
      </div>
    </div>
  );
}
```

## Component Overview

### AgentChat
**Purpose**: Real-time chat interface with ADK agents
**Key Features**: File uploads, audio recording, streaming, function calls, code execution

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  enableFileUpload={true}
  enableAudioRecording={true}
  enableStreaming={true}
  enableThoughts={true}
  onMessageSent={(message) => console.log(message)}
/>
```

### AgentSession
**Purpose**: Session management and organization
**Key Features**: Create, list, import/export, search sessions

```tsx
<AgentSession
  appName="my-agent"
  userId="user123"
  showSessionHistory={true}
  enableSessionImport={true}
  enableSessionExport={true}
/>
```

### AgentTrace
**Purpose**: Visualize agent execution traces
**Key Features**: Timeline view, performance metrics, real-time updates

```tsx
<AgentTrace
  sessionId="session-123"
  userId="user123"
  appName="my-agent"
  showTimeline={true}
  showMetrics={true}
  enableFiltering={true}
/>
```

### AgentEval
**Purpose**: Run and manage agent evaluations
**Key Features**: Test creation, execution monitoring, results analysis

```tsx
<AgentEval
  appName="my-agent"
  userId="user123"
  enableBatchEvaluation={true}
  enableMetricsComparison={true}
  enableResultExport={true}
/>
```

## Common Patterns

### 1. Complete Agent Interface

```tsx
import { Tabs } from 'app-studio';

function AgentInterface() {
  return (
    <Tabs defaultValue="chat">
      <Tabs.List>
        <Tabs.Trigger value="chat">Chat</Tabs.Trigger>
        <Tabs.Trigger value="sessions">Sessions</Tabs.Trigger>
        <Tabs.Trigger value="trace">Trace</Tabs.Trigger>
        <Tabs.Trigger value="eval">Evaluation</Tabs.Trigger>
      </Tabs.List>

      <Tabs.Content value="chat">
        <AgentChat appName="my-agent" userId="user123" />
      </Tabs.Content>

      <Tabs.Content value="sessions">
        <AgentSession appName="my-agent" userId="user123" />
      </Tabs.Content>

      <Tabs.Content value="trace">
        <AgentTrace sessionId="current-session" userId="user123" appName="my-agent" />
      </Tabs.Content>

      <Tabs.Content value="eval">
        <AgentEval appName="my-agent" userId="user123" />
      </Tabs.Content>
    </Tabs>
  );
}
```

### 2. Custom Styling

```tsx
<AgentChat
  appName="my-agent"
  userId="user123"
  views={{
    container: { backgroundColor: 'color.blue.50' },
    userMessage: { backgroundColor: 'color.blue.500' },
    botMessage: { backgroundColor: 'color.green.100' },
    inputField: { borderColor: 'color.blue.300' },
  }}
/>
```

### 3. Event Handling

```tsx
function MyComponent() {
  const handleSessionCreate = (session) => {
    console.log('New session created:', session);
  };

  const handleMessageSent = (message) => {
    console.log('Message sent:', message);
  };

  const handleError = (error) => {
    console.error('Error:', error);
  };

  return (
    <AgentChat
      appName="my-agent"
      userId="user123"
      onSessionCreate={handleSessionCreate}
      onMessageSent={handleMessageSent}
      onError={handleError}
    />
  );
}
```

## Backend Requirements

Your ADK backend must provide these endpoints:

### Session Management
- `POST /sessions` - Create session
- `GET /sessions` - List sessions
- `GET /sessions/:id` - Get session
- `DELETE /sessions/:id` - Delete session

### Messaging
- `POST /run` - Send message (non-streaming)
- `POST /run_sse` - Send message (streaming)

### Tracing (Optional)
- `GET /trace/events` - Get trace events
- `GET /trace/spans` - Get trace spans
- `GET /trace/metrics` - Get trace metrics

### Evaluation (Optional)
- `POST /evaluations` - Create evaluation
- `GET /evaluations` - List evaluations
- `POST /evaluations/:id/start` - Start evaluation

## Environment Variables

```bash
# .env
REACT_APP_AGENT_API_URL=https://your-adk-api.com
REACT_APP_AGENT_API_KEY=your-api-key
```

## TypeScript Support

All components include comprehensive TypeScript definitions:

```tsx
import type { 
  AgentChatProps,
  AgentSessionProps,
  AgentTraceProps,
  AgentEvalProps,
  AgentMessage,
  AgentSession,
  TraceEvent,
  EvaluationRun
} from '@app-studio/web';
```

## Troubleshooting

### Common Issues

1.  **API errors**: Check the `apiBaseUrl` prop and ensure your backend URL and API endpoints are correct.
2.  **Styling issues**: Verify you're using the app-studio color system.
3.  **TypeScript errors**: Import types from the correct package.

## Next Steps

- Explore the [complete documentation](./adk-components.md)
- Check out the [demo page](../src/pages/adkComponents.page.tsx)
- View component examples in each component's `examples/` directory
- Customize components using the `views` prop system

## Support

For questions or issues:
- Check the component documentation
- Review the example implementations
- Create an issue in the repository
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentRunProgress.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { Loader } from '../../../Loader/Loader';
import { AgentMessage } from './AgentChat.props';
import { DefaultAgentChatStyles } from './AgentChat.style';

interface AgentRunProgressProps {
  messages: AgentMessage[];
  isTyping: boolean;
}

/**
 * Displays a step-by-step view of the agent's reasoning and execution
 */
export const AgentRunProgress: React.FC<AgentRunProgressProps> = ({
  messages,
  isTyping,
}) => {
  const steps = messages
    .filter(
      (m) =>
        m.thought ||
        m.functionCall ||
        m.functionResponse ||
        m.executableCode ||
        m.codeExecutionResult
    )
    .map((m) => {
      if (m.thought) {
        return { id: m.id, label: m.text || 'Thinking', done: true };
      }
      if (m.functionCall) {
        return {
          id: m.id,
          label: `Call ${m.functionCall.name}`,
          done: true,
        };
      }
      if (m.functionResponse) {
        return {
          id: m.id,
          label: `Response ${m.functionResponse.name}`,
          done: true,
        };
      }
      if (m.executableCode) {
        return { id: m.id, label: 'Execute code', done: true };
      }
      if (m.codeExecutionResult) {
        return { id: m.id, label: 'Execution result', done: true };
      }
      return null;
    })
    .filter(Boolean) as { id: string; label: string; done: boolean }[];

  if (isTyping) {
    steps.push({ id: 'typing', label: 'Thinking...', done: false });
  }

  if (steps.length === 0) return null;

  return (
    <View {...DefaultAgentChatStyles.runProgress}>
      <Vertical gap={4}>
        {steps.map((step) => (
          <Horizontal key={step.id} alignItems="center" gap={8}>
            {step.done ? (
              <Text color="color.green.600">✔</Text>
            ) : (
              <Loader size="xs" />
            )}
            <Text fontSize="sm" color="color.gray.700">
              {step.label}
            </Text>
          </Horizontal>
        ))}
      </Vertical>
    </View>
  );
};

export default AgentRunProgress;
</file>

<file path="src/components/adk/AgentChat/AgentChat.tsx">
import React from 'react';
import { AgentChatProps } from './AgentChat/AgentChat.props';
import AgentChatView from './AgentChat/AgentChat.view';
import { useAgentChat } from './AgentChat/AgentChat.state';

/**
 * AgentChat Component
 *
 * A comprehensive chat interface for interacting with ADK agents.
 * Supports real-time messaging, file uploads, agent responses, and session management.
 *
 * @example
 * ```tsx
 * <AgentChat
 *   appName="my-agent"
 *   userId="user123"
 *   onSessionCreate={(session) => console.log('Session created:', session)}
 *   onMessageSent={(message) => console.log('Message sent:', message)}
 * />
 * ```
 *
 * @example
 * ```tsx
 * // With custom styling and configuration
 * <AgentChat
 *   appName="my-agent"
 *   userId="user123"
 *   enableFileUpload={true}
 *   enableAudioRecording={true}
 *   enableVideoRecording={true}
 *   maxFileSize={10 * 1024 * 1024} // 10MB
 *   apiBaseUrl="http://localhost:3000/adk"
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     messageList: { maxHeight: '400px' },
 *     inputArea: { borderRadius: '12px' }
 *   }}
 * />
 * ```
 */
const AgentChat: React.FC<AgentChatProps> = (props) => {
  const chatState = useAgentChat(props);

  return <AgentChatView {...props} {...chatState} />;
};

export default AgentChat;
export { AgentChat };
export type { AgentChatProps };
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentEvalProps,
  EvaluationRun,
  EvaluationResult,
  EvaluationTestCase,
  EvaluationMetric,
  EvaluationTemplate,
  EvaluationExportOptions,
} from './AgentEval.props';

/**
 * Custom hook for managing AgentEval state and operations
 */
export const useAgentEval = (props: AgentEvalProps) => {
  const {
    appName,
    userId,
    apiBaseUrl = '',
    maxConcurrentEvals = 3,
    maxTestCases = 100,
    refreshInterval = 10000,
    enableAutoRefresh = false,
    initialEvaluations = [],
    selectedEvaluationId,
    availableTemplates = [],
    onEvaluationCreate,
    onEvaluationStart,
    onEvaluationComplete,
    onEvaluationCancel,
    onEvaluationDelete,
    onTestCaseSelect,
    onResultSelect,
    onExport,
    onError,
    onRefresh,
  } = props;

  // Core state
  const [evaluations, setEvaluations] =
    useState<EvaluationRun[]>(initialEvaluations);
  const [selectedEvaluation, setSelectedEvaluation] =
    useState<EvaluationRun | null>(null);
  const [selectedResult, setSelectedResult] = useState<EvaluationResult | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [templates, setTemplates] =
    useState<EvaluationTemplate[]>(availableTemplates);

  // Refs
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  /**
   * Fetch evaluations from API
   */
  const fetchEvaluations = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(
        `${apiBaseUrl}/evaluations?appName=${appName}&userId=${userId}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch evaluations: ${response.statusText}`);
      }

      const data: EvaluationRun[] = await response.json();
      setEvaluations(data);
      onRefresh?.();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl, appName, userId, onRefresh, onError]);

  /**
   * Create a new evaluation
   */
  const createEvaluation = useCallback(
    async (
      name: string,
      testCases: EvaluationTestCase[],
      metrics: EvaluationMetric[],
      config?: any
    ) => {
      try {
        setIsCreating(true);
        setError(null);

        const evaluation: Partial<EvaluationRun> = {
          name,
          appName,
          userId,
          status: 'pending',
          progress: 0,
          startTime: Date.now(),
          testCases,
          metrics,
          config,
        };

        const response = await fetch(`${apiBaseUrl}/evaluations`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(evaluation),
        });

        if (!response.ok) {
          throw new Error(
            `Failed to create evaluation: ${response.statusText}`
          );
        }

        const newEvaluation: EvaluationRun = await response.json();
        setEvaluations((prev) => [newEvaluation, ...prev]);
        setSelectedEvaluation(newEvaluation);
        onEvaluationCreate?.(newEvaluation);

        return newEvaluation;
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
        throw error;
      } finally {
        setIsCreating(false);
      }
    },
    [apiBaseUrl, appName, userId, onEvaluationCreate, onError]
  );

  /**
   * Start an evaluation
   */
  const startEvaluation = useCallback(
    async (evaluationId: string) => {
      try {
        setError(null);

        const response = await fetch(
          `${apiBaseUrl}/evaluations/${evaluationId}/start`,
          {
            method: 'POST',
          }
        );

        if (!response.ok) {
          throw new Error(`Failed to start evaluation: ${response.statusText}`);
        }

        // Update evaluation status
        setEvaluations((prev) =>
          prev.map((evaluation) =>
            evaluation.id === evaluationId
              ? { ...evaluation, status: 'running', progress: 0 }
              : evaluation
          )
        );

        onEvaluationStart?.(evaluationId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      }
    },
    [apiBaseUrl, onEvaluationStart, onError]
  );

  /**
   * Cancel an evaluation
   */
  const cancelEvaluation = useCallback(
    async (evaluationId: string) => {
      try {
        setError(null);

        const response = await fetch(
          `${apiBaseUrl}/evaluations/${evaluationId}/cancel`,
          {
            method: 'POST',
          }
        );

        if (!response.ok) {
          throw new Error(
            `Failed to cancel evaluation: ${response.statusText}`
          );
        }

        // Update evaluation status
        setEvaluations((prev) =>
          prev.map((evaluation) =>
            evaluation.id === evaluationId
              ? { ...evaluation, status: 'cancelled' }
              : evaluation
          )
        );

        onEvaluationCancel?.(evaluationId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      }
    },
    [apiBaseUrl, onEvaluationCancel, onError]
  );

  /**
   * Delete an evaluation
   */
  const deleteEvaluation = useCallback(
    async (evaluationId: string) => {
      try {
        setError(null);

        const response = await fetch(
          `${apiBaseUrl}/evaluations/${evaluationId}`,
          {
            method: 'DELETE',
          }
        );

        if (!response.ok) {
          throw new Error(
            `Failed to delete evaluation: ${response.statusText}`
          );
        }

        setEvaluations((prev) =>
          prev.filter((evaluation) => evaluation.id !== evaluationId)
        );

        if (selectedEvaluation?.id === evaluationId) {
          setSelectedEvaluation(null);
        }

        onEvaluationDelete?.(evaluationId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      }
    },
    [apiBaseUrl, selectedEvaluation, onEvaluationDelete, onError]
  );

  /**
   * Select an evaluation
   */
  const selectEvaluation = useCallback(
    (evaluationId: string) => {
      const evaluation = evaluations.find((e) => e.id === evaluationId);
      if (evaluation) {
        setSelectedEvaluation(evaluation);
      }
    },
    [evaluations]
  );

  /**
   * Select a result
   */
  const selectResult = useCallback(
    (result: EvaluationResult) => {
      setSelectedResult(result);
      onResultSelect?.(result);
    },
    [onResultSelect]
  );

  /**
   * Export evaluation data
   */
  const exportEvaluations = useCallback(
    async (options: EvaluationExportOptions) => {
      try {
        const evaluationsToExport = options.evaluationIds
          ? evaluations.filter((e) => options.evaluationIds!.includes(e.id))
          : evaluations;

        let exportData: any;
        let filename: string;
        let mimeType: string;

        switch (options.format) {
          case 'json':
            exportData = {
              evaluations: evaluationsToExport,
              ...(options.includeMetrics && {
                metrics: evaluationsToExport.flatMap((e) => e.metrics),
              }),
              exportedAt: new Date().toISOString(),
              exportedBy: userId,
            };
            filename = `evaluations-${
              new Date().toISOString().split('T')[0]
            }.json`;
            mimeType = 'application/json';
            break;

          case 'csv':
            const csvHeaders = [
              'id',
              'name',
              'status',
              'progress',
              'passRate',
              'averageScore',
              'duration',
            ];
            const csvRows = evaluationsToExport.map((evaluation) => [
              evaluation.id,
              evaluation.name,
              evaluation.status,
              evaluation.progress,
              evaluation.summary?.passRate || 0,
              evaluation.summary?.averageScore || 0,
              evaluation.duration || 0,
            ]);
            exportData = [csvHeaders, ...csvRows]
              .map((row) => row.join(','))
              .join('\n');
            filename = `evaluations-${
              new Date().toISOString().split('T')[0]
            }.csv`;
            mimeType = 'text/csv';
            break;

          default:
            throw new Error(`Export format ${options.format} not supported`);
        }

        // Create and download file
        const blob = new Blob(
          [
            typeof exportData === 'string'
              ? exportData
              : JSON.stringify(exportData, null, 2),
          ],
          {
            type: mimeType,
          }
        );
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
        onExport?.(options.format);
      } catch (err) {
        const error =
          err instanceof Error
            ? err
            : new Error('Failed to export evaluations');
        setError(error.message);
        onError?.(error);
      }
    },
    [evaluations, userId, onExport, onError]
  );

  /**
   * Filter evaluations based on search query
   */
  const getFilteredEvaluations = useCallback(() => {
    if (!searchQuery) return evaluations;

    const query = searchQuery.toLowerCase();
    return evaluations.filter(
      (evaluation) =>
        evaluation.name.toLowerCase().includes(query) ||
        evaluation.id.toLowerCase().includes(query) ||
        evaluation.status.toLowerCase().includes(query)
    );
  }, [evaluations, searchQuery]);

  /**
   * Get running evaluations count
   */
  const getRunningEvaluationsCount = useCallback(() => {
    return evaluations.filter((e) => e.status === 'running').length;
  }, [evaluations]);

  /**
   * Set up real-time updates via WebSocket
   */
  const setupRealTimeUpdates = useCallback(() => {
    if (!props.enableRealTimeUpdates) return;

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${apiBaseUrl.replace(
      /^https?:\/\//,
      ''
    )}/evaluations/ws?userId=${userId}`;

    wsRef.current = new WebSocket(wsUrl);

    wsRef.current.onmessage = (event) => {
      try {
        const update = JSON.parse(event.data);

        switch (update.type) {
          case 'progress':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? { ...e, progress: update.data.progress }
                  : e
              )
            );
            break;
          case 'result':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? {
                      ...e,
                      results: [...(e.results || []), update.data],
                    }
                  : e
              )
            );
            break;
          case 'complete':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? {
                      ...e,
                      status: 'completed',
                      endTime: update.timestamp,
                      duration: update.timestamp - e.startTime,
                      summary: update.data.summary,
                    }
                  : e
              )
            );
            onEvaluationComplete?.(update.data);
            break;
          case 'error':
            setEvaluations((prev) =>
              prev.map((e) =>
                e.id === update.evaluationId
                  ? { ...e, status: 'failed', error: update.data.error }
                  : e
              )
            );
            break;
        }
      } catch (err) {
        console.error('Error parsing WebSocket message:', err);
      }
    };

    wsRef.current.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }, [props.enableRealTimeUpdates, apiBaseUrl, userId, onEvaluationComplete]);

  /**
   * Initialize evaluations on mount
   */
  useEffect(() => {
    fetchEvaluations();
    setupRealTimeUpdates();
  }, [fetchEvaluations, setupRealTimeUpdates]);

  /**
   * Set up auto-refresh
   */
  useEffect(() => {
    if (enableAutoRefresh && refreshInterval > 0) {
      refreshIntervalRef.current = setInterval(
        fetchEvaluations,
        refreshInterval
      );

      return () => {
        if (refreshIntervalRef.current) {
          clearInterval(refreshIntervalRef.current);
        }
      };
    }

    return () => {
      // Cleanup function for when auto-refresh is disabled
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
    };
  }, [enableAutoRefresh, refreshInterval, fetchEvaluations]);

  /**
   * Select initial evaluation
   */
  useEffect(() => {
    if (selectedEvaluationId && evaluations.length > 0 && !selectedEvaluation) {
      selectEvaluation(selectedEvaluationId);
    }
  }, [selectedEvaluationId, evaluations, selectedEvaluation, selectEvaluation]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  return {
    // State
    evaluations: getFilteredEvaluations(),
    selectedEvaluation,
    selectedResult,
    isLoading,
    isCreating,
    error,
    searchQuery,
    templates,

    // Actions
    fetchEvaluations,
    createEvaluation,
    startEvaluation,
    cancelEvaluation,
    deleteEvaluation,
    selectEvaluation,
    selectResult,
    exportEvaluations,
    setSearchQuery,
    setError,

    // Computed
    runningEvaluationsCount: getRunningEvaluationsCount(),
    canStartNewEvaluation: getRunningEvaluationsCount() < maxConcurrentEvals,
  };
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentEval component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentEvalStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  evaluationList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    padding: '16px',
  } as ViewProps,

  evaluationItem: {
    padding: '16px',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginBottom: '12px',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  activeEvaluationItem: {
    padding: '16px',
    borderRadius: '8px',
    border: '2px solid',
    borderColor: 'color.blue.500',
    backgroundColor: 'color.blue.50',
    cursor: 'pointer',
    marginBottom: '12px',
  } as ViewProps,

  evaluationHeader: {
    marginBottom: '12px',
  } as ViewProps,

  evaluationTitle: {
    fontSize: '16px',
    fontWeight: '600',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  evaluationMeta: {
    fontSize: '12px',
    color: 'color.gray.500',
  } as ViewProps,

  statusBadge: {
    padding: '4px 8px',
    fontSize: '11px',
    fontWeight: '600',
    borderRadius: '12px',
    textTransform: 'uppercase',
  } as ViewProps,

  statusPending: {
    backgroundColor: 'color.gray.100',
    color: 'color.gray.800',
  } as ViewProps,

  statusRunning: {
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
  } as ViewProps,

  statusCompleted: {
    backgroundColor: 'color.green.100',
    color: 'color.green.800',
  } as ViewProps,

  statusFailed: {
    backgroundColor: 'color.red.100',
    color: 'color.red.800',
  } as ViewProps,

  statusCancelled: {
    backgroundColor: 'color.yellow.100',
    color: 'color.yellow.800',
  } as ViewProps,

  progressBar: {
    width: '100%',
    height: '8px',
    backgroundColor: 'color.gray.200',
    borderRadius: '4px',
    overflow: 'hidden',
    marginTop: '8px',
  } as ViewProps,

  progressFill: {
    height: '100%',
    backgroundColor: 'color.blue.500',
    borderRadius: '4px',
    transition: 'width 0.3s ease',
  } as ViewProps,

  evaluationActions: {
    marginTop: '12px',
  } as ViewProps,

  actionButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    backgroundColor: 'color.white',
    color: 'color.gray.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginRight: '8px',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.700',
    },
  } as ViewProps,

  startButton: {
    borderColor: 'color.green.300',
    color: 'color.green.700',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  cancelButton: {
    borderColor: 'color.red.300',
    color: 'color.red.700',
    ':hover': {
      borderColor: 'color.red.400',
      backgroundColor: 'color.red.50',
      color: 'color.red.800',
    },
  } as ViewProps,

  deleteButton: {
    borderColor: 'color.red.300',
    color: 'color.red.700',
    ':hover': {
      borderColor: 'color.red.400',
      backgroundColor: 'color.red.50',
      color: 'color.red.800',
    },
  } as ViewProps,

  createPanel: {
    flex: 1,
    padding: '24px',
    backgroundColor: 'color.white',
    overflowY: 'auto',
  } as ViewProps,

  formGroup: {
    marginBottom: '20px',
  } as ViewProps,

  formLabel: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '8px',
    display: 'block',
  } as ViewProps,

  formInput: {
    width: '100%',
    padding: '8px 12px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    borderRadius: '6px',
    fontSize: '14px',
  } as ViewProps,

  formTextarea: {
    width: '100%',
    padding: '8px 12px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    borderRadius: '6px',
    fontSize: '14px',
    minHeight: '100px',
    resize: 'vertical',
  } as ViewProps,

  resultsPanel: {
    flex: 1,
    padding: '16px',
    backgroundColor: 'color.white',
    overflowY: 'auto',
  } as ViewProps,

  resultsSummary: {
    padding: '16px',
    backgroundColor: 'color.gray.50',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    marginBottom: '20px',
  } as ViewProps,

  summaryGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))',
    gap: '16px',
  } as ViewProps,

  summaryCard: {
    textAlign: 'center',
  } as ViewProps,

  summaryValue: {
    fontSize: '24px',
    fontWeight: '700',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  summaryLabel: {
    fontSize: '12px',
    color: 'color.gray.600',
    textTransform: 'uppercase',
    fontWeight: '600',
  } as ViewProps,

  testCaseList: {
    marginTop: '20px',
  } as ViewProps,

  testCaseItem: {
    padding: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    marginBottom: '8px',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  testCaseHeader: {
    marginBottom: '8px',
  } as ViewProps,

  testCaseName: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.900',
  } as ViewProps,

  testCaseStatus: {
    fontSize: '12px',
    fontWeight: '600',
    textTransform: 'uppercase',
  } as ViewProps,

  testCasePass: {
    color: 'color.green.700',
  } as ViewProps,

  testCaseFail: {
    color: 'color.red.700',
  } as ViewProps,

  testCaseError: {
    color: 'color.orange.700',
  } as ViewProps,

  testCaseSkip: {
    color: 'color.gray.600',
  } as ViewProps,

  metricsPanel: {
    flex: 1,
    padding: '16px',
    backgroundColor: 'color.white',
    overflowY: 'auto',
  } as ViewProps,

  metricsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '16px',
    marginBottom: '24px',
  } as ViewProps,

  metricCard: {
    padding: '16px',
    backgroundColor: 'color.white',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  metricTitle: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '8px',
  } as ViewProps,

  metricValue: {
    fontSize: '20px',
    fontWeight: '700',
    color: 'color.gray.900',
  } as ViewProps,

  metricChange: {
    fontSize: '12px',
    marginTop: '4px',
  } as ViewProps,

  metricIncrease: {
    color: 'color.green.600',
  } as ViewProps,

  metricDecrease: {
    color: 'color.red.600',
  } as ViewProps,

  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
  } as ViewProps,

  loadingState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
    gap: '16px',
  } as ViewProps,

  errorState: {
    padding: '16px',
    backgroundColor: 'color.red.50',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    margin: '16px',
  } as ViewProps,

  searchInput: {
    width: '100%',
  } as ViewProps,

  exportButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.green.300',
    backgroundColor: 'color.white',
    color: 'color.green.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  refreshButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.blue.300',
    backgroundColor: 'color.white',
    color: 'color.blue.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.800',
    },
  } as ViewProps,
};

/**
 * Size variants for AgentEval
 */
export const AgentEvalSizes = {
  sm: {
    container: { height: '400px' },
    evaluationList: { minHeight: '200px' },
  },
  md: {
    container: { height: '600px' },
    evaluationList: { minHeight: '300px' },
  },
  lg: {
    container: { height: '800px' },
    evaluationList: { minHeight: '400px' },
  },
  xl: {
    container: { height: '1000px' },
    evaluationList: { minHeight: '500px' },
  },
};

/**
 * Theme variants for AgentEval
 */
export const AgentEvalThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    evaluationList: { backgroundColor: 'color.white' },
    createPanel: { backgroundColor: 'color.white' },
    resultsPanel: { backgroundColor: 'color.white' },
    metricsPanel: { backgroundColor: 'color.white' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    evaluationList: { backgroundColor: 'color.gray.900' },
    createPanel: { backgroundColor: 'color.gray.900' },
    resultsPanel: { backgroundColor: 'color.gray.900' },
    metricsPanel: { backgroundColor: 'color.gray.900' },
  },
};
</file>

<file path="src/components/adk/AgentEval/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text } from 'app-studio';
import { AgentEval } from '../AgentEval';
import { EvaluationRun } from '../AgentEval/AgentEval.props';

/**
 * Default AgentEval Example
 *
 * Demonstrates basic usage of the AgentEval component
 */
export const DefaultDemo = () => {
  const [selectedEvaluation, setSelectedEvaluation] =
    useState<EvaluationRun | null>(null);

  const handleEvaluationCreate = (evaluation: EvaluationRun) => {
    console.log('Evaluation created:', evaluation);
    setSelectedEvaluation(evaluation);
  };

  const handleEvaluationComplete = (evaluation: EvaluationRun) => {
    console.log('Evaluation completed:', evaluation);
  };

  const handleError = (error: Error) => {
    console.error('AgentEval error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentEval Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A comprehensive evaluation component for ADK agents. Handles evaluation
        creation, execution, monitoring, and results analysis.
      </Text>

      {/* Selected Evaluation Info */}
      {selectedEvaluation && (
        <View
          padding={16}
          backgroundColor="color.green.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.green.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.green.800">
            Active Evaluation
          </Text>
          <Text fontSize={12} color="color.green.600">
            Name: {selectedEvaluation.name}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Status: {selectedEvaluation.status}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Progress: {selectedEvaluation.progress}%
          </Text>
        </View>
      )}

      {/* AgentEval Component */}
      <View
        height="700px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentEval
          appName="demo-agent"
          userId="demo-user"
          apiBaseUrl="http://localhost:3000/adk"
          enableBatchEvaluation={true}
          enableMetricsComparison={true}
          enableResultExport={true}
          enableTemplates={true}
          showEvaluationHistory={true}
          showMetricsPanel={true}
          showTestCaseDetails={true}
          showProgressIndicators={true}
          maxConcurrentEvals={3}
          enableAutoRefresh={false}
          onEvaluationCreate={handleEvaluationCreate}
          onEvaluationComplete={handleEvaluationComplete}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * AgentEval with Mock Data Example
 *
 * Shows the component with sample evaluation data
 */
export const MockDataDemo = () => {
  const mockEvaluations: EvaluationRun[] = [
    {
      id: 'eval-1',
      name: 'Customer Support Evaluation',
      appName: 'support-agent',
      userId: 'user123',
      status: 'completed',
      progress: 100,
      startTime: Date.now() - 3600000,
      endTime: Date.now() - 3000000,
      duration: 600000,
      testCases: [
        {
          id: 'test-1',
          name: 'Basic Greeting',
          description: 'Test agent greeting response',
          input: { message: 'Hello' },
          expectedOutput: { response: 'Hello! How can I help you today?' },
          tags: ['greeting', 'basic'],
        },
        {
          id: 'test-2',
          name: 'Product Question',
          description: 'Test product information query',
          input: { message: 'Tell me about your pricing' },
          expectedOutput: { response: 'Our pricing starts at...' },
          tags: ['product', 'pricing'],
        },
      ],
      metrics: [
        {
          id: 'accuracy',
          name: 'Response Accuracy',
          description: 'Measures correctness of responses',
          type: 'accuracy',
          threshold: 0.8,
          weight: 1.0,
        },
        {
          id: 'latency',
          name: 'Response Time',
          description: 'Measures response latency',
          type: 'latency',
          threshold: 3000,
          weight: 0.5,
        },
      ],
      results: [
        {
          id: 'result-1',
          evaluationId: 'eval-1',
          testCaseId: 'test-1',
          status: 'pass',
          score: 0.95,
          actualOutput: { response: 'Hello! How can I help you today?' },
          metrics: { accuracy: 0.95, latency: 1200 },
          duration: 1200,
          timestamp: Date.now() - 3500000,
        },
        {
          id: 'result-2',
          evaluationId: 'eval-1',
          testCaseId: 'test-2',
          status: 'pass',
          score: 0.88,
          actualOutput: { response: 'Our pricing starts at $29/month...' },
          metrics: { accuracy: 0.88, latency: 2100 },
          duration: 2100,
          timestamp: Date.now() - 3400000,
        },
      ],
      summary: {
        totalTests: 2,
        passedTests: 2,
        failedTests: 0,
        errorTests: 0,
        skippedTests: 0,
        averageScore: 0.915,
        totalDuration: 3300,
        metricsAverages: { accuracy: 0.915, latency: 1650 },
        passRate: 1.0,
      },
    },
    {
      id: 'eval-2',
      name: 'Code Review Assistant',
      appName: 'code-agent',
      userId: 'user123',
      status: 'running',
      progress: 60,
      startTime: Date.now() - 1800000,
      testCases: [
        {
          id: 'test-3',
          name: 'Python Code Review',
          description: 'Review Python code for best practices',
          input: { code: 'def hello(): print("world")' },
          expectedOutput: {
            suggestions: ['Add type hints', 'Use more descriptive names'],
          },
          tags: ['python', 'review'],
        },
      ],
      metrics: [
        {
          id: 'quality',
          name: 'Review Quality',
          description: 'Quality of code review suggestions',
          type: 'quality',
          threshold: 0.7,
          weight: 1.0,
        },
      ],
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentEval with Mock Data
      </Text>

      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentEval
          appName="demo-agent"
          userId="demo-user"
          initialEvaluations={mockEvaluations}
          selectedEvaluationId="eval-1"
          enableMetricsComparison={true}
          showMetricsPanel={true}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Compact AgentEval Example
 *
 * Shows the component in compact mode
 */
export const CompactDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Compact AgentEval Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentEval
          appName="compact-agent"
          userId="user123"
          compactMode={true}
          showMetricsPanel={false}
          enableTemplates={false}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentEval Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentEval Example
      </Text>

      <View
        height="600px"
        border="1px solid"
        borderColor="color.purple.200"
        borderRadius="12px"
      >
        <AgentEval
          appName="custom-agent"
          userId="user123"
          enableBatchEvaluation={true}
          enableResultExport={true}
          maxConcurrentEvals={5}
          views={{
            container: {
              backgroundColor: 'color.purple.25',
              height: '100%',
            },
            header: {
              backgroundColor: 'color.purple.500',
              color: 'white',
            },
            evaluationList: {
              backgroundColor: 'color.white',
            },
            activeEvaluationItem: {
              backgroundColor: 'color.purple.100',
              borderColor: 'color.purple.500',
            },
            createPanel: {
              backgroundColor: 'color.purple.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Real-time AgentEval Example
 *
 * Demonstrates real-time updates and monitoring
 */
export const RealTimeDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Real-time AgentEval Example
      </Text>

      <Text fontSize={14} color="color.gray.600">
        This example shows real-time evaluation monitoring with auto-refresh
        enabled.
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentEval
          appName="realtime-agent"
          userId="user123"
          enableAutoRefresh={true}
          enableRealTimeUpdates={true}
          refreshInterval={10000}
          showProgressIndicators={true}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentSessionProps,
  AgentSession,
  SessionFilters,
  SessionSortOptions,
  SessionExportData,
  SessionImportOptions,
} from './AgentSession.props';
import { generateId } from '../../../../utils/generateId';

/**
 * Custom hook for managing AgentSession state and operations
 */
export const useAgentSession = (props: AgentSessionProps) => {
  const {
    appName,
    userId,
    apiBaseUrl = '',
    maxSessions = 100,
    refreshInterval = 30000,
    enableAutoRefresh = false,
    initialSessions = [],
    selectedSessionId,
    defaultFilters = {},
    defaultSort = { field: 'updatedAt', direction: 'desc' },
    onSessionSelect,
    onSessionCreate,
    onSessionUpdate,
    onSessionDelete,
    onSessionImport,
    onSessionExport,
    onError,
    onRefresh,
  } = props;

  // Core state
  const [sessions, setSessions] = useState<AgentSession[]>(initialSessions);
  const [selectedSession, setSelectedSession] = useState<AgentSession | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState(
    defaultFilters.searchQuery || ''
  );
  const [filters, setFilters] = useState<SessionFilters>(defaultFilters);
  const [sortOptions, setSortOptions] =
    useState<SessionSortOptions>(defaultSort);

  // Refs
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  /**
   * Fetch sessions from API
   */
  const fetchSessions = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(
        `${apiBaseUrl}/sessions?userId=${userId}&appName=${appName}&limit=${maxSessions}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch sessions: ${response.statusText}`);
      }

      const data: AgentSession[] = await response.json();
      setSessions(data);
      onRefresh?.();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [apiBaseUrl, userId, appName, maxSessions, onRefresh, onError]);

  /**
   * Create a new session
   */
  const createSession = useCallback(
    async (metadata?: {
      title?: string;
      description?: string;
      tags?: string[];
    }) => {
      try {
        setIsCreating(true);
        setError(null);

        const response = await fetch(`${apiBaseUrl}/sessions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId,
            appName,
            metadata,
          }),
        });

        if (!response.ok) {
          throw new Error(`Failed to create session: ${response.statusText}`);
        }

        const newSession: AgentSession = await response.json();
        setSessions((prev) => [newSession, ...prev]);
        setSelectedSession(newSession);
        onSessionCreate?.(newSession);
        onSessionSelect?.(newSession);

        return newSession;
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
        throw error;
      } finally {
        setIsCreating(false);
      }
    },
    [apiBaseUrl, userId, appName, onSessionCreate, onSessionSelect, onError]
  );

  /**
   * Select a session
   */
  const selectSession = useCallback(
    async (sessionId: string) => {
      try {
        setIsLoading(true);
        setError(null);

        // First try to find in current sessions
        let session = sessions.find((s) => s.id === sessionId);

        // If not found, fetch from API
        if (!session) {
          const response = await fetch(`${apiBaseUrl}/sessions/${sessionId}`);
          if (!response.ok) {
            throw new Error(`Failed to fetch session: ${response.statusText}`);
          }
          session = await response.json();
        }

        if (session) {
          setSelectedSession(session);
          onSessionSelect?.(session);
        }
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [sessions, apiBaseUrl, onSessionSelect, onError]
  );

  /**
   * Delete a session
   */
  const deleteSession = useCallback(
    async (sessionId: string) => {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch(`${apiBaseUrl}/sessions/${sessionId}`, {
          method: 'DELETE',
        });

        if (!response.ok) {
          throw new Error(`Failed to delete session: ${response.statusText}`);
        }

        setSessions((prev) => prev.filter((s) => s.id !== sessionId));

        if (selectedSession?.id === sessionId) {
          setSelectedSession(null);
        }

        onSessionDelete?.(sessionId);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [apiBaseUrl, selectedSession, onSessionDelete, onError]
  );

  /**
   * Export session to JSON
   */
  const exportSession = useCallback(
    (session: AgentSession) => {
      try {
        const exportData: SessionExportData = {
          session,
          exportedAt: Date.now(),
          exportedBy: userId,
          version: '1.0.0',
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `session-${session.id}-${
          new Date().toISOString().split('T')[0]
        }.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
        onSessionExport?.(session);
      } catch (err) {
        const error =
          err instanceof Error ? err : new Error('Failed to export session');
        setError(error.message);
        onError?.(error);
      }
    },
    [userId, onSessionExport, onError]
  );

  /**
   * Import session from JSON file
   */
  const importSession = useCallback(
    async (file: File, options: SessionImportOptions = {}) => {
      try {
        setIsLoading(true);
        setError(null);

        const text = await file.text();
        const importData: SessionExportData = JSON.parse(text);

        if (!importData.session) {
          throw new Error('Invalid session file format');
        }

        let session = importData.session;

        // Generate new ID if not preserving
        if (!options.preserveIds) {
          session = { ...session, id: generateId() };
        }

        // Update timestamps if requested
        if (options.updateTimestamps) {
          const now = Date.now();
          session = { ...session, createdAt: now, updatedAt: now };
        }

        // Check if session already exists
        const existingSession = sessions.find((s) => s.id === session.id);
        if (existingSession && !options.overwriteExisting) {
          throw new Error(
            'Session already exists. Enable overwrite to replace it.'
          );
        }

        // Import via API
        const response = await fetch(`${apiBaseUrl}/sessions/import`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session, options }),
        });

        if (!response.ok) {
          throw new Error(`Failed to import session: ${response.statusText}`);
        }

        const importedSession: AgentSession = await response.json();

        if (existingSession) {
          setSessions((prev) =>
            prev.map((s) => (s.id === importedSession.id ? importedSession : s))
          );
        } else {
          setSessions((prev) => [importedSession, ...prev]);
        }

        onSessionImport?.(importedSession);
      } catch (err) {
        const error =
          err instanceof Error ? err : new Error('Failed to import session');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
      }
    },
    [sessions, apiBaseUrl, onSessionImport, onError]
  );

  /**
   * Filter and sort sessions
   */
  const getFilteredAndSortedSessions = useCallback(() => {
    let filtered = [...sessions];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (session) =>
          session.metadata?.title?.toLowerCase().includes(query) ||
          session.metadata?.description?.toLowerCase().includes(query) ||
          session.metadata?.tags?.some((tag) =>
            tag.toLowerCase().includes(query)
          ) ||
          session.id.toLowerCase().includes(query)
      );
    }

    // Apply other filters
    if (filters.dateRange) {
      filtered = filtered.filter(
        (session) =>
          session.createdAt >= filters.dateRange!.start.getTime() &&
          session.createdAt <= filters.dateRange!.end.getTime()
      );
    }

    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter((session) =>
        session.metadata?.tags?.some((tag) => filters.tags!.includes(tag))
      );
    }

    if (filters.messageCountRange) {
      filtered = filtered.filter((session) => {
        const count = session.metadata?.messageCount || 0;
        return (
          count >= filters.messageCountRange!.min &&
          count <= filters.messageCountRange!.max
        );
      });
    }

    // Apply sorting
    filtered.sort((a, b) => {
      let aValue: any, bValue: any;

      switch (sortOptions.field) {
        case 'title':
          aValue = a.metadata?.title || '';
          bValue = b.metadata?.title || '';
          break;
        case 'messageCount':
          aValue = a.metadata?.messageCount || 0;
          bValue = b.metadata?.messageCount || 0;
          break;
        case 'createdAt':
          aValue = a.createdAt;
          bValue = b.createdAt;
          break;
        case 'updatedAt':
        default:
          aValue = a.updatedAt;
          bValue = b.updatedAt;
          break;
      }

      if (sortOptions.direction === 'asc') {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return filtered;
  }, [sessions, searchQuery, filters, sortOptions]);

  /**
   * Handle file import
   */
  const handleFileImport = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleFileSelect = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file) {
        importSession(file);
      }
      // Reset input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    },
    [importSession]
  );

  /**
   * Initialize sessions on mount
   */
  useEffect(() => {
    fetchSessions();
  }, [fetchSessions]);

  /**
   * Set up auto-refresh
   */
  useEffect(() => {
    if (enableAutoRefresh && refreshInterval > 0) {
      refreshIntervalRef.current = setInterval(fetchSessions, refreshInterval);
      return () => {
        if (refreshIntervalRef.current) {
          clearInterval(refreshIntervalRef.current);
        }
      };
    }
    return undefined;
  }, [enableAutoRefresh, refreshInterval, fetchSessions]);

  /**
   * Select initial session
   */
  useEffect(() => {
    if (selectedSessionId && sessions.length > 0 && !selectedSession) {
      selectSession(selectedSessionId);
    }
  }, [selectedSessionId, sessions, selectedSession, selectSession]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
    };
  }, []);

  return {
    // State
    sessions: getFilteredAndSortedSessions(),
    selectedSession,
    isLoading,
    isCreating,
    error,
    searchQuery,
    filters,
    sortOptions,

    // Actions
    fetchSessions,
    createSession,
    selectSession,
    deleteSession,
    exportSession,
    importSession,
    handleFileImport,
    setSearchQuery,
    setFilters,
    setSortOptions,
    setError,

    // Refs
    fileInputRef,

    // Event handlers
    handleFileSelect,
  };
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentSession component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentSessionStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  sessionList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    minHeight: '200px',
  } as ViewProps,

  sessionItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  activeSessionItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '2px solid',
    borderColor: 'color.blue.500',
    backgroundColor: 'color.blue.50',
    cursor: 'pointer',
  } as ViewProps,

  compactSessionItem: {
    padding: '8px 12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  sessionInfo: {
    flex: 1,
  } as ViewProps,

  sessionTitle: {
    fontSize: '14px',
    fontWeight: '600',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  sessionDescription: {
    fontSize: '12px',
    color: 'color.gray.600',
    marginBottom: '8px',
  } as ViewProps,

  sessionMeta: {
    fontSize: '11px',
    color: 'color.gray.500',
  } as ViewProps,

  sessionActions: {
    padding: '12px 16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.100',
    flexShrink: 0,
  } as ViewProps,

  actionButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.gray.300',
    backgroundColor: 'color.white',
    color: 'color.gray.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.700',
    },
  } as ViewProps,

  deleteButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.red.300',
    backgroundColor: 'color.white',
    color: 'color.red.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.red.400',
      backgroundColor: 'color.red.50',
      color: 'color.red.800',
    },
  } as ViewProps,

  exportButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.green.300',
    backgroundColor: 'color.white',
    color: 'color.green.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  importButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.purple.300',
    backgroundColor: 'color.white',
    color: 'color.purple.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.purple.400',
      backgroundColor: 'color.purple.50',
      color: 'color.purple.800',
    },
  } as ViewProps,

  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '200px',
    padding: '32px',
  } as ViewProps,

  loadingState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '200px',
    padding: '32px',
    gap: '16px',
  } as ViewProps,

  errorState: {
    padding: '16px',
    backgroundColor: 'color.red.50',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    margin: '16px',
  } as ViewProps,

  searchInput: {
    width: '100%',
  } as ViewProps,

  filterContainer: {
    padding: '12px',
    backgroundColor: 'color.gray.50',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  filterGroup: {
    marginBottom: '12px',
  } as ViewProps,

  filterLabel: {
    fontSize: '12px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '4px',
  } as ViewProps,

  tagContainer: {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '4px',
    marginTop: '4px',
  } as ViewProps,

  tag: {
    padding: '2px 6px',
    fontSize: '10px',
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
    borderRadius: '4px',
    border: '1px solid',
    borderColor: 'color.blue.200',
  } as ViewProps,

  statusIndicator: {
    width: '8px',
    height: '8px',
    borderRadius: '50%',
    flexShrink: 0,
  } as ViewProps,

  activeStatus: {
    backgroundColor: 'color.green.500',
  } as ViewProps,

  inactiveStatus: {
    backgroundColor: 'color.gray.400',
  } as ViewProps,

  errorStatus: {
    backgroundColor: 'color.red.500',
  } as ViewProps,
};

/**
 * Size variants for AgentSession
 */
export const AgentSessionSizes = {
  sm: {
    container: { height: '300px' },
    sessionList: { minHeight: '150px' },
  },
  md: {
    container: { height: '400px' },
    sessionList: { minHeight: '200px' },
  },
  lg: {
    container: { height: '500px' },
    sessionList: { minHeight: '300px' },
  },
  xl: {
    container: { height: '600px' },
    sessionList: { minHeight: '400px' },
  },
};

/**
 * Theme variants for AgentSession
 */
export const AgentSessionThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    sessionList: { backgroundColor: 'color.white' },
    sessionActions: { backgroundColor: 'color.gray.100' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    sessionList: { backgroundColor: 'color.gray.900' },
    sessionActions: { backgroundColor: 'color.gray.800' },
  },
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentTraceProps,
  TraceEvent,
  TraceSpan,
  TraceMetrics,
  TraceFilter,
  TraceExportOptions,
  VisualizationType,
} from './AgentTrace.props';

/**
 * Custom hook for managing AgentTrace state and operations
 */
export const useAgentTrace = (props: AgentTraceProps) => {
  const {
    sessionId,
    userId,
    appName,
    apiBaseUrl = '',
    maxEvents = 1000,
    refreshInterval = 5000,
    enableAutoRefresh = false,
    visualizationType = 'timeline',
    initialEvents = [],
    initialFilter = {},
    selectedEventId,
    onEventSelect,
    onSpanSelect,
    onFilterChange,
    onExport,
    onRefresh,
    onError,
  } = props;

  // Core state
  const [events, setEvents] = useState<TraceEvent[]>(initialEvents);
  const [spans, setSpans] = useState<TraceSpan[]>([]);
  const [selectedEvent, setSelectedEvent] = useState<TraceEvent | null>(null);
  const [selectedSpan, setSelectedSpan] = useState<TraceSpan | null>(null);
  const [metrics, setMetrics] = useState<TraceMetrics | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [filter, setFilter] = useState<TraceFilter>(initialFilter);
  const [searchQuery, setSearchQuery] = useState(
    initialFilter.searchQuery || ''
  );
  const [currentVisualization, setCurrentVisualization] =
    useState<VisualizationType>(visualizationType);

  // Refs
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  /**
   * Fetch trace events from API
   */
  const fetchTraceEvents = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const params = new URLSearchParams({
        sessionId,
        userId,
        appName,
        limit: maxEvents.toString(),
      });

      // Add filter parameters
      if (filter.eventTypes?.length) {
        params.append('eventTypes', filter.eventTypes.join(','));
      }
      if (filter.timeRange) {
        params.append('startTime', filter.timeRange.start.toISOString());
        params.append('endTime', filter.timeRange.end.toISOString());
      }
      if (filter.searchQuery) {
        params.append('search', filter.searchQuery);
      }

      const response = await fetch(`${apiBaseUrl}/trace/events?${params}`);

      if (!response.ok) {
        throw new Error(`Failed to fetch trace events: ${response.statusText}`);
      }

      const data: TraceEvent[] = await response.json();
      setEvents(data);

      // Calculate metrics
      const calculatedMetrics = calculateMetrics(data);
      setMetrics(calculatedMetrics);

      onRefresh?.();
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [
    sessionId,
    userId,
    appName,
    apiBaseUrl,
    maxEvents,
    filter,
    onRefresh,
    onError,
  ]);

  /**
   * Fetch trace spans from API
   */
  const fetchTraceSpans = useCallback(async () => {
    try {
      const response = await fetch(
        `${apiBaseUrl}/trace/spans?sessionId=${sessionId}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch trace spans: ${response.statusText}`);
      }

      const data: TraceSpan[] = await response.json();
      setSpans(data);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
    }
  }, [sessionId, apiBaseUrl, onError]);

  /**
   * Calculate metrics from events
   */
  const calculateMetrics = useCallback((events: TraceEvent[]): TraceMetrics => {
    const totalEvents = events.length;
    const durations = events.filter((e) => e.duration).map((e) => e.duration!);
    const totalDuration = durations.reduce((sum, d) => sum + d, 0);
    const averageResponseTime =
      durations.length > 0 ? totalDuration / durations.length : 0;

    const errorCount = events.filter(
      (e) => e.metadata?.level === 'error'
    ).length;
    const successCount = totalEvents - errorCount;
    const functionCallCount = events.filter(
      (e) => e.type === 'function_call'
    ).length;
    const llmRequestCount = events.filter(
      (e) => e.type === 'llm_request'
    ).length;

    const eventsByType = events.reduce((acc, event) => {
      acc[event.type] = (acc[event.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Calculate percentiles
    const sortedDurations = durations.sort((a, b) => a - b);
    const getPercentile = (p: number) => {
      const index = Math.ceil((p / 100) * sortedDurations.length) - 1;
      return sortedDurations[index] || 0;
    };

    return {
      totalEvents,
      totalDuration,
      averageResponseTime,
      errorCount,
      successCount,
      functionCallCount,
      llmRequestCount,
      eventsByType,
      performanceMetrics: {
        p50: getPercentile(50),
        p90: getPercentile(90),
        p95: getPercentile(95),
        p99: getPercentile(99),
      },
    };
  }, []);

  /**
   * Select an event
   */
  const selectEvent = useCallback(
    (eventId: string) => {
      const event = events.find((e) => e.id === eventId);
      if (event) {
        setSelectedEvent(event);
        onEventSelect?.(event);
      }
    },
    [events, onEventSelect]
  );

  /**
   * Select a span
   */
  const selectSpan = useCallback(
    (spanId: string) => {
      const span = spans.find((s) => s.id === spanId);
      if (span) {
        setSelectedSpan(span);
        onSpanSelect?.(span);
      }
    },
    [spans, onSpanSelect]
  );

  /**
   * Update filter
   */
  const updateFilter = useCallback(
    (newFilter: TraceFilter) => {
      setFilter(newFilter);
      onFilterChange?.(newFilter);
    },
    [onFilterChange]
  );

  /**
   * Export trace data
   */
  const exportTrace = useCallback(
    async (options: TraceExportOptions) => {
      try {
        let filteredEvents = events;

        // Apply export filters
        if (options.timeRange) {
          filteredEvents = filteredEvents.filter(
            (event) =>
              event.timestamp >= options.timeRange!.start.getTime() &&
              event.timestamp <= options.timeRange!.end.getTime()
          );
        }

        if (options.eventTypes?.length) {
          filteredEvents = filteredEvents.filter((event) =>
            options.eventTypes!.includes(event.type)
          );
        }

        let exportData: any;
        let filename: string;
        let mimeType: string;

        switch (options.format) {
          case 'json':
            exportData = {
              events: filteredEvents,
              ...(options.includeMetrics && { metrics }),
              ...(options.includeMetadata && {
                sessionId,
                userId,
                appName,
                exportedAt: new Date().toISOString(),
              }),
            };
            filename = `trace-${sessionId}-${
              new Date().toISOString().split('T')[0]
            }.json`;
            mimeType = 'application/json';
            break;

          case 'csv':
            const csvHeaders = [
              'id',
              'type',
              'timestamp',
              'duration',
              'level',
              'title',
            ];
            const csvRows = filteredEvents.map((event) => [
              event.id,
              event.type,
              new Date(event.timestamp).toISOString(),
              event.duration || '',
              event.metadata?.level || '',
              event.metadata?.title || '',
            ]);
            exportData = [csvHeaders, ...csvRows]
              .map((row) => row.join(','))
              .join('\n');
            filename = `trace-${sessionId}-${
              new Date().toISOString().split('T')[0]
            }.csv`;
            mimeType = 'text/csv';
            break;

          default:
            throw new Error(`Export format ${options.format} not supported`);
        }

        // Create and download file
        const blob = new Blob(
          [
            typeof exportData === 'string'
              ? exportData
              : JSON.stringify(exportData, null, 2),
          ],
          {
            type: mimeType,
          }
        );
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
        onExport?.(options.format);
      } catch (err) {
        const error =
          err instanceof Error ? err : new Error('Failed to export trace');
        setError(error.message);
        onError?.(error);
      }
    },
    [events, metrics, sessionId, userId, appName, onExport, onError]
  );

  /**
   * Filter and search events
   */
  const getFilteredEvents = useCallback(() => {
    let filtered = [...events];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (event) =>
          event.id.toLowerCase().includes(query) ||
          event.type.toLowerCase().includes(query) ||
          event.metadata?.title?.toLowerCase().includes(query) ||
          event.metadata?.description?.toLowerCase().includes(query) ||
          JSON.stringify(event.data).toLowerCase().includes(query)
      );
    }

    // Apply type filter
    if (filter.eventTypes?.length) {
      filtered = filtered.filter((event) =>
        filter.eventTypes!.includes(event.type)
      );
    }

    // Apply level filter
    if (filter.level?.length) {
      filtered = filtered.filter(
        (event) =>
          event.metadata?.level && filter.level!.includes(event.metadata.level)
      );
    }

    // Apply time range filter
    if (filter.timeRange) {
      filtered = filtered.filter(
        (event) =>
          event.timestamp >= filter.timeRange!.start.getTime() &&
          event.timestamp <= filter.timeRange!.end.getTime()
      );
    }

    // Apply duration filter
    if (filter.minDuration !== undefined) {
      filtered = filtered.filter(
        (event) => (event.duration || 0) >= filter.minDuration!
      );
    }
    if (filter.maxDuration !== undefined) {
      filtered = filtered.filter(
        (event) => (event.duration || 0) <= filter.maxDuration!
      );
    }

    // Apply tags filter
    if (filter.tags?.length) {
      filtered = filtered.filter((event) =>
        event.metadata?.tags?.some((tag) => filter.tags!.includes(tag))
      );
    }

    return filtered;
  }, [events, searchQuery, filter]);

  /**
   * Set up real-time updates via WebSocket
   */
  const setupRealTimeUpdates = useCallback(() => {
    if (!props.enableRealTimeUpdates) return;

    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${apiBaseUrl.replace(
      /^https?:\/\//,
      ''
    )}/trace/ws?sessionId=${sessionId}`;

    wsRef.current = new WebSocket(wsUrl);

    wsRef.current.onmessage = (event) => {
      try {
        const update = JSON.parse(event.data);

        switch (update.type) {
          case 'event_added':
            setEvents((prev) => [...prev, update.data]);
            break;
          case 'event_updated':
            setEvents((prev) =>
              prev.map((e) => (e.id === update.data.id ? update.data : e))
            );
            break;
          case 'metrics_updated':
            setMetrics(update.data);
            break;
        }
      } catch (err) {
        console.error('Error parsing WebSocket message:', err);
      }
    };

    wsRef.current.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }, [props.enableRealTimeUpdates, apiBaseUrl, sessionId]);

  /**
   * Initialize trace data on mount
   */
  useEffect(() => {
    fetchTraceEvents();
    fetchTraceSpans();
    setupRealTimeUpdates();
  }, [fetchTraceEvents, fetchTraceSpans, setupRealTimeUpdates]);

  /**
   * Set up auto-refresh
   */
  useEffect(() => {
    if (enableAutoRefresh && refreshInterval > 0) {
      refreshIntervalRef.current = setInterval(() => {
        fetchTraceEvents();
        fetchTraceSpans();
      }, refreshInterval);

      return () => {
        if (refreshIntervalRef.current) {
          clearInterval(refreshIntervalRef.current);
        }
      };
    }
    return undefined;
  }, [enableAutoRefresh, refreshInterval, fetchTraceEvents, fetchTraceSpans]);

  /**
   * Select initial event
   */
  useEffect(() => {
    if (selectedEventId && events.length > 0 && !selectedEvent) {
      selectEvent(selectedEventId);
    }
  }, [selectedEventId, events, selectedEvent, selectEvent]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  return {
    // State
    events: getFilteredEvents(),
    spans,
    selectedEvent,
    selectedSpan,
    metrics,
    isLoading,
    error,
    filter,
    searchQuery,
    currentVisualization,

    // Actions
    fetchTraceEvents,
    fetchTraceSpans,
    selectEvent,
    selectSpan,
    updateFilter,
    exportTrace,
    setSearchQuery,
    setCurrentVisualization,
    setError,

    // Computed
    filteredEvents: getFilteredEvents(),
  };
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentTrace component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentTraceStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  timeline: {
    height: '200px',
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.white',
    overflowX: 'auto',
    overflowY: 'hidden',
  } as ViewProps,

  eventList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    padding: '16px',
  } as ViewProps,

  eventItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    backgroundColor: 'color.white',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    marginBottom: '8px',
    ':hover': {
      borderColor: 'color.blue.300',
      backgroundColor: 'color.blue.25',
    },
  } as ViewProps,

  selectedEventItem: {
    padding: '12px',
    borderRadius: '8px',
    border: '2px solid',
    borderColor: 'color.blue.500',
    backgroundColor: 'color.blue.50',
    cursor: 'pointer',
    marginBottom: '8px',
  } as ViewProps,

  eventHeader: {
    marginBottom: '8px',
  } as ViewProps,

  eventType: {
    padding: '2px 8px',
    fontSize: '11px',
    fontWeight: '600',
    borderRadius: '12px',
    textTransform: 'uppercase',
  } as ViewProps,

  eventTypeRequest: {
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
  } as ViewProps,

  eventTypeResponse: {
    backgroundColor: 'color.green.100',
    color: 'color.green.800',
  } as ViewProps,

  eventTypeError: {
    backgroundColor: 'color.red.100',
    color: 'color.red.800',
  } as ViewProps,

  eventTypeFunction: {
    backgroundColor: 'color.purple.100',
    color: 'color.purple.800',
  } as ViewProps,

  eventTypeSystem: {
    backgroundColor: 'color.gray.100',
    color: 'color.gray.800',
  } as ViewProps,

  eventContent: {
    fontSize: '14px',
    lineHeight: 1.5,
    color: 'color.gray.700',
  } as ViewProps,

  eventMetadata: {
    marginTop: '8px',
    padding: '8px',
    backgroundColor: 'color.gray.50',
    borderRadius: '6px',
    fontSize: '12px',
    color: 'color.gray.600',
  } as ViewProps,

  eventDuration: {
    fontSize: '11px',
    color: 'color.gray.500',
    fontFamily: 'Monaco, Consolas, monospace',
  } as ViewProps,

  eventTimestamp: {
    fontSize: '11px',
    color: 'color.gray.500',
    fontFamily: 'Monaco, Consolas, monospace',
  } as ViewProps,

  metrics: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.100',
    flexShrink: 0,
  } as ViewProps,

  metricsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
    gap: '16px',
  } as ViewProps,

  metricCard: {
    padding: '12px',
    backgroundColor: 'color.white',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    textAlign: 'center',
  } as ViewProps,

  metricValue: {
    fontSize: '20px',
    fontWeight: '700',
    color: 'color.gray.900',
    marginBottom: '4px',
  } as ViewProps,

  metricLabel: {
    fontSize: '12px',
    color: 'color.gray.600',
    textTransform: 'uppercase',
    fontWeight: '600',
  } as ViewProps,

  visualization: {
    flex: 1,
    padding: '16px',
    backgroundColor: 'color.white',
    overflow: 'auto',
  } as ViewProps,

  timelineContainer: {
    position: 'relative',
    height: '100%',
    minWidth: '800px',
  } as ViewProps,

  timelineAxis: {
    position: 'absolute',
    bottom: '0',
    left: '0',
    right: '0',
    height: '30px',
    borderTop: '1px solid',
    borderTopColor: 'color.gray.300',
  } as ViewProps,

  timelineEvent: {
    position: 'absolute',
    height: '20px',
    borderRadius: '4px',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '10px',
    fontWeight: '600',
    color: 'white',
    transition: 'all 0.2s ease',
    ':hover': {
      transform: 'scale(1.05)',
      zIndex: 10,
    },
  } as ViewProps,

  timelineSpan: {
    position: 'absolute',
    height: '30px',
    borderRadius: '6px',
    border: '2px solid',
    backgroundColor: 'transparent',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    paddingLeft: '8px',
    fontSize: '11px',
    fontWeight: '600',
    transition: 'all 0.2s ease',
    ':hover': {
      backgroundColor: 'rgba(59, 130, 246, 0.1)',
    },
  } as ViewProps,

  filters: {
    padding: '12px',
    backgroundColor: 'color.gray.50',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  filterGroup: {
    marginBottom: '12px',
  } as ViewProps,

  filterLabel: {
    fontSize: '12px',
    fontWeight: '600',
    color: 'color.gray.700',
    marginBottom: '4px',
  } as ViewProps,

  tagContainer: {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '4px',
    marginTop: '4px',
  } as ViewProps,

  tag: {
    padding: '2px 6px',
    fontSize: '10px',
    backgroundColor: 'color.blue.100',
    color: 'color.blue.800',
    borderRadius: '4px',
    border: '1px solid',
    borderColor: 'color.blue.200',
  } as ViewProps,

  emptyState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
  } as ViewProps,

  loadingState: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    height: '300px',
    padding: '32px',
    gap: '16px',
  } as ViewProps,

  errorState: {
    padding: '16px',
    backgroundColor: 'color.red.50',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    margin: '16px',
  } as ViewProps,

  searchInput: {
    width: '100%',
  } as ViewProps,

  exportButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.green.300',
    backgroundColor: 'color.white',
    color: 'color.green.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.green.400',
      backgroundColor: 'color.green.50',
      color: 'color.green.800',
    },
  } as ViewProps,

  refreshButton: {
    padding: '6px 12px',
    fontSize: '12px',
    borderRadius: '6px',
    border: '1px solid',
    borderColor: 'color.blue.300',
    backgroundColor: 'color.white',
    color: 'color.blue.700',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    ':hover': {
      borderColor: 'color.blue.400',
      backgroundColor: 'color.blue.50',
      color: 'color.blue.800',
    },
  } as ViewProps,
};

/**
 * Event type color mapping
 */
export const EventTypeColors = {
  llm_request: 'color.blue.500',
  llm_response: 'color.green.500',
  function_call: 'color.purple.500',
  function_response: 'color.purple.300',
  user_input: 'color.orange.500',
  agent_output: 'color.teal.500',
  error: 'color.red.500',
  system: 'color.gray.500',
};

/**
 * Size variants for AgentTrace
 */
export const AgentTraceSizes = {
  sm: {
    container: { height: '400px' },
    timeline: { height: '120px' },
    eventList: { minHeight: '200px' },
  },
  md: {
    container: { height: '600px' },
    timeline: { height: '200px' },
    eventList: { minHeight: '300px' },
  },
  lg: {
    container: { height: '800px' },
    timeline: { height: '250px' },
    eventList: { minHeight: '400px' },
  },
  xl: {
    container: { height: '1000px' },
    timeline: { height: '300px' },
    eventList: { minHeight: '500px' },
  },
};

/**
 * Theme variants for AgentTrace
 */
export const AgentTraceThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    timeline: { backgroundColor: 'color.white' },
    eventList: { backgroundColor: 'color.white' },
    metrics: { backgroundColor: 'color.gray.100' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    timeline: { backgroundColor: 'color.gray.900' },
    eventList: { backgroundColor: 'color.gray.900' },
    metrics: { backgroundColor: 'color.gray.800' },
  },
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceEventList.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { TraceEvent } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';

export interface TraceEventListProps {
  events: TraceEvent[];
  selectedEvent?: TraceEvent | null;
  onEventSelect: (eventId: string) => void;
  showDetails?: boolean;
  compactMode?: boolean;
  views?: {
    container?: any;
    eventItem?: any;
    selectedEventItem?: any;
  };
}

/**
 * TraceEventList Component
 *
 * Renders a list of trace events with selection and detail display
 */
export const TraceEventList: React.FC<TraceEventListProps> = ({
  events,
  selectedEvent,
  onEventSelect,
  showDetails = true,
  compactMode = false,
  views = {},
}) => {
  /**
   * Get event type badge style
   */
  const getEventTypeStyle = (type: string) => {
    const baseStyle = DefaultAgentTraceStyles.eventType;

    switch (type) {
      case 'llm_request':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeRequest };
      case 'llm_response':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeResponse };
      case 'function_call':
      case 'function_response':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeFunction };
      case 'error':
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeError };
      default:
        return { ...baseStyle, ...DefaultAgentTraceStyles.eventTypeSystem };
    }
  };

  /**
   * Format timestamp
   */
  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3,
    } as Intl.DateTimeFormatOptions);
  };

  /**
   * Format duration
   */
  const formatDuration = (duration?: number) => {
    if (!duration) return '';
    if (duration < 1000) return `${duration.toFixed(1)}ms`;
    return `${(duration / 1000).toFixed(2)}s`;
  };

  /**
   * Get event icon
   */
  const getEventIcon = (type: string) => {
    switch (type) {
      case 'llm_request':
        return '🤖';
      case 'llm_response':
        return '💬';
      case 'function_call':
        return '🔧';
      case 'function_response':
        return '✅';
      case 'user_input':
        return '👤';
      case 'agent_output':
        return '🎯';
      case 'error':
        return '❌';
      case 'system':
        return '⚙️';
      default:
        return '📝';
    }
  };

  /**
   * Render event data preview
   */
  const renderEventDataPreview = (event: TraceEvent) => {
    if (!showDetails) return null;

    let preview = '';
    try {
      if (typeof event.data === 'string') {
        preview =
          event.data.length > 100
            ? event.data.substring(0, 100) + '...'
            : event.data;
      } else if (event.data) {
        const dataStr = JSON.stringify(event.data);
        preview =
          dataStr.length > 100 ? dataStr.substring(0, 100) + '...' : dataStr;
      }
    } catch (err) {
      preview = '[Complex data structure]';
    }

    return preview;
  };

  return (
    <View {...DefaultAgentTraceStyles.eventList} {...views.container}>
      <Vertical gap={compactMode ? 4 : 8}>
        {events.map((event) => {
          const isSelected = selectedEvent?.id === event.id;
          const containerStyle = isSelected
            ? {
                ...DefaultAgentTraceStyles.selectedEventItem,
                ...views.selectedEventItem,
              }
            : { ...DefaultAgentTraceStyles.eventItem, ...views.eventItem };

          return (
            <View
              key={event.id}
              {...containerStyle}
              onClick={() => onEventSelect(event.id)}
            >
              <Vertical gap={compactMode ? 4 : 8}>
                {/* Event Header */}
                <Horizontal justifyContent="space-between" alignItems="center">
                  <Horizontal gap={8} alignItems="center">
                    <Text fontSize="16px">{getEventIcon(event.type)}</Text>
                    <View {...getEventTypeStyle(event.type)}>
                      <Text>{event.type.replace('_', ' ')}</Text>
                    </View>
                    {event.metadata?.title && (
                      <Text
                        fontSize="sm"
                        fontWeight="600"
                        color="color.gray.900"
                      >
                        {event.metadata.title}
                      </Text>
                    )}
                  </Horizontal>

                  <Horizontal gap={8} alignItems="center">
                    {event.duration && (
                      <Text {...DefaultAgentTraceStyles.eventDuration}>
                        {formatDuration(event.duration)}
                      </Text>
                    )}
                    <Text {...DefaultAgentTraceStyles.eventTimestamp}>
                      {formatTimestamp(event.timestamp)}
                    </Text>
                  </Horizontal>
                </Horizontal>

                {/* Event Description */}
                {event.metadata?.description && !compactMode && (
                  <Text fontSize="sm" color="color.gray.600">
                    {event.metadata.description}
                  </Text>
                )}

                {/* Event Data Preview */}
                {showDetails && !compactMode && (
                  <View {...DefaultAgentTraceStyles.eventContent}>
                    <Text
                      fontSize="sm"
                      fontFamily="Monaco, Consolas, monospace"
                    >
                      {renderEventDataPreview(event)}
                    </Text>
                  </View>
                )}

                {/* Event Tags */}
                {event.metadata?.tags &&
                  event.metadata.tags.length > 0 &&
                  !compactMode && (
                    <Horizontal gap={4} flexWrap="wrap">
                      {event.metadata.tags.map((tag, index) => (
                        <View key={index} {...DefaultAgentTraceStyles.tag}>
                          <Text fontSize="10px">{tag}</Text>
                        </View>
                      ))}
                    </Horizontal>
                  )}

                {/* Event Level Indicator */}
                {event.metadata?.level && event.metadata.level !== 'info' && (
                  <Horizontal alignItems="center" gap={4}>
                    <View
                      width="8px"
                      height="8px"
                      borderRadius="50%"
                      backgroundColor={
                        event.metadata.level === 'error'
                          ? 'color.red.500'
                          : event.metadata.level === 'warning'
                          ? 'color.yellow.500'
                          : 'color.blue.500'
                      }
                    />
                    <Text
                      fontSize="xs"
                      color="color.gray.600"
                      textTransform="uppercase"
                    >
                      {event.metadata.level}
                    </Text>
                  </Horizontal>
                )}

                {/* Expanded Details for Selected Event */}
                {isSelected && showDetails && (
                  <View {...DefaultAgentTraceStyles.eventMetadata}>
                    <Vertical gap={8}>
                      <Text
                        fontSize="xs"
                        fontWeight="600"
                        color="color.gray.700"
                      >
                        Event Details
                      </Text>

                      <Horizontal gap={16}>
                        <Text fontSize="xs" color="color.gray.600">
                          ID: {event.id}
                        </Text>
                        {event.parentId && (
                          <Text fontSize="xs" color="color.gray.600">
                            Parent: {event.parentId.slice(0, 8)}...
                          </Text>
                        )}
                      </Horizontal>

                      {event.attributes &&
                        Object.keys(event.attributes).length > 0 && (
                          <View>
                            <Text
                              fontSize="xs"
                              fontWeight="600"
                              color="color.gray.700"
                              marginBottom={4}
                            >
                              Attributes
                            </Text>
                            <View
                              padding={8}
                              backgroundColor="color.gray.100"
                              borderRadius="4px"
                              maxHeight="100px"
                              overflowY="auto"
                            >
                              <Text
                                fontSize="xs"
                                fontFamily="Monaco, Consolas, monospace"
                              >
                                {JSON.stringify(event.attributes, null, 2)}
                              </Text>
                            </View>
                          </View>
                        )}

                      <View>
                        <Text
                          fontSize="xs"
                          fontWeight="600"
                          color="color.gray.700"
                          marginBottom={4}
                        >
                          Data
                        </Text>
                        <View
                          padding={8}
                          backgroundColor="color.gray.100"
                          borderRadius="4px"
                          maxHeight="150px"
                          overflowY="auto"
                        >
                          <Text
                            fontSize="xs"
                            fontFamily="Monaco, Consolas, monospace"
                          >
                            {typeof event.data === 'string'
                              ? event.data
                              : JSON.stringify(event.data, null, 2)}
                          </Text>
                        </View>
                      </View>
                    </Vertical>
                  </View>
                )}
              </Vertical>
            </View>
          );
        })}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceTimeline.tsx">
import React from 'react';
import { View, Horizontal, Text } from 'app-studio';
import { TraceEvent, TraceSpan } from './AgentTrace.props';
import { DefaultAgentTraceStyles, EventTypeColors } from './AgentTrace.style';

export interface TraceTimelineProps {
  events: TraceEvent[];
  spans: TraceSpan[];
  selectedEvent?: TraceEvent | null;
  selectedSpan?: TraceSpan | null;
  onEventSelect: (eventId: string) => void;
  onSpanSelect: (spanId: string) => void;
  views?: {
    container?: any;
  };
}

/**
 * TraceTimeline Component
 *
 * Renders a timeline visualization of trace events and spans
 */
export const TraceTimeline: React.FC<TraceTimelineProps> = ({
  events,
  spans,
  selectedEvent,
  selectedSpan,
  onEventSelect,
  onSpanSelect,
  views = {},
}) => {
  // Calculate timeline bounds
  const allTimestamps = events.map((e) => e.timestamp);
  const minTime = Math.min(...allTimestamps);
  const maxTime = Math.max(...allTimestamps);
  const timeRange = maxTime - minTime || 1000; // Fallback to 1 second

  /**
   * Convert timestamp to timeline position (0-100%)
   */
  const getTimelinePosition = (timestamp: number) => {
    return ((timestamp - minTime) / timeRange) * 100;
  };

  /**
   * Get event color based on type
   */
  const getEventColor = (type: string) => {
    return (
      EventTypeColors[type as keyof typeof EventTypeColors] || 'color.gray.500'
    );
  };

  /**
   * Format time for display
   */
  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      fractionalSecondDigits: 3,
    } as Intl.DateTimeFormatOptions);
  };

  /**
   * Generate time axis labels
   */
  const generateTimeLabels = () => {
    const labelCount = 5;
    const labels: Array<{
      timestamp: number;
      position: number;
      label: string;
    }> = [];

    for (let i = 0; i <= labelCount; i++) {
      const timestamp = minTime + (timeRange * i) / labelCount;
      const position = (i / labelCount) * 100;
      labels.push({
        timestamp,
        position,
        label: formatTime(timestamp),
      });
    }

    return labels;
  };

  const timeLabels = generateTimeLabels();

  return (
    <View {...DefaultAgentTraceStyles.timeline} {...views.container}>
      <View {...DefaultAgentTraceStyles.timelineContainer}>
        {/* Spans */}
        {spans.map((span, index) => {
          const startPos = getTimelinePosition(span.startTime);
          const endPos = span.endTime ? getTimelinePosition(span.endTime) : 100;
          const width = Math.max(endPos - startPos, 2); // Minimum 2% width
          const top = 20 + index * 35; // Stack spans vertically

          return (
            <View
              key={span.id}
              {...DefaultAgentTraceStyles.timelineSpan}
              style={{
                left: `${startPos}%`,
                width: `${width}%`,
                top: `${top}px`,
                borderColor:
                  span.status === 'error' ? 'color.red.500' : 'color.blue.500',
                color:
                  span.status === 'error' ? 'color.red.700' : 'color.blue.700',
              }}
              onClick={() => onSpanSelect(span.id)}
              title={`${span.name} (${
                span.duration ? `${span.duration}ms` : 'running'
              })`}
            >
              <Text fontSize="10px" fontWeight="600">
                {span.name}
              </Text>
            </View>
          );
        })}

        {/* Events */}
        {events.map((event, index) => {
          const position = getTimelinePosition(event.timestamp);
          const isSelected = selectedEvent?.id === event.id;
          const color = getEventColor(event.type);

          // Calculate vertical position to avoid overlap
          const eventsAtSameTime = events.filter(
            (e) => Math.abs(e.timestamp - event.timestamp) < timeRange * 0.01
          );
          const eventIndex = eventsAtSameTime.findIndex(
            (e) => e.id === event.id
          );
          const top = 100 + spans.length * 35 + eventIndex * 25;

          return (
            <View
              key={event.id}
              {...DefaultAgentTraceStyles.timelineEvent}
              style={{
                left: `${Math.max(0, position - 1)}%`, // Center the event
                width: '20px',
                top: `${top}px`,
                backgroundColor: color,
                border: isSelected ? '2px solid white' : 'none',
                boxShadow: isSelected ? '0 0 0 2px #3b82f6' : 'none',
                zIndex: isSelected ? 20 : 10,
              }}
              onClick={() => onEventSelect(event.id)}
              title={`${event.type} - ${formatTime(event.timestamp)}`}
            >
              <Text fontSize="8px" color="white">
                {event.type.charAt(0).toUpperCase()}
              </Text>
            </View>
          );
        })}

        {/* Time Axis */}
        <View {...DefaultAgentTraceStyles.timelineAxis}>
          {timeLabels.map((label, index) => (
            <View
              key={index}
              position="absolute"
              left={`${label.position}%`}
              top="0"
              transform="translateX(-50%)"
            >
              <View
                width="1px"
                height="10px"
                backgroundColor="color.gray.400"
                marginBottom="4px"
              />
              <Text fontSize="9px" color="color.gray.600" textAlign="center">
                {label.label}
              </Text>
            </View>
          ))}
        </View>

        {/* Legend */}
        <View
          position="absolute"
          top="10px"
          right="10px"
          padding="8px"
          backgroundColor="color.white"
          borderRadius="6px"
          border="1px solid"
          borderColor="color.gray.200"
          boxShadow="0 2px 4px rgba(0,0,0,0.1)"
        >
          <Text
            fontSize="10px"
            fontWeight="600"
            color="color.gray.700"
            marginBottom="4px"
          >
            Legend
          </Text>
          <View>
            {Object.entries(EventTypeColors).map(([type, color]) => {
              const eventCount = events.filter((e) => e.type === type).length;
              if (eventCount === 0) return null;

              return (
                <Horizontal
                  key={type}
                  gap={4}
                  alignItems="center"
                  marginBottom="2px"
                >
                  <View
                    width="8px"
                    height="8px"
                    borderRadius="2px"
                    backgroundColor={color}
                  />
                  <Text fontSize="9px" color="color.gray.600">
                    {type.replace('_', ' ')} ({eventCount})
                  </Text>
                </Horizontal>
              );
            })}
          </View>
        </View>
      </View>
    </View>
  );
};
</file>

<file path="src/components/ChatInput/examples/EnhancedEditableInput.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text, Horizontal } from 'app-studio';
import { EditableInput } from '../EditableInput';

export const EnhancedEditableInputDemo = () => {
  const [inputValue, setInputValue] = useState('');
  const [submittedMessage, setSubmittedMessage] = useState('');
  const [selectedMentions, setSelectedMentions] = useState<any[]>([]);

  const suggestions = [
    {
      id: '1',
      text: 'Tell me a joke',
      description: 'Get a funny joke to brighten your day',
    },
    {
      id: '2',
      text: 'What is the weather today?',
      description: 'Check current weather conditions',
    },
    {
      id: '3',
      text: 'How do I create a React component?',
      description: 'Learn React component development',
    },
    {
      id: '4',
      text: 'Write a poem about coding',
      description: 'Generate creative content about programming',
    },
  ];

  const mentionData = [
    {
      id: '1',
      name: 'john_doe',
      description: 'Frontend Developer',
    },
    {
      id: '2',
      name: 'jane_smith',
      description: 'UI/UX Designer',
    },
    {
      id: '3',
      name: 'mike_wilson',
      description: 'Backend Developer',
    },
    {
      id: '4',
      name: 'sarah_jones',
      description: 'Product Manager',
    },
    {
      id: '5',
      name: 'alex_brown',
      description: 'DevOps Engineer',
    },
    {
      id: '6',
      name: 'lisa_davis',
      description: 'QA Engineer',
    },
  ];

  const handleSubmit = () => {
    if (inputValue.trim()) {
      setSubmittedMessage(inputValue);
      setInputValue('');
    }
  };

  const handleSuggestionSelect = (suggestion: any) => {
    setInputValue(suggestion.text);
  };

  return (
    <Vertical gap={20} padding="20px" maxWidth="600px">
      <Text fontSize="18px" fontWeight="bold">
        Enhanced Editable Input Demo
      </Text>

      <Text fontSize="14px" color="color.gray.600">
        Features: • Visible placeholder text • Auto-growing height • Line breaks
        with Enter key • Auto-completion suggestions • Submit only via button
        (not Enter key)
      </Text>

      <View
        border="1px solid"
        borderColor="color.gray.300"
        borderRadius="8px"
        padding="16px"
        backgroundColor="color.white"
      >
        <Vertical gap={12}>
          <EditableInput
            value={inputValue}
            onChange={setInputValue}
            placeholder="Type your message here... Press Enter for new lines, use suggestions below"
            suggestions={suggestions}
            showSuggestions={!inputValue && suggestions.length > 0}
            onSuggestionSelect={handleSuggestionSelect}
            maxHeight="150px"
            minHeight="60px"
          />

          <View display="flex" justifyContent="flex-end">
            <View
              as="button"
              onClick={handleSubmit}
              padding="8px 16px"
              backgroundColor={
                inputValue.trim() ? 'color.blue.500' : 'color.gray.300'
              }
              color="color.white"
              border="none"
              borderRadius="6px"
              cursor={inputValue.trim() ? 'pointer' : 'not-allowed'}
              disabled={!inputValue.trim()}
              _hover={{
                backgroundColor: inputValue.trim()
                  ? 'color.blue.600'
                  : 'color.gray.300',
              }}
            >
              Send Message
            </View>
          </View>
        </Vertical>
      </View>

      {submittedMessage && (
        <View
          padding="12px"
          backgroundColor="color.green.50"
          border="1px solid"
          borderColor="color.green.200"
          borderRadius="6px"
        >
          <Text fontSize="14px" fontWeight="medium" color="color.green.800">
            Submitted Message:
          </Text>
          <Text
            fontSize="14px"
            color="color.green.700"
            marginTop="4px"
            whiteSpace="pre-wrap"
          >
            {submittedMessage}
          </Text>
        </View>
      )}
    </Vertical>
  );
};
</file>

<file path="src/components/ChatInput/examples/index.ts">
export * from './EnhancedEditableInput';
export * from './MentionEditableInput';
export * from './AudioWaveformChatInput';
</file>

<file path="src/components/ChatInput/examples/MentionEditableInput.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text, Horizontal } from 'app-studio';
import { EditableInput } from '../EditableInput';

export const MentionEditableInputDemo = () => {
  const [inputValue, setInputValue] = useState('');
  const [submittedMessage, setSubmittedMessage] = useState('');
  const [selectedMentions, setSelectedMentions] = useState<any[]>([]);

  const suggestions = [
    {
      id: '1',
      text: 'Tell me a joke',
      description: 'Get a funny joke to brighten your day',
    },
    {
      id: '2',
      text: 'What is the weather today?',
      description: 'Check current weather conditions',
    },
    {
      id: '3',
      text: 'How do I create a React component?',
      description: 'Learn React component development',
    },
    {
      id: '4',
      text: 'Write a poem about coding',
      description: 'Generate creative content about programming',
    },
  ];

  const mentionData = [
    {
      id: '1',
      name: 'john_doe',
      description: 'Frontend Developer',
    },
    {
      id: '2',
      name: 'jane_smith',
      description: 'UI/UX Designer',
    },
    {
      id: '3',
      name: 'mike_wilson',
      description: 'Backend Developer',
    },
    {
      id: '4',
      name: 'sarah_jones',
      description: 'Product Manager',
    },
    {
      id: '5',
      name: 'alex_brown',
      description: 'DevOps Engineer',
    },
    {
      id: '6',
      name: 'lisa_davis',
      description: 'QA Engineer',
    },
  ];

  const handleSubmit = () => {
    if (inputValue.trim()) {
      setSubmittedMessage(inputValue);
      setInputValue('');
      setSelectedMentions([]);
    }
  };

  const handleSuggestionSelect = (suggestion: any) => {
    setInputValue(suggestion.text);
  };

  const handleMentionSelect = (mention: any) => {
    setSelectedMentions((prev) => [...prev, mention]);
  };

  return (
    <Vertical gap={20} padding="20px" maxWidth="600px">
      <Text fontSize="18px" fontWeight="bold">
        Enhanced Editable Input with @ Mentions Demo
      </Text>

      <Text fontSize="14px" color="color.gray.600">
        Features: • Visible placeholder text • Auto-growing height • Line breaks
        with Enter key • @ mention auto-completion • Auto-completion suggestions
        • Submit only via button (not Enter key)
      </Text>

      <View
        padding="12px"
        backgroundColor="color.blue.50"
        border="1px solid"
        borderColor="color.blue.200"
        borderRadius="6px"
      >
        <Text fontSize="14px" fontWeight="medium" color="color.blue.800">
          Try typing "@" to see mention suggestions!
        </Text>
        <Text fontSize="12px" color="color.blue.700" marginTop="4px">
          Available users: @john_doe, @jane_smith, @mike_wilson, @sarah_jones,
          @alex_brown, @lisa_davis
        </Text>
      </View>

      <View
        border="1px solid"
        borderColor="color.gray.300"
        borderRadius="8px"
        padding="16px"
        backgroundColor="color.white"
        overflow="visible"
        position="relative"
      >
        <Vertical gap={12}>
          <EditableInput
            value={inputValue}
            onChange={setInputValue}
            placeholder="Type your message here... Use @ to mention someone, Enter for new lines"
            suggestions={suggestions}
            showSuggestions={!inputValue && suggestions.length > 0}
            onSuggestionSelect={handleSuggestionSelect}
            mentionData={mentionData}
            mentionTrigger="@"
            onMentionSelect={handleMentionSelect}
            maxHeight="150px"
            minHeight="60px"
            views={{
              container: {
                border: '1px solid',
                borderColor: 'color.gray.300',
                borderRadius: '8px',
                backgroundColor: 'color.white',
                padding: '8px',
              },
            }}
          />

          <Horizontal justifyContent="space-between" alignItems="center">
            {selectedMentions.length > 0 && (
              <View>
                <Text fontSize="12px" color="color.gray.600" marginBottom="4px">
                  Mentioned:
                </Text>
                <Horizontal gap={4} flexWrap="wrap">
                  {selectedMentions.map((mention, index) => (
                    <View
                      key={`${mention.id}-${index}`}
                      padding="2px 6px"
                      backgroundColor="color.blue.100"
                      borderRadius="4px"
                      border="1px solid"
                      borderColor="color.blue.200"
                    >
                      <Text fontSize="12px" color="color.blue.800">
                        @{mention.name}
                      </Text>
                    </View>
                  ))}
                </Horizontal>
              </View>
            )}

            <View
              as="button"
              onClick={handleSubmit}
              padding="8px 16px"
              backgroundColor={
                inputValue.trim() ? 'color.blue.500' : 'color.gray.300'
              }
              color="color.white"
              border="none"
              borderRadius="6px"
              cursor={inputValue.trim() ? 'pointer' : 'not-allowed'}
              disabled={!inputValue.trim()}
              _hover={{
                backgroundColor: inputValue.trim()
                  ? 'color.blue.600'
                  : 'color.gray.300',
              }}
            >
              Send Message
            </View>
          </Horizontal>
        </Vertical>
      </View>

      {submittedMessage && (
        <View
          padding="12px"
          backgroundColor="color.green.50"
          border="1px solid"
          borderColor="color.green.200"
          borderRadius="6px"
        >
          <Text fontSize="14px" fontWeight="medium" color="color.green.800">
            Submitted Message:
          </Text>
          <Text
            fontSize="14px"
            color="color.green.700"
            marginTop="4px"
            whiteSpace="pre-wrap"
          >
            {submittedMessage}
          </Text>
        </View>
      )}
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentTypingIndicator.tsx">
import React from 'react';
import { View, Horizontal } from 'app-studio';
import {
  DefaultAgentChatStyles,
  TypingAnimationStyles,
} from './AgentChat.style';
import { Avatar } from '../../../Avatar/Avatar';

/**
 * AgentTypingIndicator Component
 *
 * Shows an animated typing indicator when the agent is processing a response
 */
export const AgentTypingIndicator: React.FC = () => {
  return (
    <Horizontal gap={12} alignItems="flex-start">
      {/* Bot Avatar */}
      <Avatar
        size="sm"
        backgroundColor="color.green.500"
        color="white"
        {...DefaultAgentChatStyles.botAvatar}
      >
        🤖
      </Avatar>

      {/* Typing Animation */}
      <View {...DefaultAgentChatStyles.typingIndicator}>
        <Horizontal gap={4} alignItems="center">
          <View
            {...DefaultAgentChatStyles.typingDot}
            style={{
              ...TypingAnimationStyles.dot1,
              animation: 'typing-pulse 1.4s infinite ease-in-out',
            }}
          />
          <View
            {...DefaultAgentChatStyles.typingDot}
            style={{
              ...TypingAnimationStyles.dot2,
              animation: 'typing-pulse 1.4s infinite ease-in-out',
            }}
          />
          <View
            {...DefaultAgentChatStyles.typingDot}
            style={{
              ...TypingAnimationStyles.dot3,
              animation: 'typing-pulse 1.4s infinite ease-in-out',
            }}
          />
        </Horizontal>
      </View>

      {/* Add CSS keyframes for typing animation */}
      <style>
        {`
          @keyframes typing-pulse {
            0%, 80%, 100% {
              opacity: 0.3;
              transform: scale(0.8);
            }
            40% {
              opacity: 1;
              transform: scale(1);
            }
          }
        `}
      </style>
    </Horizontal>
  );
};
</file>

<file path="src/components/adk/AgentChat/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text, Horizontal } from 'app-studio';
import { AgentChat } from '../AgentChat';
import { AgentSession, AgentMessage } from '../AgentChat/AgentChat.props';

/**
 * Default AgentChat Example
 *
 * Demonstrates basic usage of the AgentChat component with ADK agents
 */
export const DefaultDemo = () => {
  const [currentSession, setCurrentSession] = useState<AgentSession | null>(
    null
  );
  const [messages, setMessages] = useState<AgentMessage[]>([]);

  const handleSessionCreate = (session: AgentSession) => {
    console.log('Session created:', session);
    setCurrentSession(session);
  };

  const handleSessionUpdate = (session: AgentSession) => {
    console.log('Session updated:', session);
    setCurrentSession(session);
  };

  const handleMessageSent = (message: AgentMessage) => {
    console.log('Message sent:', message);
    setMessages((prev) => [...prev, message]);
  };

  const handleMessageReceived = (message: AgentMessage) => {
    console.log('Message received:', message);
    setMessages((prev) => [...prev, message]);
  };

  const handleError = (error: Error) => {
    console.error('AgentChat error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentChat Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A complete chat interface for interacting with ADK agents. Supports
        real-time messaging, file uploads, function calls, code execution, and
        more.
      </Text>

      {/* Session Info */}
      {currentSession && (
        <View
          padding={16}
          backgroundColor="color.blue.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.blue.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.blue.800">
            Active Session
          </Text>
          <Text fontSize={12} color="color.blue.600">
            ID: {currentSession.id}
          </Text>
          <Text fontSize={12} color="color.blue.600">
            App: {currentSession.appName}
          </Text>
        </View>
      )}

      {/* AgentChat Component */}
      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentChat
          appName="demo-agent"
          userId="demo-user"
          apiBaseUrl="http://localhost:3000/adk"
          placeholder="Ask the agent anything..."
          enableFileUpload={true}
          enableStreaming={true}
          enableThoughts={true}
          showTimestamps={true}
          showAvatars={true}
          showTypingIndicator={true}
          autoScroll={true}
          maxFileSize={10 * 1024 * 1024} // 10MB
          maxFiles={5}
          allowedFileTypes={[
            'image/*',
            'video/*',
            'audio/*',
            'application/pdf',
            'text/*',
          ]}
          onSessionCreate={handleSessionCreate}
          onSessionUpdate={handleSessionUpdate}
          onMessageSent={handleMessageSent}
          onMessageReceived={handleMessageReceived}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
            messageList: {
              backgroundColor: 'color.gray.100',
            },
            inputArea: {
              backgroundColor: 'color.white',
            },
          }}
        />
      </View>

      {/* Message Log */}
      {messages.length > 0 && (
        <View>
          <Text fontSize={16} fontWeight="600" marginBottom={16}>
            Message Log ({messages.length} messages)
          </Text>
          <View
            maxHeight="200px"
            overflowY="auto"
            padding={16}
            backgroundColor="color.gray.50"
            borderRadius="8px"
          >
            <Vertical gap={8}>
              {messages.map((message, index) => (
                <View
                  key={message.id}
                  padding={8}
                  backgroundColor="color.white"
                  borderRadius="4px"
                >
                  <Horizontal
                    justifyContent="space-between"
                    alignItems="center"
                  >
                    <Text
                      fontSize={12}
                      fontWeight="600"
                      color={
                        message.role === 'user'
                          ? 'color.blue.600'
                          : 'color.green.600'
                      }
                    >
                      {message.role === 'user' ? '👤 User' : '🤖 Agent'}
                    </Text>
                    <Text fontSize={10} color="color.gray.500">
                      {new Date(message.timestamp).toLocaleTimeString()}
                    </Text>
                  </Horizontal>
                  <Text fontSize={12} marginTop={4}>
                    {message.text || '[Non-text content]'}
                  </Text>
                  {message.thought && (
                    <Text
                      fontSize={10}
                      color="color.yellow.600"
                      fontStyle="italic"
                    >
                      💭 Thought
                    </Text>
                  )}
                </View>
              ))}
            </Vertical>
          </View>
        </View>
      )}
    </Vertical>
  );
};

/**
 * Minimal AgentChat Example
 *
 * Shows the simplest possible usage
 */
export const MinimalDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Minimal AgentChat Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentChat appName="simple-agent" userId="user123" />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentChat Example
 *
 * Shows advanced customization options with enhanced views prop
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentChat Example - Enhanced Views
      </Text>

      <Text color="color.gray.600" fontSize={14}>
        Demonstrates comprehensive customization using the enhanced views prop
        and container props for complete control over appearance.
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.purple.200"
        borderRadius="12px"
      >
        <AgentChat
          appName="custom-agent"
          userId="user123"
          placeholder="Chat with our custom AI assistant..."
          enableFileUpload={true}
          enableThoughts={true}
          showAvatars={true}
          colorScheme="purple"
          compact={false}
          rounded={true}
          containerProps={{
            backgroundColor: 'color.purple.25',
            border: '2px solid',
            borderColor: 'color.purple.300',
          }}
          views={{
            // Main areas
            container: {
              backgroundColor: 'color.purple.25',
            },
            header: {
              backgroundColor: 'color.purple.500',
              color: 'white',
              padding: '16px',
              borderRadius: '12px 12px 0 0',
            },
            messageList: {
              backgroundColor: 'color.white',
              padding: '20px',
            },
            inputArea: {
              backgroundColor: 'color.purple.50',
              padding: '16px',
              borderRadius: '0 0 12px 12px',
            },

            // Message styling
            userMessage: {
              backgroundColor: 'color.purple.500',
              color: 'white',
              borderRadius: '18px 18px 4px 18px',
              padding: '12px 16px',
              marginLeft: '40px',
            },
            botMessage: {
              backgroundColor: 'color.purple.100',
              color: 'color.purple.900',
              borderRadius: '18px 18px 18px 4px',
              padding: '12px 16px',
              marginRight: '40px',
            },
            messageTimestamp: {
              color: 'color.purple.600',
              fontSize: '12px',
            },
            messageAvatar: {
              borderRadius: '50%',
              border: '2px solid',
              borderColor: 'color.purple.300',
            },

            // Input components
            inputField: {
              borderRadius: '24px',
              border: '2px solid',
              borderColor: 'color.purple.200',
              backgroundColor: 'white',
            },
            sendButton: {
              backgroundColor: 'color.purple.500',
              borderRadius: '50%',
              padding: '12px',
            },
            attachButton: {
              color: 'color.purple.500',
              borderRadius: '8px',
            },

            // State indicators
            typingIndicator: {
              color: 'color.purple.600',
              backgroundColor: 'color.purple.100',
              borderRadius: '16px',
              padding: '8px 12px',
            },
            loadingIndicator: {
              color: 'color.purple.500',
            },

            // Attachment components
            attachmentArea: {
              backgroundColor: 'color.purple.50',
              borderRadius: '8px',
              padding: '12px',
              border: '1px dashed',
              borderColor: 'color.purple.300',
            },
            attachmentPreview: {
              borderRadius: '8px',
              border: '1px solid',
              borderColor: 'color.purple.200',
            },

            // Function call components
            functionCall: {
              backgroundColor: 'color.purple.50',
              border: '1px solid',
              borderColor: 'color.purple.200',
              borderRadius: '8px',
              padding: '12px',
            },

            // Code components
            codeBlock: {
              backgroundColor: 'color.gray.900',
              color: 'color.gray.100',
              borderRadius: '8px',
              padding: '16px',
            },

            // Thought components
            thoughtBubble: {
              backgroundColor: 'color.purple.25',
              border: '1px dashed',
              borderColor: 'color.purple.300',
              borderRadius: '12px',
              padding: '12px',
              fontStyle: 'italic',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Agent with Function Calls Example
 *
 * Demonstrates function call capabilities
 */
export const FunctionCallsDemo = () => {
  const initialMessages: AgentMessage[] = [
    {
      id: '1',
      role: 'user',
      text: "What's the weather like in San Francisco?",
      timestamp: Date.now() - 60000,
    },
    {
      id: '2',
      role: 'bot',
      text: "I'll check the weather for you.",
      timestamp: Date.now() - 50000,
      functionCall: {
        id: 'call_1',
        name: 'get_weather',
        args: { location: 'San Francisco, CA' },
      },
    },
    {
      id: '3',
      role: 'bot',
      text: 'The weather in San Francisco is currently 68°F with partly cloudy skies.',
      timestamp: Date.now() - 40000,
      functionResponse: {
        id: 'call_1',
        name: 'get_weather',
        response: { temperature: 68, condition: 'partly cloudy', humidity: 65 },
      },
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentChat with Function Calls
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentChat
          appName="function-agent"
          userId="user123"
          initialMessages={initialMessages}
          enableFunctionCalls={true}
          enableCodeExecution={true}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Evaluation Types
 */
export interface EvaluationMetric {
  id: string;
  name: string;
  description: string;
  type: 'accuracy' | 'latency' | 'cost' | 'quality' | 'safety' | 'custom';
  threshold?: number;
  weight?: number;
  config?: Record<string, any>;
}

export interface EvaluationTestCase {
  id: string;
  name: string;
  description?: string;
  input: any;
  expectedOutput?: any;
  metadata?: Record<string, any>;
  tags?: string[];
}

export interface EvaluationRun {
  id: string;
  name: string;
  appName: string;
  userId: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  progress: number; // 0-100
  startTime: number;
  endTime?: number;
  duration?: number;
  testCases: EvaluationTestCase[];
  metrics: EvaluationMetric[];
  results?: EvaluationResult[];
  summary?: EvaluationSummary;
  config?: EvaluationConfig;
  error?: string;
}

export interface EvaluationResult {
  id: string;
  evaluationId: string;
  testCaseId: string;
  status: 'pass' | 'fail' | 'error' | 'skip';
  score?: number;
  actualOutput?: any;
  metrics: Record<string, number>;
  duration: number;
  error?: string;
  details?: Record<string, any>;
  timestamp: number;
}

export interface EvaluationSummary {
  totalTests: number;
  passedTests: number;
  failedTests: number;
  errorTests: number;
  skippedTests: number;
  averageScore: number;
  totalDuration: number;
  metricsAverages: Record<string, number>;
  passRate: number;
}

export interface EvaluationConfig {
  maxConcurrency?: number;
  timeout?: number;
  retryCount?: number;
  stopOnFailure?: boolean;
  randomizeOrder?: boolean;
  enableDetailedLogging?: boolean;
}

/**
 * Component View Customization
 */
export interface AgentEvalViews {
  // Main container areas
  container?: ViewProps;
  header?: ViewProps;
  toolbar?: ViewProps;
  evaluationList?: ViewProps;
  createPanel?: ViewProps;
  resultsPanel?: ViewProps;
  metricsPanel?: ViewProps;
  configPanel?: ViewProps;

  // Evaluation list items
  evaluationItem?: ViewProps;
  activeEvaluationItem?: ViewProps;
  evaluationTitle?: ViewProps;
  evaluationDescription?: ViewProps;
  evaluationStatus?: ViewProps;
  evaluationProgress?: ViewProps;
  evaluationMetrics?: ViewProps;
  evaluationTimestamp?: ViewProps;

  // Test case components
  testCaseList?: ViewProps;
  testCaseItem?: ViewProps;
  testCaseInput?: ViewProps;
  testCaseOutput?: ViewProps;
  testCaseExpected?: ViewProps;
  testCaseResult?: ViewProps;
  testCaseMetrics?: ViewProps;

  // Progress and status
  progressBar?: ViewProps;
  statusIndicator?: ViewProps;
  statusBadge?: ViewProps;
  scoreDisplay?: ViewProps;
  durationDisplay?: ViewProps;

  // Action buttons
  actionButtons?: ViewProps;
  runButton?: ViewProps;
  stopButton?: ViewProps;
  exportButton?: ViewProps;
  refreshButton?: ViewProps;
  deleteButton?: ViewProps;
  duplicateButton?: ViewProps;

  // Search and filters
  searchInput?: ViewProps;
  filterDropdown?: ViewProps;
  sortDropdown?: ViewProps;
  statusFilter?: ViewProps;

  // State displays
  emptyState?: ViewProps;
  loadingState?: ViewProps;
  errorState?: ViewProps;

  // Results visualization
  chartContainer?: ViewProps;
  metricsChart?: ViewProps;
  resultsTable?: ViewProps;
  summaryCard?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentEvalEventHandlers {
  onEvaluationCreate?: (evaluation: EvaluationRun) => void;
  onEvaluationStart?: (evaluationId: string) => void;
  onEvaluationComplete?: (result: EvaluationRun) => void;
  onEvaluationCancel?: (evaluationId: string) => void;
  onEvaluationDelete?: (evaluationId: string) => void;
  onTestCaseSelect?: (testCase: EvaluationTestCase) => void;
  onResultSelect?: (result: EvaluationResult) => void;
  onExport?: (format: 'json' | 'csv' | 'pdf') => void;
  onError?: (error: Error) => void;
  onRefresh?: () => void;
}

/**
 * Evaluation Templates
 */
export interface EvaluationTemplate {
  id: string;
  name: string;
  description: string;
  testCases: EvaluationTestCase[];
  metrics: EvaluationMetric[];
  config: EvaluationConfig;
  tags?: string[];
}

/**
 * Comparison Options
 */
export interface EvaluationComparison {
  baselineId: string;
  comparisonIds: string[];
  metrics: string[];
  showDifferences?: boolean;
  showTrends?: boolean;
}

/**
 * Main AgentEval Props Interface
 */
export interface AgentEvalProps extends ViewProps, AgentEvalEventHandlers {
  // Required props
  appName: string;
  userId: string;

  // Optional configuration
  apiBaseUrl?: string;

  // Feature toggles
  enableBatchEvaluation?: boolean;
  enableMetricsComparison?: boolean;
  enableResultExport?: boolean;
  enableTemplates?: boolean;
  enableAutoRefresh?: boolean;

  // Limits and constraints
  maxConcurrentEvals?: number;
  maxTestCases?: number;
  refreshInterval?: number; // in milliseconds

  // UI customization
  showEvaluationHistory?: boolean;
  showMetricsPanel?: boolean;
  showTestCaseDetails?: boolean;
  showProgressIndicators?: boolean;
  compactMode?: boolean;

  // Styling and customization
  views?: AgentEvalViews;
  containerProps?: ViewProps;

  // Initial state
  initialEvaluations?: EvaluationRun[];
  selectedEvaluationId?: string;
  availableTemplates?: EvaluationTemplate[];

  // Advanced features
  enableRealTimeUpdates?: boolean;
  enableResultCaching?: boolean;
  enableCustomMetrics?: boolean;

  // Theme and appearance
  colorScheme?: 'blue' | 'purple' | 'green' | 'orange' | 'red' | 'gray';
  layout?: 'list' | 'grid' | 'dashboard';
  showCharts?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

/**
 * Export Options
 */
export interface EvaluationExportOptions {
  format: 'json' | 'csv' | 'pdf';
  includeTestCases?: boolean;
  includeResults?: boolean;
  includeMetrics?: boolean;
  includeSummary?: boolean;
  evaluationIds?: string[];
}

/**
 * Real-time Update Types
 */
export interface EvaluationUpdate {
  type: 'progress' | 'result' | 'status' | 'complete' | 'error';
  evaluationId: string;
  data: any;
  timestamp: number;
}
</file>

<file path="src/components/adk/AgentEval/AgentEval/AgentEval.view.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { AgentEvalProps } from './AgentEval.props';
import { useAgentEval } from './AgentEval.state';
import { DefaultAgentEvalStyles } from './AgentEval.style';
import { EvaluationList } from './EvaluationList';
import { EvaluationCreator } from './EvaluationCreator';
import { EvaluationResults } from './EvaluationResults';
import { EvaluationMetrics } from './EvaluationMetrics';
import { Loader } from '../../../Loader/Loader';
import { TextField } from '../../../Form/Form';

export interface AgentEvalViewProps
  extends AgentEvalProps,
    ReturnType<typeof useAgentEval> {}

/**
 * AgentEval View Component
 *
 * Renders the complete evaluation interface with creation, monitoring, and results analysis
 */
const AgentEvalView: React.FC<AgentEvalViewProps> = ({
  // Props
  enableBatchEvaluation = true,
  enableMetricsComparison = true,
  enableResultExport = true,
  enableTemplates = true,
  showEvaluationHistory = true,
  showMetricsPanel = true,
  showTestCaseDetails = true,
  showProgressIndicators = true,
  compactMode = false,
  views,
  ariaLabel = 'Agent Evaluation Interface',
  ariaDescribedBy,

  // State from hook
  evaluations,
  selectedEvaluation,
  selectedResult,
  isLoading,
  isCreating,
  error,
  searchQuery,
  templates,
  runningEvaluationsCount,
  canStartNewEvaluation,
  fetchEvaluations,
  createEvaluation,
  startEvaluation,
  cancelEvaluation,
  deleteEvaluation,
  selectEvaluation,
  selectResult,
  exportEvaluations,
  setSearchQuery,
  setError,

  ...props
}) => {
  const [activeTab, setActiveTab] = React.useState('evaluations');
  /**
   * Handle evaluation creation
   */
  const handleCreateEvaluation = async (
    name: string,
    testCases: any[],
    metrics: any[]
  ) => {
    try {
      await createEvaluation(name, testCases, metrics);
    } catch (error) {
      // Error is handled in the hook
    }
  };

  /**
   * Handle evaluation start
   */
  const handleStartEvaluation = (evaluationId: string) => {
    startEvaluation(evaluationId);
  };

  /**
   * Handle evaluation cancel
   */
  const handleCancelEvaluation = (evaluationId: string) => {
    if (window.confirm('Are you sure you want to cancel this evaluation?')) {
      cancelEvaluation(evaluationId);
    }
  };

  /**
   * Handle evaluation delete
   */
  const handleDeleteEvaluation = (evaluationId: string) => {
    if (window.confirm('Are you sure you want to delete this evaluation?')) {
      deleteEvaluation(evaluationId);
    }
  };

  /**
   * Handle export
   */
  const handleExport = (format: 'json' | 'csv' | 'pdf') => {
    exportEvaluations({
      format,
      includeTestCases: true,
      includeResults: true,
      includeMetrics: true,
      includeSummary: true,
    });
  };

  /**
   * Handle refresh
   */
  const handleRefresh = () => {
    fetchEvaluations();
  };

  return (
    <View
      {...DefaultAgentEvalStyles.container}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentEvalStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Evaluation
            </Text>
            <Text fontSize="sm" color="color.gray.600">
              {evaluations.length} evaluation
              {evaluations.length !== 1 ? 's' : ''} •{runningEvaluationsCount}{' '}
              running
            </Text>
          </Vertical>

          <Horizontal gap={8}>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isLoading}
              aria-label="Refresh evaluations"
            >
              {isLoading ? <Loader size="xs" /> : '🔄'}
            </Button>

            {enableResultExport && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleExport('json')}
                disabled={evaluations.length === 0}
                aria-label="Export evaluations"
              >
                📤 Export
              </Button>
            )}
          </Horizontal>
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Text variant="error" onClick={() => setError(null)}>
          {error}
        </Text>
      )}

      {/* Search */}
      <View
        padding={16}
        borderBottom="1px solid"
        borderBottomColor="color.gray.200"
      >
        <TextField
          placeholder="Search evaluations..."
          value={searchQuery}
          onChange={setSearchQuery}
          views={{
            container: views?.searchInput,
          }}
        />
      </View>

      {/* Main Content */}
      <View flex={1} display="flex" flexDirection="column">
        {compactMode ? (
          // Compact mode - single view
          <EvaluationList
            evaluations={evaluations}
            selectedEvaluation={selectedEvaluation}
            onEvaluationSelect={selectEvaluation}
            onEvaluationStart={handleStartEvaluation}
            onEvaluationCancel={handleCancelEvaluation}
            onEvaluationDelete={handleDeleteEvaluation}
            showProgressIndicators={showProgressIndicators}
            compactMode={true}
            views={{
              container: views?.evaluationList,
              evaluationItem: views?.evaluationItem,
              activeEvaluationItem: views?.activeEvaluationItem,
            }}
          />
        ) : (
          // Full mode - tabbed interface
          <View flex={1} display="flex" flexDirection="column">
            {/* Tab Navigation */}
            <View
              display="flex"
              borderBottom="1px solid"
              borderBottomColor="color.gray.200"
              backgroundColor="color.gray.50"
            >
              <Button
                variant={activeTab === 'evaluations' ? 'filled' : 'ghost'}
                onClick={() => setActiveTab('evaluations')}
                borderRadius="0"
                borderBottom={
                  activeTab === 'evaluations' ? '2px solid' : 'none'
                }
                borderBottomColor="color.blue.500"
              >
                Evaluations
              </Button>
              <Button
                variant={activeTab === 'create' ? 'filled' : 'ghost'}
                onClick={() => setActiveTab('create')}
                borderRadius="0"
                borderBottom={activeTab === 'create' ? '2px solid' : 'none'}
                borderBottomColor="color.blue.500"
              >
                Create New
              </Button>
              {selectedEvaluation && (
                <Button
                  variant={activeTab === 'results' ? 'filled' : 'ghost'}
                  onClick={() => setActiveTab('results')}
                  borderRadius="0"
                  borderBottom={activeTab === 'results' ? '2px solid' : 'none'}
                  borderBottomColor="color.blue.500"
                >
                  Results
                </Button>
              )}
              {showMetricsPanel && (
                <Button
                  variant={activeTab === 'metrics' ? 'filled' : 'ghost'}
                  onClick={() => setActiveTab('metrics')}
                  borderRadius="0"
                  borderBottom={activeTab === 'metrics' ? '2px solid' : 'none'}
                  borderBottomColor="color.blue.500"
                >
                  Metrics
                </Button>
              )}
            </View>

            {/* Tab Content */}
            <View flex={1}>
              {activeTab === 'evaluations' && (
                <EvaluationList
                  evaluations={evaluations}
                  selectedEvaluation={selectedEvaluation}
                  onEvaluationSelect={selectEvaluation}
                  onEvaluationStart={handleStartEvaluation}
                  onEvaluationCancel={handleCancelEvaluation}
                  onEvaluationDelete={handleDeleteEvaluation}
                  showProgressIndicators={showProgressIndicators}
                  compactMode={false}
                  views={{
                    container: views?.evaluationList,
                    evaluationItem: views?.evaluationItem,
                    activeEvaluationItem: views?.activeEvaluationItem,
                  }}
                />
              )}

              {activeTab === 'create' && (
                <EvaluationCreator
                  templates={enableTemplates ? templates : []}
                  isCreating={isCreating}
                  canCreate={canStartNewEvaluation}
                  onCreateEvaluation={handleCreateEvaluation}
                  views={{
                    container: views?.createPanel,
                  }}
                />
              )}

              {activeTab === 'results' && selectedEvaluation && (
                <EvaluationResults
                  evaluation={selectedEvaluation}
                  selectedResult={selectedResult}
                  onResultSelect={selectResult}
                  showTestCaseDetails={showTestCaseDetails}
                  views={{
                    container: views?.resultsPanel,
                    testCaseList: views?.testCaseList,
                    testCaseItem: views?.testCaseItem,
                  }}
                />
              )}

              {activeTab === 'metrics' && showMetricsPanel && (
                <EvaluationMetrics
                  evaluations={evaluations}
                  enableComparison={enableMetricsComparison}
                  views={{
                    container: views?.metricsPanel,
                  }}
                />
              )}
            </View>
          </View>
        )}
      </View>

      {/* Loading State */}
      {isLoading && evaluations.length === 0 && (
        <View {...DefaultAgentEvalStyles.loadingState} {...views?.loadingState}>
          <Loader size="md" />
          <Text color="color.gray.600">Loading evaluations...</Text>
        </View>
      )}

      {/* Empty State */}
      {!isLoading && evaluations.length === 0 && (
        <View {...DefaultAgentEvalStyles.emptyState} {...views?.emptyState}>
          <Text fontSize="lg" color="color.gray.500" textAlign="center">
            No evaluations found
          </Text>
          <Text fontSize="sm" color="color.gray.400" textAlign="center">
            Create your first evaluation to get started
          </Text>
          <Button
            variant="filled"
            onClick={() => {
              // Switch to create tab if in tabbed mode
              const createTab = document.querySelector(
                '[data-value="create"]'
              ) as HTMLElement;
              createTab?.click();
            }}
            marginTop={16}
          >
            Create Evaluation
          </Button>
        </View>
      )}
    </View>
  );
};

export default AgentEvalView;
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationCreator.tsx">
import React, { useState } from 'react';
import { Select, TextArea, TextField } from '../../../Form/Form';

import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import {
  EvaluationTemplate,
  EvaluationTestCase,
  EvaluationMetric,
} from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationCreatorProps {
  templates: EvaluationTemplate[];
  isCreating: boolean;
  canCreate: boolean;
  onCreateEvaluation: (
    name: string,
    testCases: EvaluationTestCase[],
    metrics: EvaluationMetric[]
  ) => void;
  views?: {
    container?: any;
  };
}

/**
 * EvaluationCreator Component
 *
 * Form for creating new evaluations with test cases and metrics
 */
export const EvaluationCreator: React.FC<EvaluationCreatorProps> = ({
  templates,
  isCreating,
  canCreate,
  onCreateEvaluation,
  views = {},
}) => {
  const [name, setName] = useState('');
  const [selectedTemplate, setSelectedTemplate] = useState<string>('');
  const [testCasesText, setTestCasesText] = useState('');
  const [metricsText, setMetricsText] = useState('');

  /**
   * Handle template selection
   */
  const handleTemplateSelect = (templateId: string) => {
    setSelectedTemplate(templateId);
    const template = templates.find((t) => t.id === templateId);
    if (template) {
      setName(template.name);
      setTestCasesText(JSON.stringify(template.testCases, null, 2));
      setMetricsText(JSON.stringify(template.metrics, null, 2));
    }
  };

  /**
   * Handle form submission
   */
  const handleSubmit = () => {
    if (!name.trim()) {
      alert('Please enter a name for the evaluation');
      return;
    }

    try {
      const testCases = testCasesText ? JSON.parse(testCasesText) : [];
      const metrics = metricsText ? JSON.parse(metricsText) : [];

      onCreateEvaluation(name, testCases, metrics);

      // Reset form
      setName('');
      setSelectedTemplate('');
      setTestCasesText('');
      setMetricsText('');
    } catch (error) {
      alert('Invalid JSON in test cases or metrics');
    }
  };

  /**
   * Load sample data
   */
  const loadSampleData = () => {
    setName('Sample Evaluation');
    setTestCasesText(
      JSON.stringify(
        [
          {
            id: 'test-1',
            name: 'Basic Question',
            description: 'Test basic question answering',
            input: { question: 'What is 2+2?' },
            expectedOutput: { answer: '4' },
            tags: ['math', 'basic'],
          },
          {
            id: 'test-2',
            name: 'Complex Question',
            description: 'Test complex reasoning',
            input: { question: 'Explain the concept of recursion' },
            expectedOutput: { answer: 'A function that calls itself...' },
            tags: ['programming', 'complex'],
          },
        ],
        null,
        2
      )
    );

    setMetricsText(
      JSON.stringify(
        [
          {
            id: 'accuracy',
            name: 'Accuracy',
            description: 'Measures correctness of answers',
            type: 'accuracy',
            threshold: 0.8,
            weight: 1.0,
          },
          {
            id: 'latency',
            name: 'Response Time',
            description: 'Measures response latency',
            type: 'latency',
            threshold: 5000,
            weight: 0.5,
          },
        ],
        null,
        2
      )
    );
  };

  return (
    <View {...DefaultAgentEvalStyles.createPanel} {...views.container}>
      <Vertical gap={24}>
        <Text fontSize="lg" fontWeight="600">
          Create New Evaluation
        </Text>

        {!canCreate && (
          <View
            padding={12}
            backgroundColor="color.yellow.50"
            borderRadius="8px"
            border="1px solid"
            borderColor="color.yellow.200"
          >
            <Text fontSize="sm" color="color.yellow.800">
              ⚠️ Maximum concurrent evaluations reached. Please wait for running
              evaluations to complete.
            </Text>
          </View>
        )}

        {/* Template Selection */}
        {templates.length > 0 && (
          <View {...DefaultAgentEvalStyles.formGroup}>
            <Text {...DefaultAgentEvalStyles.formLabel}>
              Use Template (Optional)
            </Text>
            <Select
              value={selectedTemplate}
              onChange={handleTemplateSelect}
              options={[
                { value: '', label: 'No template' },
                ...templates.map((t) => ({ value: t.id, label: t.name })),
              ]}
              placeholder="Select a template"
            />
          </View>
        )}

        {/* Evaluation Name */}
        <View {...DefaultAgentEvalStyles.formGroup}>
          <Text {...DefaultAgentEvalStyles.formLabel}>Evaluation Name *</Text>
          <TextField
            value={name}
            onChange={setName}
            placeholder="Enter evaluation name"
            disabled={isCreating}
          />
        </View>

        {/* Test Cases */}
        <View {...DefaultAgentEvalStyles.formGroup}>
          <Horizontal
            justifyContent="space-between"
            alignItems="center"
            marginBottom={8}
          >
            <Text {...DefaultAgentEvalStyles.formLabel}>Test Cases (JSON)</Text>
            <Button
              variant="outline"
              size="sm"
              onClick={loadSampleData}
              disabled={isCreating}
            >
              Load Sample
            </Button>
          </Horizontal>
          <TextArea
            value={testCasesText}
            onChange={(e) => setTestCasesText(e.target.value)}
            placeholder="Enter test cases as JSON array"
            disabled={isCreating}
            style={{
              width: '100%',
              minHeight: '200px',
              padding: '8px 12px',
              border: '1px solid',
              borderColor: 'color.gray.300',
              borderRadius: '6px',
              fontSize: '14px',
            }}
          />
          <Text fontSize="xs" color="color.gray.600" marginTop={4}>
            Each test case should have: id, name, input, expectedOutput
            (optional)
          </Text>
        </View>

        {/* Metrics */}
        <View {...DefaultAgentEvalStyles.formGroup}>
          <Text {...DefaultAgentEvalStyles.formLabel}>Metrics (JSON)</Text>
          <TextArea
            value={metricsText}
            onChange={(e) => setMetricsText(e.target.value)}
            placeholder="Enter metrics as JSON array"
            disabled={isCreating}
            style={{
              width: '100%',
              minHeight: '150px',
              padding: '8px 12px',
              border: '1px solid',
              borderColor: 'color.gray.300',
              borderRadius: '6px',
              fontSize: '14px',
            }}
          />
          <Text fontSize="xs" color="color.gray.600" marginTop={4}>
            Each metric should have: id, name, type, threshold (optional),
            weight (optional)
          </Text>
        </View>

        {/* Actions */}
        <Horizontal gap={12}>
          <Button
            variant="filled"
            onClick={handleSubmit}
            disabled={!name.trim() || isCreating || !canCreate}
            loading={isCreating}
          >
            {isCreating ? 'Creating...' : 'Create Evaluation'}
          </Button>

          <Button
            variant="outline"
            onClick={() => {
              setName('');
              setSelectedTemplate('');
              setTestCasesText('');
              setMetricsText('');
            }}
            disabled={isCreating}
          >
            Clear
          </Button>
        </Horizontal>

        {/* Help Text */}
        <View
          padding={16}
          backgroundColor="color.blue.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.blue.200"
        >
          <Text
            fontSize="sm"
            fontWeight="600"
            color="color.blue.800"
            marginBottom={8}
          >
            💡 Tips for Creating Evaluations
          </Text>
          <Vertical gap={4}>
            <Text fontSize="sm" color="color.blue.700">
              • Use descriptive names for test cases to easily identify them
            </Text>
            <Text fontSize="sm" color="color.blue.700">
              • Include diverse test cases to thoroughly evaluate your agent
            </Text>
            <Text fontSize="sm" color="color.blue.700">
              • Set appropriate thresholds for metrics based on your
              requirements
            </Text>
            <Text fontSize="sm" color="color.blue.700">
              • Use tags to categorize and filter test cases
            </Text>
          </Vertical>
        </View>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationList.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { EvaluationRun } from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationListProps {
  evaluations: EvaluationRun[];
  selectedEvaluation?: EvaluationRun | null;
  onEvaluationSelect: (evaluationId: string) => void;
  onEvaluationStart: (evaluationId: string) => void;
  onEvaluationCancel: (evaluationId: string) => void;
  onEvaluationDelete: (evaluationId: string) => void;
  showProgressIndicators?: boolean;
  compactMode?: boolean;
  views?: {
    container?: any;
    evaluationItem?: any;
    activeEvaluationItem?: any;
  };
}

/**
 * EvaluationList Component
 *
 * Renders a list of evaluations with status, progress, and actions
 */
export const EvaluationList: React.FC<EvaluationListProps> = ({
  evaluations,
  selectedEvaluation,
  onEvaluationSelect,
  onEvaluationStart,
  onEvaluationCancel,
  onEvaluationDelete,
  showProgressIndicators = true,
  compactMode = false,
  views = {},
}) => {
  /**
   * Get status badge style
   */
  const getStatusStyle = (status: string) => {
    const baseStyle = DefaultAgentEvalStyles.statusBadge;

    switch (status) {
      case 'pending':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusPending };
      case 'running':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusRunning };
      case 'completed':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusCompleted };
      case 'failed':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusFailed };
      case 'cancelled':
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusCancelled };
      default:
        return { ...baseStyle, ...DefaultAgentEvalStyles.statusPending };
    }
  };

  /**
   * Format duration
   */
  const formatDuration = (duration?: number) => {
    if (!duration) return '';
    if (duration < 60000) return `${Math.round(duration / 1000)}s`;
    return `${Math.round(duration / 60000)}m`;
  };

  /**
   * Format timestamp
   */
  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp).toLocaleDateString([], {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <View {...DefaultAgentEvalStyles.evaluationList} {...views.container}>
      <Vertical gap={compactMode ? 8 : 12}>
        {evaluations.map((evaluation) => {
          const isSelected = selectedEvaluation?.id === evaluation.id;
          const containerStyle = isSelected
            ? {
                ...DefaultAgentEvalStyles.activeEvaluationItem,
                ...views.activeEvaluationItem,
              }
            : {
                ...DefaultAgentEvalStyles.evaluationItem,
                ...views.evaluationItem,
              };

          return (
            <View
              key={evaluation.id}
              {...containerStyle}
              onClick={() => onEvaluationSelect(evaluation.id)}
            >
              <Vertical gap={compactMode ? 8 : 12}>
                {/* Evaluation Header */}
                <Horizontal
                  justifyContent="space-between"
                  alignItems="flex-start"
                >
                  <Vertical gap={4}>
                    <Text {...DefaultAgentEvalStyles.evaluationTitle}>
                      {evaluation.name}
                    </Text>
                    <Horizontal gap={12} alignItems="center">
                      <View {...getStatusStyle(evaluation.status)}>
                        <Text>{evaluation.status}</Text>
                      </View>
                      <Text {...DefaultAgentEvalStyles.evaluationMeta}>
                        {evaluation.testCases.length} test
                        {evaluation.testCases.length !== 1 ? 's' : ''}
                      </Text>
                      <Text {...DefaultAgentEvalStyles.evaluationMeta}>
                        {formatTimestamp(evaluation.startTime)}
                      </Text>
                      {evaluation.duration && (
                        <Text {...DefaultAgentEvalStyles.evaluationMeta}>
                          {formatDuration(evaluation.duration)}
                        </Text>
                      )}
                    </Horizontal>
                  </Vertical>
                </Horizontal>

                {/* Progress Bar */}
                {showProgressIndicators && evaluation.status === 'running' && (
                  <View>
                    <Horizontal
                      justifyContent="space-between"
                      alignItems="center"
                      marginBottom={4}
                    >
                      <Text fontSize="xs" color="color.gray.600">
                        Progress
                      </Text>
                      <Text fontSize="xs" color="color.gray.600">
                        {evaluation.progress}%
                      </Text>
                    </Horizontal>
                    <View {...DefaultAgentEvalStyles.progressBar}>
                      <View
                        {...DefaultAgentEvalStyles.progressFill}
                        style={{ width: `${evaluation.progress}%` }}
                      />
                    </View>
                  </View>
                )}

                {/* Summary (for completed evaluations) */}
                {evaluation.summary && !compactMode && (
                  <Horizontal gap={16} alignItems="center">
                    <Text fontSize="sm" color="color.green.700">
                      ✅ {evaluation.summary.passedTests} passed
                    </Text>
                    {evaluation.summary.failedTests > 0 && (
                      <Text fontSize="sm" color="color.red.700">
                        ❌ {evaluation.summary.failedTests} failed
                      </Text>
                    )}
                    <Text fontSize="sm" color="color.gray.600">
                      Avg Score: {evaluation.summary.averageScore.toFixed(1)}
                    </Text>
                    <Text fontSize="sm" color="color.gray.600">
                      Pass Rate:{' '}
                      {(evaluation.summary.passRate * 100).toFixed(1)}%
                    </Text>
                  </Horizontal>
                )}

                {/* Error Message */}
                {evaluation.error && (
                  <View
                    padding={8}
                    backgroundColor="color.red.50"
                    borderRadius="4px"
                    border="1px solid"
                    borderColor="color.red.200"
                  >
                    <Text fontSize="sm" color="color.red.700">
                      Error: {evaluation.error}
                    </Text>
                  </View>
                )}

                {/* Actions */}
                <View {...DefaultAgentEvalStyles.evaluationActions}>
                  <Horizontal gap={8}>
                    {evaluation.status === 'pending' && (
                      <Button
                        {...DefaultAgentEvalStyles.actionButton}
                        {...DefaultAgentEvalStyles.startButton}
                        onClick={(e) => {
                          e.stopPropagation();
                          onEvaluationStart(evaluation.id);
                        }}
                        size="sm"
                      >
                        ▶️ Start
                      </Button>
                    )}

                    {evaluation.status === 'running' && (
                      <Button
                        {...DefaultAgentEvalStyles.actionButton}
                        {...DefaultAgentEvalStyles.cancelButton}
                        onClick={(e) => {
                          e.stopPropagation();
                          onEvaluationCancel(evaluation.id);
                        }}
                        size="sm"
                      >
                        ⏹️ Cancel
                      </Button>
                    )}

                    {(evaluation.status === 'completed' ||
                      evaluation.status === 'failed' ||
                      evaluation.status === 'cancelled') && (
                      <Button
                        {...DefaultAgentEvalStyles.actionButton}
                        {...DefaultAgentEvalStyles.deleteButton}
                        onClick={(e) => {
                          e.stopPropagation();
                          onEvaluationDelete(evaluation.id);
                        }}
                        size="sm"
                      >
                        🗑️ Delete
                      </Button>
                    )}
                  </Horizontal>
                </View>
              </Vertical>
            </View>
          );
        })}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationMetrics.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { EvaluationRun } from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationMetricsProps {
  evaluations: EvaluationRun[];
  enableComparison?: boolean;
  views?: {
    container?: any;
  };
}

/**
 * EvaluationMetrics Component
 *
 * Displays aggregated metrics and comparisons across evaluations
 */
export const EvaluationMetrics: React.FC<EvaluationMetricsProps> = ({
  evaluations,
  enableComparison = true,
  views = {},
}) => {
  /**
   * Calculate overall metrics
   */
  const calculateOverallMetrics = () => {
    const completedEvaluations = evaluations.filter(
      (e) => e.status === 'completed' && e.summary
    );

    if (completedEvaluations.length === 0) {
      return null;
    }

    const totalTests = completedEvaluations.reduce(
      (sum, e) => sum + (e.summary?.totalTests || 0),
      0
    );
    const totalPassed = completedEvaluations.reduce(
      (sum, e) => sum + (e.summary?.passedTests || 0),
      0
    );
    const totalFailed = completedEvaluations.reduce(
      (sum, e) => sum + (e.summary?.failedTests || 0),
      0
    );
    const avgScore =
      completedEvaluations.reduce(
        (sum, e) => sum + (e.summary?.averageScore || 0),
        0
      ) / completedEvaluations.length;
    const avgPassRate =
      completedEvaluations.reduce(
        (sum, e) => sum + (e.summary?.passRate || 0),
        0
      ) / completedEvaluations.length;
    const totalDuration = completedEvaluations.reduce(
      (sum, e) => sum + (e.summary?.totalDuration || 0),
      0
    );

    return {
      totalEvaluations: completedEvaluations.length,
      totalTests,
      totalPassed,
      totalFailed,
      avgScore,
      avgPassRate,
      totalDuration,
    };
  };

  /**
   * Get recent evaluations for trend analysis
   */
  const getRecentEvaluations = (count = 5) => {
    return evaluations
      .filter((e) => e.status === 'completed' && e.summary)
      .sort((a, b) => b.startTime - a.startTime)
      .slice(0, count);
  };

  /**
   * Format duration
   */
  const formatDuration = (duration: number) => {
    if (duration < 60000) return `${Math.round(duration / 1000)}s`;
    if (duration < 3600000) return `${Math.round(duration / 60000)}m`;
    return `${Math.round(duration / 3600000)}h`;
  };

  const overallMetrics = calculateOverallMetrics();
  const recentEvaluations = getRecentEvaluations();

  return (
    <View {...DefaultAgentEvalStyles.metricsPanel} {...views.container}>
      <Vertical gap={32}>
        {/* Overall Metrics */}
        {overallMetrics && (
          <View>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Overall Performance
            </Text>

            <View {...DefaultAgentEvalStyles.metricsGrid}>
              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Total Evaluations
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {overallMetrics.totalEvaluations}
                </Text>
              </View>

              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>Total Tests</Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {overallMetrics.totalTests}
                </Text>
              </View>

              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Average Score
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {overallMetrics.avgScore.toFixed(1)}
                </Text>
              </View>

              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>Pass Rate</Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {(overallMetrics.avgPassRate * 100).toFixed(1)}%
                </Text>
              </View>

              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>
                  Success Rate
                </Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {(
                    (overallMetrics.totalPassed / overallMetrics.totalTests) *
                    100
                  ).toFixed(1)}
                  %
                </Text>
              </View>

              <View {...DefaultAgentEvalStyles.metricCard}>
                <Text {...DefaultAgentEvalStyles.metricTitle}>Total Time</Text>
                <Text {...DefaultAgentEvalStyles.metricValue}>
                  {formatDuration(overallMetrics.totalDuration)}
                </Text>
              </View>
            </View>
          </View>
        )}

        {/* Recent Evaluations Trend */}
        {recentEvaluations.length > 0 && (
          <View>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Recent Performance Trend
            </Text>

            <View
              padding={16}
              backgroundColor="color.gray.50"
              borderRadius="8px"
              border="1px solid"
              borderColor="color.gray.200"
            >
              <Vertical gap={12}>
                {recentEvaluations.map((evaluation, index) => (
                  <Horizontal
                    key={evaluation.id}
                    justifyContent="space-between"
                    alignItems="center"
                  >
                    <Vertical gap={2}>
                      <Text fontSize="sm" fontWeight="600">
                        {evaluation.name}
                      </Text>
                      <Text fontSize="xs" color="color.gray.600">
                        {new Date(evaluation.startTime).toLocaleDateString()}
                      </Text>
                    </Vertical>

                    <Horizontal gap={16} alignItems="center">
                      <Text fontSize="sm" color="color.green.700">
                        {evaluation.summary?.passedTests || 0} passed
                      </Text>
                      <Text fontSize="sm" color="color.red.700">
                        {evaluation.summary?.failedTests || 0} failed
                      </Text>
                      <Text fontSize="sm" fontWeight="600">
                        {evaluation.summary?.averageScore.toFixed(1) || 0} avg
                      </Text>
                      <Text fontSize="sm" color="color.gray.600">
                        {((evaluation.summary?.passRate || 0) * 100).toFixed(1)}
                        %
                      </Text>
                    </Horizontal>
                  </Horizontal>
                ))}
              </Vertical>
            </View>
          </View>
        )}

        {/* Evaluation Status Distribution */}
        <View>
          <Text fontSize="lg" fontWeight="600" marginBottom={16}>
            Evaluation Status
          </Text>

          <View {...DefaultAgentEvalStyles.metricsGrid}>
            {['completed', 'running', 'failed', 'cancelled', 'pending'].map(
              (status) => {
                const count = evaluations.filter(
                  (e) => e.status === status
                ).length;
                const percentage =
                  evaluations.length > 0
                    ? (count / evaluations.length) * 100
                    : 0;

                return (
                  <View key={status} {...DefaultAgentEvalStyles.metricCard}>
                    <Text
                      {...DefaultAgentEvalStyles.metricTitle}
                      textTransform="capitalize"
                    >
                      {status}
                    </Text>
                    <Text {...DefaultAgentEvalStyles.metricValue}>{count}</Text>
                    <Text fontSize="xs" color="color.gray.600">
                      {percentage.toFixed(1)}%
                    </Text>
                  </View>
                );
              }
            )}
          </View>
        </View>

        {/* Performance Insights */}
        {overallMetrics && (
          <View>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Performance Insights
            </Text>

            <View
              padding={16}
              backgroundColor="color.blue.50"
              borderRadius="8px"
              border="1px solid"
              borderColor="color.blue.200"
            >
              <Vertical gap={8}>
                <Text fontSize="sm" fontWeight="600" color="color.blue.800">
                  📊 Key Insights
                </Text>

                {overallMetrics.avgPassRate > 0.9 && (
                  <Text fontSize="sm" color="color.green.700">
                    ✅ Excellent performance with{' '}
                    {(overallMetrics.avgPassRate * 100).toFixed(1)}% average
                    pass rate
                  </Text>
                )}

                {overallMetrics.avgPassRate < 0.7 && (
                  <Text fontSize="sm" color="color.red.700">
                    ⚠️ Consider reviewing test cases or agent configuration
                    (pass rate: {(overallMetrics.avgPassRate * 100).toFixed(1)}
                    %)
                  </Text>
                )}

                {overallMetrics.totalEvaluations >= 10 && (
                  <Text fontSize="sm" color="color.blue.700">
                    📈 Good evaluation coverage with{' '}
                    {overallMetrics.totalEvaluations} completed evaluations
                  </Text>
                )}

                {overallMetrics.totalEvaluations < 5 && (
                  <Text fontSize="sm" color="color.yellow.700">
                    💡 Consider running more evaluations for better performance
                    insights
                  </Text>
                )}
              </Vertical>
            </View>
          </View>
        )}

        {/* Empty State */}
        {!overallMetrics && (
          <View textAlign="center" padding={32}>
            <Text fontSize="lg" color="color.gray.500">
              No completed evaluations yet
            </Text>
            <Text fontSize="sm" color="color.gray.400" marginTop={8}>
              Run some evaluations to see performance metrics
            </Text>
          </View>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval/EvaluationResults.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { EvaluationRun, EvaluationResult } from './AgentEval.props';
import { DefaultAgentEvalStyles } from './AgentEval.style';

export interface EvaluationResultsProps {
  evaluation: EvaluationRun;
  selectedResult?: EvaluationResult | null;
  onResultSelect: (result: EvaluationResult) => void;
  showTestCaseDetails?: boolean;
  views?: {
    container?: any;
    testCaseList?: any;
    testCaseItem?: any;
  };
}

/**
 * EvaluationResults Component
 *
 * Displays evaluation results with summary and detailed test case results
 */
export const EvaluationResults: React.FC<EvaluationResultsProps> = ({
  evaluation,
  selectedResult,
  onResultSelect,
  showTestCaseDetails = true,
  views = {},
}) => {
  /**
   * Get test case status style
   */
  const getTestCaseStatusStyle = (status: string) => {
    const baseStyle = DefaultAgentEvalStyles.testCaseStatus;

    switch (status) {
      case 'pass':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCasePass };
      case 'fail':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCaseFail };
      case 'error':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCaseError };
      case 'skip':
        return { ...baseStyle, ...DefaultAgentEvalStyles.testCaseSkip };
      default:
        return baseStyle;
    }
  };

  /**
   * Get status icon
   */
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'pass':
        return '✅';
      case 'fail':
        return '❌';
      case 'error':
        return '⚠️';
      case 'skip':
        return '⏭️';
      default:
        return '❓';
    }
  };

  /**
   * Format duration
   */
  const formatDuration = (duration: number) => {
    if (duration < 1000) return `${duration}ms`;
    return `${(duration / 1000).toFixed(2)}s`;
  };

  return (
    <View {...DefaultAgentEvalStyles.resultsPanel} {...views.container}>
      <Vertical gap={24}>
        {/* Summary */}
        {evaluation.summary && (
          <View {...DefaultAgentEvalStyles.resultsSummary}>
            <Text fontSize="lg" fontWeight="600" marginBottom={16}>
              Evaluation Summary
            </Text>

            <View {...DefaultAgentEvalStyles.summaryGrid}>
              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {evaluation.summary.totalTests}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>
                  Total Tests
                </Text>
              </View>

              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text
                  {...DefaultAgentEvalStyles.summaryValue}
                  color="color.green.600"
                >
                  {evaluation.summary.passedTests}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>Passed</Text>
              </View>

              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text
                  {...DefaultAgentEvalStyles.summaryValue}
                  color="color.red.600"
                >
                  {evaluation.summary.failedTests}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>Failed</Text>
              </View>

              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {evaluation.summary.averageScore.toFixed(1)}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>Avg Score</Text>
              </View>

              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {(evaluation.summary.passRate * 100).toFixed(1)}%
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>Pass Rate</Text>
              </View>

              <View {...DefaultAgentEvalStyles.summaryCard}>
                <Text {...DefaultAgentEvalStyles.summaryValue}>
                  {formatDuration(evaluation.summary.totalDuration)}
                </Text>
                <Text {...DefaultAgentEvalStyles.summaryLabel}>Total Time</Text>
              </View>
            </View>
          </View>
        )}

        {/* Test Case Results */}
        <View>
          <Text fontSize="lg" fontWeight="600" marginBottom={16}>
            Test Case Results
          </Text>

          <View
            {...DefaultAgentEvalStyles.testCaseList}
            {...views.testCaseList}
          >
            <Vertical gap={8}>
              {evaluation.testCases.map((testCase) => {
                const result = evaluation.results?.find(
                  (r) => r.testCaseId === testCase.id
                );
                const isSelected = selectedResult?.testCaseId === testCase.id;

                return (
                  <View
                    key={testCase.id}
                    {...DefaultAgentEvalStyles.testCaseItem}
                    {...views.testCaseItem}
                    onClick={() => result && onResultSelect(result)}
                    style={{
                      borderColor: isSelected ? '#3b82f6' : undefined,
                      backgroundColor: isSelected ? '#eff6ff' : undefined,
                    }}
                  >
                    <Vertical gap={8}>
                      {/* Test Case Header */}
                      <Horizontal
                        justifyContent="space-between"
                        alignItems="center"
                      >
                        <Horizontal gap={8} alignItems="center">
                          <Text fontSize="16px">
                            {result ? getStatusIcon(result.status) : '⏳'}
                          </Text>
                          <Text {...DefaultAgentEvalStyles.testCaseName}>
                            {testCase.name}
                          </Text>
                          {result && (
                            <Text {...getTestCaseStatusStyle(result.status)}>
                              {result.status}
                            </Text>
                          )}
                        </Horizontal>

                        <Horizontal gap={12} alignItems="center">
                          {result?.score !== undefined && (
                            <Text
                              fontSize="sm"
                              fontWeight="600"
                              color="color.gray.700"
                            >
                              Score: {result.score.toFixed(2)}
                            </Text>
                          )}
                          {result?.duration && (
                            <Text fontSize="sm" color="color.gray.600">
                              {formatDuration(result.duration)}
                            </Text>
                          )}
                        </Horizontal>
                      </Horizontal>

                      {/* Test Case Description */}
                      {testCase.description && (
                        <Text fontSize="sm" color="color.gray.600">
                          {testCase.description}
                        </Text>
                      )}

                      {/* Tags */}
                      {testCase.tags && testCase.tags.length > 0 && (
                        <Horizontal gap={4} flexWrap="wrap">
                          {testCase.tags.map((tag, index) => (
                            <View
                              key={index}
                              padding="2px 6px"
                              backgroundColor="color.blue.100"
                              borderRadius="4px"
                              border="1px solid"
                              borderColor="color.blue.200"
                            >
                              <Text fontSize="10px" color="color.blue.800">
                                {tag}
                              </Text>
                            </View>
                          ))}
                        </Horizontal>
                      )}

                      {/* Error Message */}
                      {result?.error && (
                        <View
                          padding={8}
                          backgroundColor="color.red.50"
                          borderRadius="4px"
                          border="1px solid"
                          borderColor="color.red.200"
                        >
                          <Text fontSize="sm" color="color.red.700">
                            Error: {result.error}
                          </Text>
                        </View>
                      )}

                      {/* Detailed Results (when selected) */}
                      {isSelected && result && showTestCaseDetails && (
                        <View
                          padding={12}
                          backgroundColor="color.gray.50"
                          borderRadius="6px"
                          marginTop={8}
                        >
                          <Vertical gap={12}>
                            <Text
                              fontSize="sm"
                              fontWeight="600"
                              color="color.gray.700"
                            >
                              Test Case Details
                            </Text>

                            {/* Input */}
                            <View>
                              <Text
                                fontSize="xs"
                                fontWeight="600"
                                color="color.gray.700"
                                marginBottom={4}
                              >
                                Input
                              </Text>
                              <View
                                padding={8}
                                backgroundColor="color.white"
                                borderRadius="4px"
                                border="1px solid"
                                borderColor="color.gray.200"
                              >
                                <Text
                                  fontSize="xs"
                                  fontFamily="Monaco, Consolas, monospace"
                                >
                                  {JSON.stringify(testCase.input, null, 2)}
                                </Text>
                              </View>
                            </View>

                            {/* Expected Output */}
                            {testCase.expectedOutput && (
                              <View>
                                <Text
                                  fontSize="xs"
                                  fontWeight="600"
                                  color="color.gray.700"
                                  marginBottom={4}
                                >
                                  Expected Output
                                </Text>
                                <View
                                  padding={8}
                                  backgroundColor="color.white"
                                  borderRadius="4px"
                                  border="1px solid"
                                  borderColor="color.gray.200"
                                >
                                  <Text
                                    fontSize="xs"
                                    fontFamily="Monaco, Consolas, monospace"
                                  >
                                    {JSON.stringify(
                                      testCase.expectedOutput,
                                      null,
                                      2
                                    )}
                                  </Text>
                                </View>
                              </View>
                            )}

                            {/* Actual Output */}
                            {result.actualOutput && (
                              <View>
                                <Text
                                  fontSize="xs"
                                  fontWeight="600"
                                  color="color.gray.700"
                                  marginBottom={4}
                                >
                                  Actual Output
                                </Text>
                                <View
                                  padding={8}
                                  backgroundColor="color.white"
                                  borderRadius="4px"
                                  border="1px solid"
                                  borderColor="color.gray.200"
                                >
                                  <Text
                                    fontSize="xs"
                                    fontFamily="Monaco, Consolas, monospace"
                                  >
                                    {JSON.stringify(
                                      result.actualOutput,
                                      null,
                                      2
                                    )}
                                  </Text>
                                </View>
                              </View>
                            )}

                            {/* Metrics */}
                            {Object.keys(result.metrics).length > 0 && (
                              <View>
                                <Text
                                  fontSize="xs"
                                  fontWeight="600"
                                  color="color.gray.700"
                                  marginBottom={4}
                                >
                                  Metrics
                                </Text>
                                <Horizontal gap={8} flexWrap="wrap">
                                  {Object.entries(result.metrics).map(
                                    ([metric, value]) => (
                                      <View
                                        key={metric}
                                        padding="4px 8px"
                                        backgroundColor="color.blue.50"
                                        borderRadius="4px"
                                        border="1px solid"
                                        borderColor="color.blue.200"
                                      >
                                        <Text
                                          fontSize="xs"
                                          color="color.blue.800"
                                        >
                                          {metric}: {value.toFixed(3)}
                                        </Text>
                                      </View>
                                    )
                                  )}
                                </Horizontal>
                              </View>
                            )}
                          </Vertical>
                        </View>
                      )}
                    </Vertical>
                  </View>
                );
              })}
            </Vertical>
          </View>
        </View>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentEval/AgentEval.tsx">
import React from 'react';
import { AgentEvalProps } from './AgentEval/AgentEval.props';
import AgentEvalView from './AgentEval/AgentEval.view';
import { useAgentEval } from './AgentEval/AgentEval.state';

/**
 * AgentEval Component
 *
 * A comprehensive evaluation component for ADK agents.
 * Handles evaluation creation, execution, monitoring, and results analysis.
 *
 * @example
 * ```tsx
 * <AgentEval
 *   appName="my-agent"
 *   userId="user123"
 *   onEvaluationComplete={(result) => console.log('Evaluation complete:', result)}
 * />
 * ```
 *
 * @example
 * ```tsx
 * // With custom evaluation configuration
 * <AgentEval
 *   appName="my-agent"
 *   userId="user123"
 *   enableBatchEvaluation={true}
 *   enableMetricsComparison={true}
 *   enableResultExport={true}
 *   maxConcurrentEvals={5}
 *   autoRefresh={true}
 *   refreshInterval={10000}
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     evaluationList: { maxHeight: '400px' },
 *     resultsPanel: { minHeight: '300px' }
 *   }}
 * />
 * ```
 */
const AgentEval: React.FC<AgentEvalProps> = (props) => {
  const evalState = useAgentEval(props);

  return <AgentEvalView {...props} {...evalState} />;
};

export default AgentEval;
export { AgentEval };
export type { AgentEvalProps };
</file>

<file path="src/components/adk/AgentSession/AgentSession/SessionActions.tsx">
import React from 'react';
import { View, Horizontal, Button } from 'app-studio';
import { AgentSession } from './AgentSession.props';
import { DefaultAgentSessionStyles } from './AgentSession.style';

export interface SessionActionsProps {
  enableImport?: boolean;
  enableExport?: boolean;
  selectedSession?: AgentSession | null;
  onImport: () => void;
  onExport: (sessionId: string) => void;
  views?: {
    container?: any;
    importButton?: any;
    exportButton?: any;
  };
}

/**
 * SessionActions Component
 *
 * Renders action buttons for session management (import, export, etc.)
 */
export const SessionActions: React.FC<SessionActionsProps> = ({
  enableImport = true,
  enableExport = true,
  selectedSession,
  onImport,
  onExport,
  views = {},
}) => {
  const handleExport = () => {
    if (selectedSession) {
      onExport(selectedSession.id);
    }
  };

  return (
    <View {...DefaultAgentSessionStyles.sessionActions} {...views.container}>
      <Horizontal gap={8} alignItems="center">
        {enableImport && (
          <Button
            {...DefaultAgentSessionStyles.importButton}
            {...views.importButton}
            onClick={onImport}
            aria-label="Import session from file"
            title="Import session from JSON file"
          >
            📥 Import
          </Button>
        )}

        {enableExport && (
          <Button
            {...DefaultAgentSessionStyles.exportButton}
            {...views.exportButton}
            onClick={handleExport}
            disabled={!selectedSession}
            aria-label="Export selected session"
            title="Export selected session to JSON file"
          >
            📤 Export
          </Button>
        )}
      </Horizontal>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/SessionFilters.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import {
  SessionFilters as SessionFiltersType,
  SessionSortOptions,
} from './AgentSession.props';
import { DefaultAgentSessionStyles } from './AgentSession.style';
import { Select, TextField } from '../../../Form/Form';

export interface SessionFiltersProps {
  filters: SessionFiltersType;
  sortOptions: SessionSortOptions;
  onFiltersChange: (filters: SessionFiltersType) => void;
  onSortChange: (sortOptions: SessionSortOptions) => void;
}

/**
 * SessionFilters Component
 *
 * Renders filter and sort controls for the session list
 */
export const SessionFilters: React.FC<SessionFiltersProps> = ({
  filters,
  sortOptions,
  onFiltersChange,
  onSortChange,
}) => {
  const handleSortFieldChange = (field: string) => {
    onSortChange({
      ...sortOptions,
      field: field as SessionSortOptions['field'],
    });
  };

  const handleSortDirectionChange = (direction: string) => {
    onSortChange({
      ...sortOptions,
      direction: direction as SessionSortOptions['direction'],
    });
  };

  const handleTagsChange = (tagsString: string) => {
    const tags = tagsString
      .split(',')
      .map((tag) => tag.trim())
      .filter((tag) => tag.length > 0);
    onFiltersChange({
      ...filters,
      tags: tags.length > 0 ? tags : undefined,
    });
  };

  const handleMessageCountMinChange = (value: string) => {
    const min = parseInt(value) || 0;
    onFiltersChange({
      ...filters,
      messageCountRange: {
        min,
        max: filters.messageCountRange?.max || 1000,
      },
    });
  };

  const handleMessageCountMaxChange = (value: string) => {
    const max = parseInt(value) || 1000;
    onFiltersChange({
      ...filters,
      messageCountRange: {
        min: filters.messageCountRange?.min || 0,
        max,
      },
    });
  };

  return (
    <View {...DefaultAgentSessionStyles.filterContainer}>
      <Vertical gap={12}>
        {/* Sort Options */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>Sort By</Text>
          <Horizontal gap={8}>
            <Select
              value={sortOptions.field}
              onChange={handleSortFieldChange}
              options={[
                { value: 'updatedAt', label: 'Last Updated' },
                { value: 'createdAt', label: 'Created Date' },
                { value: 'title', label: 'Title' },
                { value: 'messageCount', label: 'Message Count' },
              ]}
              placeholder="Sort field"
            />
            <Select
              value={sortOptions.direction}
              onChange={handleSortDirectionChange}
              options={[
                { value: 'desc', label: 'Descending' },
                { value: 'asc', label: 'Ascending' },
              ]}
              placeholder="Sort direction"
            />
          </Horizontal>
        </View>

        {/* Tag Filter */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>Filter by Tags</Text>
          <TextField
            placeholder="Enter tags separated by commas"
            value={filters.tags?.join(', ') || ''}
            onChange={handleTagsChange}
          />
        </View>

        {/* Message Count Range */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>
            Message Count Range
          </Text>
          <Horizontal gap={8} alignItems="center">
            <TextField
              placeholder="Min"
              type="number"
              value={filters.messageCountRange?.min?.toString() || ''}
              onChange={handleMessageCountMinChange}
              style={{ width: '80px' }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <TextField
              placeholder="Max"
              type="number"
              value={filters.messageCountRange?.max?.toString() || ''}
              onChange={handleMessageCountMaxChange}
              style={{ width: '80px' }}
            />
          </Horizontal>
        </View>

        {/* Date Range Filter */}
        <View {...DefaultAgentSessionStyles.filterGroup}>
          <Text {...DefaultAgentSessionStyles.filterLabel}>Date Range</Text>
          <Horizontal gap={8} alignItems="center">
            <input
              type="date"
              value={
                filters.dateRange?.start
                  ? filters.dateRange.start.toISOString().split('T')[0]
                  : ''
              }
              onChange={(e) => {
                const start = e.target.value
                  ? new Date(e.target.value)
                  : undefined;
                onFiltersChange({
                  ...filters,
                  dateRange: start
                    ? {
                        start,
                        end: filters.dateRange?.end || new Date(),
                      }
                    : undefined,
                });
              }}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <input
              type="date"
              value={
                filters.dateRange?.end
                  ? filters.dateRange.end.toISOString().split('T')[0]
                  : ''
              }
              onChange={(e) => {
                const end = e.target.value
                  ? new Date(e.target.value)
                  : undefined;
                onFiltersChange({
                  ...filters,
                  dateRange: end
                    ? {
                        start: filters.dateRange?.start || new Date(0),
                        end,
                      }
                    : undefined,
                });
              }}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </Horizontal>
        </View>

        {/* Clear Filters */}
        {(filters.tags || filters.dateRange || filters.messageCountRange) && (
          <Horizontal justifyContent="flex-end">
            <button
              onClick={() => onFiltersChange({})}
              style={{
                padding: '4px 8px',
                fontSize: '11px',
                color: '#6b7280',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                textDecoration: 'underline',
              }}
            >
              Clear all filters
            </button>
          </Horizontal>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/SessionListItem.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text, Button } from 'app-studio';
import { AgentSession } from './AgentSession.props';
import { DefaultAgentSessionStyles } from './AgentSession.style';

export interface SessionListItemProps {
  session: AgentSession;
  isSelected: boolean;
  compactMode?: boolean;
  showInfo?: boolean;
  enableDelete?: boolean;
  enableExport?: boolean;
  onSelect: () => void;
  onDelete: () => void;
  onExport: () => void;
  formatDate: (timestamp: number) => string;
  views?: {
    container?: any;
    info?: any;
    deleteButton?: any;
    exportButton?: any;
  };
}

/**
 * SessionListItem Component
 *
 * Renders individual session items in the session list
 */
export const SessionListItem: React.FC<SessionListItemProps> = ({
  session,
  isSelected,
  compactMode = false,
  showInfo = true,
  enableDelete = true,
  enableExport = true,
  onSelect,
  onDelete,
  onExport,
  formatDate,
  views = {},
}) => {
  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    onDelete();
  };

  const handleExport = (e: React.MouseEvent) => {
    e.stopPropagation();
    onExport();
  };

  const containerStyles = compactMode
    ? DefaultAgentSessionStyles.compactSessionItem
    : isSelected
    ? DefaultAgentSessionStyles.activeSessionItem
    : DefaultAgentSessionStyles.sessionItem;

  return (
    <View {...containerStyles} {...views.container} onClick={onSelect}>
      <Horizontal gap={12} alignItems="flex-start">
        {/* Status Indicator */}
        <View
          {...DefaultAgentSessionStyles.statusIndicator}
          {...DefaultAgentSessionStyles.activeStatus}
          marginTop="4px"
        />

        {/* Session Info */}
        <View {...DefaultAgentSessionStyles.sessionInfo} {...views.info}>
          <Vertical gap={compactMode ? 2 : 4}>
            {/* Title */}
            <Text {...DefaultAgentSessionStyles.sessionTitle}>
              {session.metadata?.title || `Session ${session.id.slice(0, 8)}`}
            </Text>

            {/* Description (if not compact) */}
            {!compactMode && session.metadata?.description && (
              <Text {...DefaultAgentSessionStyles.sessionDescription}>
                {session.metadata.description}
              </Text>
            )}

            {/* Tags */}
            {session.metadata?.tags && session.metadata.tags.length > 0 && (
              <View {...DefaultAgentSessionStyles.tagContainer}>
                {session.metadata.tags
                  .slice(0, compactMode ? 2 : 5)
                  .map((tag, index) => (
                    <View key={index} {...DefaultAgentSessionStyles.tag}>
                      <Text fontSize="10px">{tag}</Text>
                    </View>
                  ))}
                {session.metadata.tags.length > (compactMode ? 2 : 5) && (
                  <View {...DefaultAgentSessionStyles.tag}>
                    <Text fontSize="10px">
                      +{session.metadata.tags.length - (compactMode ? 2 : 5)}
                    </Text>
                  </View>
                )}
              </View>
            )}

            {/* Metadata */}
            {showInfo && (
              <Horizontal gap={16} alignItems="center">
                <Text {...DefaultAgentSessionStyles.sessionMeta}>
                  {formatDate(session.updatedAt)}
                </Text>
                {session.metadata?.messageCount !== undefined && (
                  <Text {...DefaultAgentSessionStyles.sessionMeta}>
                    {session.metadata.messageCount} message
                    {session.metadata.messageCount !== 1 ? 's' : ''}
                  </Text>
                )}
                <Text {...DefaultAgentSessionStyles.sessionMeta}>
                  ID: {session.id.slice(0, 8)}...
                </Text>
              </Horizontal>
            )}
          </Vertical>
        </View>

        {/* Actions */}
        <Horizontal gap={4} alignItems="center">
          {enableExport && (
            <Button
              {...DefaultAgentSessionStyles.exportButton}
              {...views.exportButton}
              onClick={handleExport}
              aria-label={`Export session ${session.id}`}
              title="Export session"
            >
              📤
            </Button>
          )}

          {enableDelete && (
            <Button
              {...DefaultAgentSessionStyles.deleteButton}
              {...views.deleteButton}
              onClick={handleDelete}
              aria-label={`Delete session ${session.id}`}
              title="Delete session"
            >
              🗑️
            </Button>
          )}
        </Horizontal>
      </Horizontal>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentSession/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text } from 'app-studio';
import { AgentSession } from '../AgentSession';
import { AgentSession as AgentSessionType } from '../AgentSession/AgentSession.props';

/**
 * Default AgentSession Example
 *
 * Demonstrates basic usage of the AgentSession component
 */
export const DefaultDemo = () => {
  const [selectedSession, setSelectedSession] =
    useState<AgentSessionType | null>(null);

  const handleSessionSelect = (session: AgentSessionType) => {
    console.log('Session selected:', session);
    setSelectedSession(session);
  };

  const handleSessionCreate = (session: AgentSessionType) => {
    console.log('Session created:', session);
    setSelectedSession(session);
  };

  const handleSessionDelete = (sessionId: string) => {
    console.log('Session deleted:', sessionId);
    if (selectedSession?.id === sessionId) {
      setSelectedSession(null);
    }
  };

  const handleError = (error: Error) => {
    console.error('AgentSession error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentSession Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A comprehensive session management interface for ADK agents. Handles
        session creation, listing, selection, deletion, and import/export.
      </Text>

      {/* Selected Session Info */}
      {selectedSession && (
        <View
          padding={16}
          backgroundColor="color.green.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.green.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.green.800">
            Selected Session
          </Text>
          <Text fontSize={12} color="color.green.600">
            ID: {selectedSession.id}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Title: {selectedSession.metadata?.title || 'Untitled'}
          </Text>
          <Text fontSize={12} color="color.green.600">
            Messages: {selectedSession.metadata?.messageCount || 0}
          </Text>
        </View>
      )}

      {/* AgentSession Component */}
      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentSession
          appName="demo-agent"
          userId="demo-user"
          apiBaseUrl="http://localhost:3000/adk"
          showSessionHistory={true}
          enableSessionImport={true}
          enableSessionExport={true}
          enableSessionDelete={true}
          enableSessionSearch={true}
          showSessionInfo={true}
          showSessionActions={true}
          showCreateButton={true}
          showRefreshButton={true}
          maxSessions={50}
          enableAutoRefresh={false}
          onSessionSelect={handleSessionSelect}
          onSessionCreate={handleSessionCreate}
          onSessionDelete={handleSessionDelete}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
            sessionList: {
              backgroundColor: 'color.gray.100',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Compact AgentSession Example
 *
 * Shows the component in compact mode
 */
export const CompactDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Compact AgentSession Example
      </Text>

      <View
        height="300px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentSession
          appName="compact-agent"
          userId="user123"
          compactMode={true}
          showSessionInfo={false}
          enableSessionSearch={false}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentSession Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentSession Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.purple.200"
        borderRadius="12px"
      >
        <AgentSession
          appName="custom-agent"
          userId="user123"
          enableSessionTags={true}
          enableSessionMetadata={true}
          maxSessions={25}
          views={{
            container: {
              backgroundColor: 'color.purple.25',
              height: '100%',
            },
            header: {
              backgroundColor: 'color.purple.500',
              color: 'white',
            },
            sessionList: {
              backgroundColor: 'color.white',
            },
            activeSessionItem: {
              backgroundColor: 'color.purple.100',
              borderColor: 'color.purple.500',
            },
            sessionActions: {
              backgroundColor: 'color.purple.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Enhanced Customization Example
 *
 * Shows comprehensive customization using enhanced views prop and container props
 */
export const EnhancedCustomizationDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Enhanced AgentSession Customization
      </Text>

      <Text color="color.gray.600" fontSize={14}>
        Demonstrates comprehensive customization using the enhanced views prop
        and container props for complete control over session management UI.
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.green.200"
        borderRadius="12px"
      >
        <AgentSession
          appName="enhanced-agent"
          userId="user123"
          showSessionHistory={true}
          enableSessionImport={true}
          enableSessionExport={true}
          enableSessionDelete={true}
          enableSessionSearch={true}
          enableBulkOperations={true}
          enableSessionTags={true}
          enableSessionMetadata={true}
          compactMode={false}
          colorScheme="green"
          layout="list"
          showPreviews={true}
          containerProps={{
            backgroundColor: 'color.green.25',
            border: '2px solid',
            borderColor: 'color.green.300',
          }}
          views={{
            // Main areas
            container: {
              backgroundColor: 'color.green.25',
            },
            header: {
              backgroundColor: 'color.green.500',
              color: 'white',
              padding: '16px',
              borderRadius: '12px 12px 0 0',
            },
            toolbar: {
              backgroundColor: 'color.green.50',
              padding: '12px',
              borderBottom: '1px solid',
              borderBottomColor: 'color.green.200',
            },
            sessionList: {
              backgroundColor: 'color.white',
              padding: '16px',
            },

            // Session items
            sessionItem: {
              backgroundColor: 'color.green.50',
              borderRadius: '8px',
              margin: '4px 0',
              padding: '12px',
              border: '1px solid',
              borderColor: 'color.green.200',
            },
            activeSessionItem: {
              backgroundColor: 'color.green.100',
              borderColor: 'color.green.500',
              borderWidth: '2px',
            },
            sessionTitle: {
              fontWeight: '600',
              color: 'color.green.900',
              fontSize: '16px',
            },
            sessionDescription: {
              color: 'color.green.700',
              fontSize: '14px',
            },
            sessionTimestamp: {
              color: 'color.green.600',
              fontSize: '12px',
            },
            sessionStats: {
              backgroundColor: 'color.green.100',
              borderRadius: '4px',
              padding: '4px 8px',
              fontSize: '12px',
              color: 'color.green.800',
            },

            // Action buttons
            createButton: {
              backgroundColor: 'color.green.500',
              color: 'white',
              borderRadius: '8px',
              padding: '8px 16px',
              fontWeight: '600',
            },
            deleteButton: {
              backgroundColor: 'color.red.500',
              color: 'white',
              borderRadius: '6px',
              padding: '6px 12px',
            },
            exportButton: {
              backgroundColor: 'color.blue.500',
              color: 'white',
              borderRadius: '6px',
              padding: '6px 12px',
            },

            // Search and filters
            searchInput: {
              borderRadius: '20px',
              border: '2px solid',
              borderColor: 'color.green.200',
              backgroundColor: 'white',
              padding: '8px 16px',
            },

            // State displays
            emptyState: {
              textAlign: 'center',
              padding: '40px',
              color: 'color.green.600',
            },
            loadingState: {
              textAlign: 'center',
              padding: '40px',
              color: 'color.green.500',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Session with Mock Data Example
 *
 * Demonstrates the component with initial session data
 */
export const MockDataDemo = () => {
  const mockSessions: AgentSessionType[] = [
    {
      id: 'session-1',
      userId: 'user123',
      appName: 'demo-agent',
      state: {},
      events: [],
      createdAt: Date.now() - 86400000, // 1 day ago
      updatedAt: Date.now() - 3600000, // 1 hour ago
      metadata: {
        title: 'Customer Support Chat',
        description: 'Helping customer with product questions',
        tags: ['support', 'product', 'urgent'],
        messageCount: 15,
        lastActivity: Date.now() - 3600000,
      },
    },
    {
      id: 'session-2',
      userId: 'user123',
      appName: 'demo-agent',
      state: {},
      events: [],
      createdAt: Date.now() - 172800000, // 2 days ago
      updatedAt: Date.now() - 7200000, // 2 hours ago
      metadata: {
        title: 'Code Review Assistant',
        description: 'Reviewing pull request and suggesting improvements',
        tags: ['code-review', 'development'],
        messageCount: 8,
        lastActivity: Date.now() - 7200000,
      },
    },
    {
      id: 'session-3',
      userId: 'user123',
      appName: 'demo-agent',
      state: {},
      events: [],
      createdAt: Date.now() - 259200000, // 3 days ago
      updatedAt: Date.now() - 10800000, // 3 hours ago
      metadata: {
        title: 'Data Analysis Session',
        description: 'Analyzing sales data and generating insights',
        tags: ['analytics', 'data', 'sales'],
        messageCount: 23,
        lastActivity: Date.now() - 10800000,
      },
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentSession with Mock Data
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentSession
          appName="demo-agent"
          userId="user123"
          initialSessions={mockSessions}
          selectedSessionId="session-1"
          enableSessionSearch={true}
          enableSessionTags={true}
          defaultSort={{ field: 'updatedAt', direction: 'desc' }}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Session Management Features Example
 *
 * Demonstrates import/export and advanced features
 */
export const FeaturesDemo = () => {
  const [importedSessions, setImportedSessions] = useState<AgentSessionType[]>(
    []
  );

  const handleSessionImport = (session: AgentSessionType) => {
    console.log('Session imported:', session);
    setImportedSessions((prev) => [...prev, session]);
  };

  const handleSessionExport = (session: AgentSessionType) => {
    console.log('Session exported:', session);
  };

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentSession Management Features
      </Text>

      {importedSessions.length > 0 && (
        <View
          padding={12}
          backgroundColor="color.blue.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.blue.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.blue.800">
            Imported Sessions ({importedSessions.length})
          </Text>
          {importedSessions.map((session) => (
            <Text key={session.id} fontSize={12} color="color.blue.600">
              • {session.metadata?.title || session.id}
            </Text>
          ))}
        </View>
      )}

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentSession
          appName="features-agent"
          userId="user123"
          enableSessionImport={true}
          enableSessionExport={true}
          enableSessionDelete={true}
          enableBulkOperations={true}
          onSessionImport={handleSessionImport}
          onSessionExport={handleSessionExport}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession.tsx">
import React from 'react';
import { AgentSessionProps } from './AgentSession/AgentSession.props';
import AgentSessionView from './AgentSession/AgentSession.view';
import { useAgentSession } from './AgentSession/AgentSession.state';

/**
 * AgentSession Component
 *
 * A comprehensive session management component for ADK agents.
 * Handles session creation, listing, selection, deletion, and state management.
 *
 * @example
 * ```tsx
 * <AgentSession
 *   appName="my-agent"
 *   userId="user123"
 *   onSessionSelect={(session) => console.log('Selected:', session)}
 *   onSessionCreate={(session) => console.log('Created:', session)}
 * />
 * ```
 *
 * @example
 * ```tsx
 * // With custom styling and features
 * <AgentSession
 *   appName="my-agent"
 *   userId="user123"
 *   showSessionHistory={true}
 *   enableSessionImport={true}
 *   enableSessionExport={true}
 *   maxSessions={50}
 *   autoRefresh={true}
 *   refreshInterval={30000}
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     sessionList: { maxHeight: '400px' },
 *     sessionItem: { borderRadius: '8px' }
 *   }}
 * />
 * ```
 */
const AgentSession: React.FC<AgentSessionProps> = (props) => {
  const sessionState = useAgentSession(props);

  return <AgentSessionView {...props} {...sessionState} />;
};

export default AgentSession;
export { AgentSession };
export type { AgentSessionProps };
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Trace Types
 */
export interface TraceEvent {
  id: string;
  sessionId: string;
  type:
    | 'llm_request'
    | 'llm_response'
    | 'function_call'
    | 'function_response'
    | 'user_input'
    | 'agent_output'
    | 'error'
    | 'system';
  timestamp: number;
  duration?: number;
  data: any;
  metadata?: {
    title?: string;
    description?: string;
    level?: 'info' | 'warning' | 'error' | 'debug';
    tags?: string[];
  };
  parentId?: string;
  children?: TraceEvent[];
  attributes?: Record<string, any>;
}

export interface TraceSpan {
  id: string;
  name: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  status: 'running' | 'completed' | 'error' | 'cancelled';
  events: TraceEvent[];
  attributes: Record<string, any>;
  parentId?: string;
  children?: TraceSpan[];
}

export interface TraceMetrics {
  totalEvents: number;
  totalDuration: number;
  averageResponseTime: number;
  errorCount: number;
  successCount: number;
  functionCallCount: number;
  llmRequestCount: number;
  eventsByType: Record<string, number>;
  performanceMetrics: {
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
}

export interface TraceFilter {
  eventTypes?: string[];
  timeRange?: {
    start: Date;
    end: Date;
  };
  searchQuery?: string;
  level?: ('info' | 'warning' | 'error' | 'debug')[];
  tags?: string[];
  minDuration?: number;
  maxDuration?: number;
}

/**
 * Component View Customization
 */
export interface AgentTraceViews {
  // Main container areas
  container?: ViewProps;
  header?: ViewProps;
  toolbar?: ViewProps;
  timeline?: ViewProps;
  eventList?: ViewProps;
  detailsPanel?: ViewProps;
  metricsPanel?: ViewProps;
  filtersPanel?: ViewProps;

  // Event components
  eventItem?: ViewProps;
  selectedEventItem?: ViewProps;
  eventHeader?: ViewProps;
  eventContent?: ViewProps;
  eventMetadata?: ViewProps;
  eventTimestamp?: ViewProps;
  eventDuration?: ViewProps;
  eventType?: ViewProps;
  eventLevel?: ViewProps;
  eventTags?: ViewProps;

  // Timeline components
  timelineContainer?: ViewProps;
  timelineAxis?: ViewProps;
  timelineEvent?: ViewProps;
  timelineSpan?: ViewProps;
  timelineMarker?: ViewProps;

  // Metrics components
  metricsCard?: ViewProps;
  performanceChart?: ViewProps;
  errorRateChart?: ViewProps;
  latencyChart?: ViewProps;
  throughputChart?: ViewProps;

  // Visualization components
  visualization?: ViewProps;
  flowDiagram?: ViewProps;
  dependencyGraph?: ViewProps;
  heatmap?: ViewProps;

  // Filter components
  searchInput?: ViewProps;
  typeFilter?: ViewProps;
  levelFilter?: ViewProps;
  timeRangeFilter?: ViewProps;
  tagFilter?: ViewProps;
  durationFilter?: ViewProps;

  // Action buttons
  exportButton?: ViewProps;
  refreshButton?: ViewProps;
  clearButton?: ViewProps;
  expandAllButton?: ViewProps;
  collapseAllButton?: ViewProps;

  // State displays
  emptyState?: ViewProps;
  loadingState?: ViewProps;
  errorState?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentTraceEventHandlers {
  onEventSelect?: (event: TraceEvent) => void;
  onSpanSelect?: (span: TraceSpan) => void;
  onFilterChange?: (filter: TraceFilter) => void;
  onExport?: (format: 'json' | 'csv' | 'svg') => void;
  onRefresh?: () => void;
  onError?: (error: Error) => void;
}

/**
 * Visualization Options
 */
export type VisualizationType =
  | 'timeline'
  | 'tree'
  | 'graph'
  | 'table'
  | 'flamegraph';

export interface VisualizationConfig {
  type: VisualizationType;
  showDuration?: boolean;
  showMetadata?: boolean;
  groupBy?: 'type' | 'level' | 'parent' | 'none';
  sortBy?: 'timestamp' | 'duration' | 'type' | 'name';
  sortDirection?: 'asc' | 'desc';
  maxDepth?: number;
  collapsible?: boolean;
}

/**
 * Main AgentTrace Props Interface
 */
export interface AgentTraceProps extends ViewProps, AgentTraceEventHandlers {
  // Required props
  sessionId: string;
  userId: string;
  appName: string;

  // Optional configuration
  apiBaseUrl?: string;

  // Feature toggles
  showTimeline?: boolean;
  showMetrics?: boolean;
  showVisualization?: boolean;
  enableFiltering?: boolean;
  enableExport?: boolean;
  enableSearch?: boolean;
  enableAutoRefresh?: boolean;

  // Visualization options
  visualizationType?: VisualizationType;
  visualizationConfig?: VisualizationConfig;

  // Limits and constraints
  maxEvents?: number;
  refreshInterval?: number; // in milliseconds

  // UI customization
  showEventDetails?: boolean;
  showPerformanceMetrics?: boolean;
  compactMode?: boolean;

  // Styling and customization
  views?: AgentTraceViews;
  containerProps?: ViewProps;

  // Initial state
  initialEvents?: TraceEvent[];
  initialFilter?: TraceFilter;
  selectedEventId?: string;

  // Advanced features
  enableRealTimeUpdates?: boolean;
  enableEventGrouping?: boolean;
  enableSpanVisualization?: boolean;

  // Theme and appearance
  colorScheme?: 'blue' | 'purple' | 'green' | 'orange' | 'red' | 'gray';
  layout?: 'timeline' | 'tree' | 'table' | 'graph';
  showMinimap?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

/**
 * Export Formats
 */
export interface TraceExportOptions {
  format: 'json' | 'csv' | 'svg' | 'png';
  includeMetadata?: boolean;
  includeMetrics?: boolean;
  timeRange?: {
    start: Date;
    end: Date;
  };
  eventTypes?: string[];
}

/**
 * Real-time Update Types
 */
export interface TraceUpdate {
  type: 'event_added' | 'event_updated' | 'span_completed' | 'metrics_updated';
  data: TraceEvent | TraceSpan | TraceMetrics;
  timestamp: number;
}
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/AgentTrace.view.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { AgentTraceProps } from './AgentTrace.props';
import { useAgentTrace } from './AgentTrace.state';
import { DefaultAgentTraceStyles } from './AgentTrace.style';
import { TraceTimeline } from './TraceTimeline';
import { TraceEventList } from './TraceEventList';
import { TraceMetrics } from './TraceMetrics';
import { TraceFilters } from './TraceFilters';
import { TraceVisualization } from './TraceVisualization';
import { Alert } from '../../../Alert/Alert';
import { Tabs } from '../../../Tabs/Tabs';
import { Loader } from '../../../Loader/Loader';
import { TextField } from '../../../Form/Form';

export interface AgentTraceViewProps
  extends Omit<AgentTraceProps, 'filter'>,
    ReturnType<typeof useAgentTrace> {}

/**
 * AgentTrace View Component
 *
 * Renders the complete trace visualization interface with timeline, events, and metrics
 */
const AgentTraceView: React.FC<AgentTraceViewProps> = ({
  // Props
  showTimeline = true,
  showMetrics = true,
  showVisualization = true,
  enableFiltering = true,
  enableExport = true,
  enableSearch = true,
  showEventDetails = true,
  showPerformanceMetrics = true,
  compactMode = false,
  views,
  ariaLabel = 'Agent Trace Visualization',
  ariaDescribedBy,

  // State from hook
  events,
  spans,
  selectedEvent,
  selectedSpan,
  metrics,
  isLoading,
  error,
  filter,
  searchQuery,
  currentVisualization,
  fetchTraceEvents,
  selectEvent,
  selectSpan,
  updateFilter,
  exportTrace,
  setSearchQuery,
  setCurrentVisualization,
  setError,

  ...props
}) => {
  /**
   * Handle event selection
   */
  const handleEventSelect = (eventId: string) => {
    selectEvent(eventId);
  };

  /**
   * Handle span selection
   */
  const handleSpanSelect = (spanId: string) => {
    selectSpan(spanId);
  };

  /**
   * Handle export
   */
  const handleExport = (format: 'json' | 'csv' | 'svg') => {
    exportTrace({
      format,
      includeMetadata: true,
      includeMetrics: true,
    });
  };

  /**
   * Handle refresh
   */
  const handleRefresh = () => {
    fetchTraceEvents();
  };

  return (
    <View
      {...DefaultAgentTraceStyles.container}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentTraceStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Trace
            </Text>
            <Text fontSize="sm" color="color.gray.600">
              {events.length} event{events.length !== 1 ? 's' : ''} • Session:{' '}
              {props.sessionId.slice(0, 8)}...
            </Text>
          </Vertical>

          <Horizontal gap={8}>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              disabled={isLoading}
              aria-label="Refresh trace data"
            >
              {isLoading ? <Loader size="xs" /> : '🔄'}
            </Button>

            {enableExport && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleExport('json')}
                aria-label="Export trace data"
              >
                📤 Export
              </Button>
            )}
          </Horizontal>
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Alert variant="error" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {/* Search and Filters */}
      {enableSearch && (
        <View
          padding={16}
          borderBottom="1px solid"
          borderBottomColor="color.gray.200"
        >
          <Vertical gap={12}>
            <TextField
              placeholder="Search events..."
              value={searchQuery}
              onChange={setSearchQuery}
              views={{
                container: views?.searchInput,
              }}
            />

            {enableFiltering && (
              <TraceFilters
                filter={filter}
                onFilterChange={updateFilter}
                eventTypes={Array.from(new Set(events.map((e) => e.type)))}
              />
            )}
          </Vertical>
        </View>
      )}

      {/* Metrics */}
      {showMetrics && metrics && (
        <TraceMetrics
          metrics={metrics}
          showPerformanceMetrics={showPerformanceMetrics}
          compactMode={compactMode}
          views={{
            container: views?.metrics,
          }}
        />
      )}

      {/* Main Content */}
      <View flex={1} display="flex" flexDirection="column">
        {compactMode ? (
          // Compact mode - single view
          <TraceEventList
            events={events}
            selectedEvent={selectedEvent}
            onEventSelect={handleEventSelect}
            showDetails={showEventDetails}
            compactMode={true}
            views={{
              container: views?.eventList,
              eventItem: views?.eventItem,
              selectedEventItem: views?.selectedEventItem,
            }}
          />
        ) : (
          // Full mode - tabbed interface
          <Tabs defaultValue="timeline">
            <Tabs.List>
              {showTimeline && (
                <Tabs.Trigger value="timeline">Timeline</Tabs.Trigger>
              )}
              <Tabs.Trigger value="events">Events</Tabs.Trigger>
              {showVisualization && (
                <Tabs.Trigger value="visualization">Visualization</Tabs.Trigger>
              )}
            </Tabs.List>

            {showTimeline && (
              <Tabs.Content value="timeline">
                <TraceTimeline
                  events={events}
                  spans={spans}
                  selectedEvent={selectedEvent}
                  selectedSpan={selectedSpan}
                  onEventSelect={handleEventSelect}
                  onSpanSelect={handleSpanSelect}
                  views={{
                    container: views?.timeline,
                  }}
                />
              </Tabs.Content>
            )}

            <Tabs.Content value="events">
              <TraceEventList
                events={events}
                selectedEvent={selectedEvent}
                onEventSelect={handleEventSelect}
                showDetails={showEventDetails}
                compactMode={false}
                views={{
                  container: views?.eventList,
                  eventItem: views?.eventItem,
                  selectedEventItem: views?.selectedEventItem,
                }}
              />
            </Tabs.Content>

            {showVisualization && (
              <Tabs.Content value="visualization">
                <TraceVisualization
                  events={events}
                  spans={spans}
                  selectedEvent={selectedEvent}
                  visualizationType={currentVisualization}
                  onVisualizationChange={setCurrentVisualization}
                  onEventSelect={handleEventSelect}
                  views={{
                    container: views?.visualization,
                  }}
                />
              </Tabs.Content>
            )}
          </Tabs>
        )}
      </View>

      {/* Loading State */}
      {isLoading && events.length === 0 && (
        <View
          {...DefaultAgentTraceStyles.loadingState}
          {...views?.loadingState}
        >
          <Loader size="md" />
          <Text color="color.gray.600">Loading trace data...</Text>
        </View>
      )}

      {/* Empty State */}
      {!isLoading && events.length === 0 && (
        <View {...DefaultAgentTraceStyles.emptyState} {...views?.emptyState}>
          <Text fontSize="lg" color="color.gray.500" textAlign="center">
            No trace events found
          </Text>
          <Text fontSize="sm" color="color.gray.400" textAlign="center">
            Start interacting with the agent to see trace data
          </Text>
        </View>
      )}
    </View>
  );
};

export default AgentTraceView;
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceFilters.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { TraceFilter } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';
import { Checkbox, TextField } from '../../../Form/Form';

export interface TraceFiltersProps {
  filter: TraceFilter;
  onFilterChange: (filter: TraceFilter) => void;
  eventTypes: string[];
}

/**
 * TraceFilters Component
 *
 * Renders filter controls for trace events
 */
export const TraceFilters: React.FC<TraceFiltersProps> = ({
  filter,
  onFilterChange,
  eventTypes,
}) => {
  const handleEventTypesChange = (selectedTypes: string[]) => {
    onFilterChange({
      ...filter,
      eventTypes: selectedTypes.length > 0 ? selectedTypes : undefined,
    });
  };

  const handleLevelChange = (selectedLevels: string[]) => {
    onFilterChange({
      ...filter,
      level: selectedLevels.length > 0 ? (selectedLevels as any) : undefined,
    });
  };

  const handleMinDurationChange = (value: string) => {
    const minDuration = parseFloat(value) || undefined;
    onFilterChange({
      ...filter,
      minDuration,
    });
  };

  const handleMaxDurationChange = (value: string) => {
    const maxDuration = parseFloat(value) || undefined;
    onFilterChange({
      ...filter,
      maxDuration,
    });
  };

  const handleTagsChange = (tagsString: string) => {
    const tags = tagsString
      .split(',')
      .map((tag) => tag.trim())
      .filter((tag) => tag.length > 0);
    onFilterChange({
      ...filter,
      tags: tags.length > 0 ? tags : undefined,
    });
  };

  const handleTimeRangeStartChange = (value: string) => {
    const start = value ? new Date(value) : undefined;
    onFilterChange({
      ...filter,
      timeRange: start
        ? {
            start,
            end: filter.timeRange?.end || new Date(),
          }
        : undefined,
    });
  };

  const handleTimeRangeEndChange = (value: string) => {
    const end = value ? new Date(value) : undefined;
    onFilterChange({
      ...filter,
      timeRange: end
        ? {
            start: filter.timeRange?.start || new Date(0),
            end,
          }
        : undefined,
    });
  };

  return (
    <View {...DefaultAgentTraceStyles.filters}>
      <Vertical gap={12}>
        {/* Event Types Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Event Types</Text>
          <Horizontal gap={8} flexWrap="wrap">
            {eventTypes.map((type) => (
              <Checkbox
                key={type}
                checked={filter.eventTypes?.includes(type) || false}
                onChange={(checked) => {
                  const currentTypes = filter.eventTypes || [];
                  const newTypes = checked
                    ? [...currentTypes, type]
                    : currentTypes.filter((t) => t !== type);
                  handleEventTypesChange(newTypes);
                }}
                label={type.replace('_', ' ')}
              />
            ))}
          </Horizontal>
        </View>

        {/* Level Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Log Levels</Text>
          <Horizontal gap={8}>
            {['info', 'warning', 'error', 'debug'].map((level) => (
              <Checkbox
                key={level}
                checked={filter.level?.includes(level as any) || false}
                onChange={(checked) => {
                  const currentLevels = filter.level || [];
                  const newLevels = checked
                    ? [...currentLevels, level]
                    : currentLevels.filter((l) => l !== level);
                  handleLevelChange(newLevels);
                }}
                label={level}
              />
            ))}
          </Horizontal>
        </View>

        {/* Duration Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>
            Duration Range (ms)
          </Text>
          <Horizontal gap={8} alignItems="center">
            <TextField
              placeholder="Min"
              type="number"
              value={filter.minDuration?.toString() || ''}
              onChange={handleMinDurationChange}
              style={{ width: '100px' }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <TextField
              placeholder="Max"
              type="number"
              value={filter.maxDuration?.toString() || ''}
              onChange={handleMaxDurationChange}
              style={{ width: '100px' }}
            />
          </Horizontal>
        </View>

        {/* Tags Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Filter by Tags</Text>
          <TextField
            placeholder="Enter tags separated by commas"
            value={filter.tags?.join(', ') || ''}
            onChange={handleTagsChange}
          />
        </View>

        {/* Time Range Filter */}
        <View {...DefaultAgentTraceStyles.filterGroup}>
          <Text {...DefaultAgentTraceStyles.filterLabel}>Time Range</Text>
          <Horizontal gap={8} alignItems="center">
            <input
              type="datetime-local"
              value={
                filter.timeRange?.start
                  ? new Date(
                      filter.timeRange.start.getTime() -
                        filter.timeRange.start.getTimezoneOffset() * 60000
                    )
                      .toISOString()
                      .slice(0, 16)
                  : ''
              }
              onChange={(e) => handleTimeRangeStartChange(e.target.value)}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
            <Text fontSize="sm" color="color.gray.600">
              to
            </Text>
            <input
              type="datetime-local"
              value={
                filter.timeRange?.end
                  ? new Date(
                      filter.timeRange.end.getTime() -
                        filter.timeRange.end.getTimezoneOffset() * 60000
                    )
                      .toISOString()
                      .slice(0, 16)
                  : ''
              }
              onChange={(e) => handleTimeRangeEndChange(e.target.value)}
              style={{
                padding: '6px 8px',
                border: '1px solid #d1d5db',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </Horizontal>
        </View>

        {/* Clear Filters */}
        {(filter.eventTypes ||
          filter.level ||
          filter.timeRange ||
          filter.tags ||
          filter.minDuration !== undefined ||
          filter.maxDuration !== undefined) && (
          <Horizontal justifyContent="flex-end">
            <button
              onClick={() => onFilterChange({})}
              style={{
                padding: '4px 8px',
                fontSize: '11px',
                color: '#6b7280',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                textDecoration: 'underline',
              }}
            >
              Clear all filters
            </button>
          </Horizontal>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceMetrics.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { TraceMetrics as TraceMetricsType } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';

export interface TraceMetricsProps {
  metrics: TraceMetricsType;
  showPerformanceMetrics?: boolean;
  compactMode?: boolean;
  views?: {
    container?: any;
  };
}

/**
 * TraceMetrics Component
 *
 * Displays performance metrics and statistics for trace events
 */
export const TraceMetrics: React.FC<TraceMetricsProps> = ({
  metrics,
  showPerformanceMetrics = true,
  compactMode = false,
  views = {},
}) => {
  /**
   * Format duration
   */
  const formatDuration = (duration: number) => {
    if (duration < 1000) return `${duration.toFixed(1)}ms`;
    return `${(duration / 1000).toFixed(2)}s`;
  };

  /**
   * Format percentage
   */
  const formatPercentage = (value: number, total: number) => {
    if (total === 0) return '0%';
    return `${((value / total) * 100).toFixed(1)}%`;
  };

  /**
   * Get success rate color
   */
  const getSuccessRateColor = (successCount: number, totalCount: number) => {
    const rate = totalCount > 0 ? (successCount / totalCount) * 100 : 0;
    if (rate >= 95) return 'color.green.600';
    if (rate >= 80) return 'color.yellow.600';
    return 'color.red.600';
  };

  return (
    <View {...DefaultAgentTraceStyles.metrics} {...views.container}>
      <Vertical gap={compactMode ? 12 : 16}>
        {/* Main Metrics */}
        <View {...DefaultAgentTraceStyles.metricsGrid}>
          {/* Total Events */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text {...DefaultAgentTraceStyles.metricValue}>
              {metrics.totalEvents.toLocaleString()}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>Total Events</Text>
          </View>

          {/* Success Rate */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text
              {...DefaultAgentTraceStyles.metricValue}
              color={getSuccessRateColor(
                metrics.successCount,
                metrics.totalEvents
              )}
            >
              {formatPercentage(metrics.successCount, metrics.totalEvents)}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>Success Rate</Text>
          </View>

          {/* Average Response Time */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text {...DefaultAgentTraceStyles.metricValue}>
              {formatDuration(metrics.averageResponseTime)}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>Avg Response</Text>
          </View>

          {/* Total Duration */}
          <View {...DefaultAgentTraceStyles.metricCard}>
            <Text {...DefaultAgentTraceStyles.metricValue}>
              {formatDuration(metrics.totalDuration)}
            </Text>
            <Text {...DefaultAgentTraceStyles.metricLabel}>Total Duration</Text>
          </View>

          {/* Error Count */}
          {metrics.errorCount > 0 && (
            <View {...DefaultAgentTraceStyles.metricCard}>
              <Text
                {...DefaultAgentTraceStyles.metricValue}
                color="color.red.600"
              >
                {metrics.errorCount}
              </Text>
              <Text {...DefaultAgentTraceStyles.metricLabel}>Errors</Text>
            </View>
          )}

          {/* Function Calls */}
          {metrics.functionCallCount > 0 && (
            <View {...DefaultAgentTraceStyles.metricCard}>
              <Text {...DefaultAgentTraceStyles.metricValue}>
                {metrics.functionCallCount}
              </Text>
              <Text {...DefaultAgentTraceStyles.metricLabel}>
                Function Calls
              </Text>
            </View>
          )}

          {/* LLM Requests */}
          {metrics.llmRequestCount > 0 && (
            <View {...DefaultAgentTraceStyles.metricCard}>
              <Text {...DefaultAgentTraceStyles.metricValue}>
                {metrics.llmRequestCount}
              </Text>
              <Text {...DefaultAgentTraceStyles.metricLabel}>LLM Requests</Text>
            </View>
          )}
        </View>

        {/* Performance Metrics */}
        {showPerformanceMetrics && !compactMode && (
          <View>
            <Text
              fontSize="sm"
              fontWeight="600"
              color="color.gray.700"
              marginBottom={12}
            >
              Response Time Percentiles
            </Text>
            <Horizontal gap={16}>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p50)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>P50</Text>
              </View>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p90)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>P90</Text>
              </View>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p95)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>P95</Text>
              </View>
              <View {...DefaultAgentTraceStyles.metricCard} flex={1}>
                <Text {...DefaultAgentTraceStyles.metricValue} fontSize="16px">
                  {formatDuration(metrics.performanceMetrics.p99)}
                </Text>
                <Text {...DefaultAgentTraceStyles.metricLabel}>P99</Text>
              </View>
            </Horizontal>
          </View>
        )}

        {/* Event Type Breakdown */}
        {!compactMode && Object.keys(metrics.eventsByType).length > 0 && (
          <View>
            <Text
              fontSize="sm"
              fontWeight="600"
              color="color.gray.700"
              marginBottom={12}
            >
              Events by Type
            </Text>
            <Horizontal gap={8} flexWrap="wrap">
              {Object.entries(metrics.eventsByType).map(([type, count]) => (
                <View
                  key={type}
                  padding="6px 12px"
                  backgroundColor="color.blue.50"
                  borderRadius="6px"
                  border="1px solid"
                  borderColor="color.blue.200"
                >
                  <Horizontal gap={8} alignItems="center">
                    <Text fontSize="sm" fontWeight="600" color="color.blue.800">
                      {type.replace('_', ' ')}
                    </Text>
                    <Text fontSize="sm" color="color.blue.600">
                      {count}
                    </Text>
                    <Text fontSize="xs" color="color.blue.500">
                      ({formatPercentage(count, metrics.totalEvents)})
                    </Text>
                  </Horizontal>
                </View>
              ))}
            </Horizontal>
          </View>
        )}
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace/TraceVisualization.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { TraceEvent, TraceSpan, VisualizationType } from './AgentTrace.props';
import { DefaultAgentTraceStyles } from './AgentTrace.style';
import { Select } from '../../../Form/Form';

export interface TraceVisualizationProps {
  events: TraceEvent[];
  spans: TraceSpan[];
  selectedEvent?: TraceEvent | null;
  visualizationType: VisualizationType;
  onVisualizationChange: (type: VisualizationType) => void;
  onEventSelect: (eventId: string) => void;
  views?: {
    container?: any;
  };
}

/**
 * TraceVisualization Component
 *
 * Renders different visualization types for trace data
 */
export const TraceVisualization: React.FC<TraceVisualizationProps> = ({
  events,
  spans,
  selectedEvent,
  visualizationType,
  onVisualizationChange,
  onEventSelect,
  views = {},
}) => {
  /**
   * Build tree structure from events
   */
  const buildEventTree = () => {
    const eventMap = new Map(
      events.map((e) => [e.id, { ...e, children: [] as TraceEvent[] }])
    );
    const roots: TraceEvent[] = [];

    events.forEach((event) => {
      const eventWithChildren = eventMap.get(event.id)!;
      if (event.parentId && eventMap.has(event.parentId)) {
        eventMap.get(event.parentId)!.children.push(eventWithChildren);
      } else {
        roots.push(eventWithChildren);
      }
    });

    return roots;
  };

  /**
   * Render tree visualization
   */
  const renderTreeVisualization = () => {
    const tree = buildEventTree();

    const renderTreeNode = (event: TraceEvent, depth = 0) => {
      const isSelected = selectedEvent?.id === event.id;
      const indent = depth * 20;

      return (
        <View key={event.id}>
          <View
            padding="8px"
            marginLeft={`${indent}px`}
            backgroundColor={isSelected ? 'color.blue.50' : 'color.white'}
            border={isSelected ? '1px solid' : 'none'}
            borderColor={isSelected ? 'color.blue.300' : 'transparent'}
            borderRadius="4px"
            cursor="pointer"
            onClick={() => onEventSelect(event.id)}
          >
            <Horizontal gap={8} alignItems="center">
              <Text fontSize="12px">
                {event.type === 'llm_request'
                  ? '🤖'
                  : event.type === 'llm_response'
                  ? '💬'
                  : event.type === 'function_call'
                  ? '🔧'
                  : event.type === 'function_response'
                  ? '✅'
                  : event.type === 'error'
                  ? '❌'
                  : '📝'}
              </Text>
              <Text fontSize="sm" fontWeight="500">
                {event.metadata?.title || event.type}
              </Text>
              {event.duration && (
                <Text fontSize="xs" color="color.gray.500">
                  ({event.duration}ms)
                </Text>
              )}
            </Horizontal>
          </View>
          {event.children &&
            event.children.map((child) => renderTreeNode(child, depth + 1))}
        </View>
      );
    };

    return (
      <Vertical gap={4}>{tree.map((root) => renderTreeNode(root))}</Vertical>
    );
  };

  /**
   * Render table visualization
   */
  const renderTableVisualization = () => {
    return (
      <View overflowX="auto">
        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
          <thead>
            <tr
              style={{
                backgroundColor: '#f9fafb',
                borderBottom: '1px solid #e5e7eb',
              }}
            >
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Type
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Title
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Timestamp
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Duration
              </th>
              <th
                style={{
                  padding: '8px',
                  textAlign: 'left',
                  fontSize: '12px',
                  fontWeight: '600',
                }}
              >
                Level
              </th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => {
              const isSelected = selectedEvent?.id === event.id;
              return (
                <tr
                  key={event.id}
                  style={{
                    backgroundColor: isSelected ? '#eff6ff' : 'white',
                    borderBottom: '1px solid #f3f4f6',
                    cursor: 'pointer',
                  }}
                  onClick={() => onEventSelect(event.id)}
                >
                  <td style={{ padding: '8px', fontSize: '12px' }}>
                    <Horizontal gap={4} alignItems="center">
                      <Text fontSize="12px">
                        {event.type === 'llm_request'
                          ? '🤖'
                          : event.type === 'llm_response'
                          ? '💬'
                          : event.type === 'function_call'
                          ? '🔧'
                          : event.type === 'function_response'
                          ? '✅'
                          : event.type === 'error'
                          ? '❌'
                          : '📝'}
                      </Text>
                      <Text fontSize="12px">{event.type}</Text>
                    </Horizontal>
                  </td>
                  <td style={{ padding: '8px', fontSize: '12px' }}>
                    {event.metadata?.title || '-'}
                  </td>
                  <td
                    style={{
                      padding: '8px',
                      fontSize: '12px',
                      fontFamily: 'Monaco, Consolas, monospace',
                    }}
                  >
                    {new Date(event.timestamp).toLocaleTimeString()}
                  </td>
                  <td
                    style={{
                      padding: '8px',
                      fontSize: '12px',
                      fontFamily: 'Monaco, Consolas, monospace',
                    }}
                  >
                    {event.duration ? `${event.duration}ms` : '-'}
                  </td>
                  <td style={{ padding: '8px', fontSize: '12px' }}>
                    {event.metadata?.level ? (
                      <View
                        padding="2px 6px"
                        borderRadius="4px"
                        backgroundColor={
                          event.metadata.level === 'error'
                            ? 'color.red.100'
                            : event.metadata.level === 'warning'
                            ? 'color.yellow.100'
                            : 'color.blue.100'
                        }
                        color={
                          event.metadata.level === 'error'
                            ? 'color.red.800'
                            : event.metadata.level === 'warning'
                            ? 'color.yellow.800'
                            : 'color.blue.800'
                        }
                        display="inline-block"
                      >
                        <Text
                          fontSize="10px"
                          fontWeight="600"
                          textTransform="uppercase"
                        >
                          {event.metadata.level}
                        </Text>
                      </View>
                    ) : (
                      '-'
                    )}
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </View>
    );
  };

  /**
   * Render flamegraph visualization (simplified)
   */
  const renderFlamegraphVisualization = () => {
    const sortedEvents = [...events].sort((a, b) => a.timestamp - b.timestamp);
    const maxDuration = Math.max(
      ...events.filter((e) => e.duration).map((e) => e.duration!)
    );

    return (
      <Vertical gap={2}>
        {sortedEvents.map((event, index) => {
          const width = event.duration
            ? (event.duration / maxDuration) * 100
            : 10;
          const isSelected = selectedEvent?.id === event.id;

          return (
            <View
              key={event.id}
              height="24px"
              width={`${width}%`}
              backgroundColor={
                event.type === 'llm_request'
                  ? 'color.blue.500'
                  : event.type === 'llm_response'
                  ? 'color.green.500'
                  : event.type === 'function_call'
                  ? 'color.purple.500'
                  : event.type === 'error'
                  ? 'color.red.500'
                  : 'color.gray.500'
              }
              borderRadius="2px"
              cursor="pointer"
              display="flex"
              alignItems="center"
              paddingLeft="8px"
              border={isSelected ? '2px solid white' : 'none'}
              boxShadow={isSelected ? '0 0 0 2px #3b82f6' : 'none'}
              onClick={() => onEventSelect(event.id)}
              title={`${event.type} - ${event.duration || 0}ms`}
            >
              <Text fontSize="10px" color="white" fontWeight="600">
                {event.metadata?.title || event.type} ({event.duration || 0}ms)
              </Text>
            </View>
          );
        })}
      </Vertical>
    );
  };

  /**
   * Render current visualization
   */
  const renderVisualization = () => {
    switch (visualizationType) {
      case 'tree':
        return renderTreeVisualization();
      case 'table':
        return renderTableVisualization();
      case 'flamegraph':
        return renderFlamegraphVisualization();
      case 'graph':
        return (
          <View padding={32} textAlign="center">
            <Text color="color.gray.500">
              Graph visualization coming soon...
            </Text>
          </View>
        );
      default:
        return renderTreeVisualization();
    }
  };

  return (
    <View {...DefaultAgentTraceStyles.visualization} {...views.container}>
      <Vertical gap={16}>
        {/* Visualization Type Selector */}
        <Horizontal justifyContent="space-between" alignItems="center">
          <Text fontSize="sm" fontWeight="600" color="color.gray.700">
            Visualization Type
          </Text>
          <Select
            value={visualizationType}
            onChange={onVisualizationChange}
            options={[
              { value: 'tree', label: 'Tree View' },
              { value: 'table', label: 'Table View' },
              { value: 'flamegraph', label: 'Flamegraph' },
              { value: 'graph', label: 'Graph (Coming Soon)' },
            ]}
          />
        </Horizontal>

        {/* Visualization Content */}
        <View flex={1} overflowY="auto">
          {renderVisualization()}
        </View>
      </Vertical>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentTrace/examples/default.tsx">
import React, { useState } from 'react';
import { View, Vertical, Text } from 'app-studio';
import { AgentTrace } from '../AgentTrace';
import { TraceEvent } from '../AgentTrace/AgentTrace.props';

/**
 * Default AgentTrace Example
 *
 * Demonstrates basic usage of the AgentTrace component
 */
export const DefaultDemo = () => {
  const [selectedEvent, setSelectedEvent] = useState<TraceEvent | null>(null);

  const handleEventSelect = (event: TraceEvent) => {
    console.log('Event selected:', event);
    setSelectedEvent(event);
  };

  const handleError = (error: Error) => {
    console.error('AgentTrace error:', error);
  };

  return (
    <Vertical gap={32} padding={20}>
      <Text fontSize={20} fontWeight="600">
        AgentTrace Component - Default Example
      </Text>

      <Text color="color.gray.600">
        A comprehensive trace visualization component for ADK agents. Displays
        execution traces, events, and performance metrics in an interactive
        format.
      </Text>

      {/* Selected Event Info */}
      {selectedEvent && (
        <View
          padding={16}
          backgroundColor="color.purple.50"
          borderRadius="8px"
          border="1px solid"
          borderColor="color.purple.200"
        >
          <Text fontSize={14} fontWeight="600" color="color.purple.800">
            Selected Event
          </Text>
          <Text fontSize={12} color="color.purple.600">
            ID: {selectedEvent.id}
          </Text>
          <Text fontSize={12} color="color.purple.600">
            Type: {selectedEvent.type}
          </Text>
          <Text fontSize={12} color="color.purple.600">
            Duration:{' '}
            {selectedEvent.duration ? `${selectedEvent.duration}ms` : 'N/A'}
          </Text>
        </View>
      )}

      {/* AgentTrace Component */}
      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="12px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="demo-user"
          appName="demo-agent"
          apiBaseUrl="http://localhost:3000/adk"
          showTimeline={true}
          showMetrics={true}
          showVisualization={true}
          enableFiltering={true}
          enableExport={true}
          enableSearch={true}
          enableAutoRefresh={false}
          visualizationType="timeline"
          onEventSelect={handleEventSelect}
          onError={handleError}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * AgentTrace with Mock Data Example
 *
 * Shows the component with sample trace data
 */
export const MockDataDemo = () => {
  const mockEvents: TraceEvent[] = [
    {
      id: 'event-1',
      sessionId: 'session-123',
      type: 'user_input',
      timestamp: Date.now() - 10000,
      duration: 50,
      data: { message: 'Hello, can you help me with my code?' },
      metadata: {
        title: 'User Message',
        description: 'User asks for coding help',
        level: 'info',
        tags: ['user', 'input'],
      },
    },
    {
      id: 'event-2',
      sessionId: 'session-123',
      type: 'llm_request',
      timestamp: Date.now() - 9000,
      duration: 1200,
      data: {
        model: 'gpt-4',
        prompt: 'Help user with coding question',
        tokens: 150,
      },
      metadata: {
        title: 'LLM Request',
        description: 'Sending request to language model',
        level: 'info',
        tags: ['llm', 'request'],
      },
      parentId: 'event-1',
    },
    {
      id: 'event-3',
      sessionId: 'session-123',
      type: 'function_call',
      timestamp: Date.now() - 8000,
      duration: 800,
      data: {
        function: 'analyze_code',
        arguments: { language: 'python', code: 'def hello(): print("world")' },
      },
      metadata: {
        title: 'Code Analysis',
        description: 'Analyzing user code for improvements',
        level: 'info',
        tags: ['function', 'analysis'],
      },
      parentId: 'event-2',
    },
    {
      id: 'event-4',
      sessionId: 'session-123',
      type: 'function_response',
      timestamp: Date.now() - 7000,
      duration: 100,
      data: {
        result: {
          suggestions: [
            'Add type hints',
            'Use more descriptive variable names',
          ],
          score: 85,
        },
      },
      metadata: {
        title: 'Analysis Result',
        description: 'Code analysis completed successfully',
        level: 'info',
        tags: ['function', 'response'],
      },
      parentId: 'event-3',
    },
    {
      id: 'event-5',
      sessionId: 'session-123',
      type: 'llm_response',
      timestamp: Date.now() - 6000,
      duration: 300,
      data: {
        response: 'I analyzed your code and have some suggestions...',
        tokens: 200,
      },
      metadata: {
        title: 'LLM Response',
        description: 'Language model provides response',
        level: 'info',
        tags: ['llm', 'response'],
      },
      parentId: 'event-2',
    },
    {
      id: 'event-6',
      sessionId: 'session-123',
      type: 'agent_output',
      timestamp: Date.now() - 5000,
      duration: 150,
      data: {
        message: 'Here are some suggestions to improve your code...',
        suggestions: ['Add type hints', 'Use more descriptive variable names'],
      },
      metadata: {
        title: 'Agent Response',
        description: 'Final response sent to user',
        level: 'info',
        tags: ['agent', 'output'],
      },
      parentId: 'event-1',
    },
  ];

  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        AgentTrace with Mock Data
      </Text>

      <View
        height="600px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="demo-user"
          appName="demo-agent"
          initialEvents={mockEvents}
          showTimeline={true}
          showMetrics={true}
          enableFiltering={true}
          visualizationType="timeline"
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Compact AgentTrace Example
 *
 * Shows the component in compact mode
 */
export const CompactDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Compact AgentTrace Example
      </Text>

      <View
        height="400px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="user123"
          appName="compact-agent"
          compactMode={true}
          showTimeline={false}
          showVisualization={false}
          enableFiltering={false}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Real-time AgentTrace Example
 *
 * Demonstrates real-time updates and auto-refresh
 */
export const RealTimeDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Real-time AgentTrace Example
      </Text>

      <Text fontSize={14} color="color.gray.600">
        This example shows real-time trace updates with auto-refresh enabled.
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius="8px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="user123"
          appName="realtime-agent"
          enableAutoRefresh={true}
          enableRealTimeUpdates={true}
          refreshInterval={5000}
          showTimeline={true}
          showMetrics={true}
          views={{
            container: {
              height: '100%',
            },
          }}
        />
      </View>
    </Vertical>
  );
};

/**
 * Customized AgentTrace Example
 *
 * Shows advanced customization options
 */
export const CustomizedDemo = () => {
  return (
    <Vertical gap={16} padding={20}>
      <Text fontSize={18} fontWeight="600">
        Customized AgentTrace Example
      </Text>

      <View
        height="500px"
        border="1px solid"
        borderColor="color.orange.200"
        borderRadius="12px"
      >
        <AgentTrace
          sessionId="session-123"
          userId="user123"
          appName="custom-agent"
          visualizationType="tree"
          showPerformanceMetrics={true}
          enableExport={true}
          views={{
            container: {
              backgroundColor: 'color.orange.25',
              height: '100%',
            },
            header: {
              backgroundColor: 'color.orange.500',
              color: 'white',
            },
            timeline: {
              backgroundColor: 'color.white',
            },
            eventList: {
              backgroundColor: 'color.white',
            },
            metricsPanel: {
              backgroundColor: 'color.orange.50',
            },
          }}
        />
      </View>
    </Vertical>
  );
};
</file>

<file path="src/components/adk/AgentTrace/AgentTrace.tsx">
import React from 'react';
import { AgentTraceProps } from './AgentTrace/AgentTrace.props';
import AgentTraceView from './AgentTrace/AgentTrace.view';
import { useAgentTrace } from './AgentTrace/AgentTrace.state';

/**
 * AgentTrace Component
 *
 * A comprehensive trace visualization component for ADK agents.
 * Displays execution traces, events, and performance metrics in an interactive format.
 *
 * @example
 * ```tsx
 * <AgentTrace
 *   sessionId="session-123"
 *   userId="user123"
 *   appName="my-agent"
 *   onEventSelect={(event) => console.log('Event selected:', event)}
 * />
 * ```
 *
 * @example
 * ```tsx
 * // With custom visualization and filtering
 * <AgentTrace
 *   sessionId="session-123"
 *   userId="user123"
 *   appName="my-agent"
 *   showTimeline={true}
 *   showMetrics={true}
 *   enableFiltering={true}
 *   enableExport={true}
 *   visualizationType="tree"
 *   autoRefresh={true}
 *   refreshInterval={5000}
 *   views={{
 *     container: { backgroundColor: 'color.gray.50' },
 *     timeline: { height: '200px' },
 *     eventList: { maxHeight: '400px' }
 *   }}
 * />
 * ```
 */
const AgentTrace: React.FC<AgentTraceProps> = (props) => {
  const traceState = useAgentTrace(props);

  return <AgentTraceView {...props} {...traceState} />;
};

export default AgentTrace;
export { AgentTrace };
export type { AgentTraceProps };
</file>

<file path="src/components/ChatInput/GuideTip.tsx">
import React from 'react';
import { Text, View } from 'app-studio';
import { CloseIcon } from '../Icon/Icon';

interface GuideTipProps {
  videoUrl?: string;
  onClose: () => void;
  views?: {
    container?: any;
    video?: any;
    closeButton?: any;
  };
}

export const GuideTip: React.FC<GuideTipProps> = ({
  videoUrl,
  onClose,
  views = {},
}) => {
  // Using theme context for potential future styling

  return (
    <View
      position="relative"
      width="100%"
      padding="16px"
      backgroundColor="color.blue.50"
      borderRadius="8px"
      marginBottom="16px"
      animate={{
        from: { opacity: 0, transform: 'translateX(-20px)' },
        to: { opacity: 1, transform: 'translateX(0)' },
      }}
      animationDuration={0.3}
      {...views?.container}
    >
      <Text fontSize="14px" color="color.blue.700" marginBottom="8px">
        Need help? Watch this quick guide to get started.
      </Text>

      {videoUrl && (
        <View
          as="video"
          src={videoUrl}
          controls
          width="100%"
          height="auto"
          borderRadius="4px"
          {...views?.video}
        />
      )}

      <View
        as="button"
        type="button"
        position="absolute"
        top="8px"
        right="8px"
        width="24px"
        height="24px"
        display="flex"
        alignItems="center"
        justifyContent="center"
        borderRadius="50%"
        backgroundColor="transparent"
        border="none"
        cursor="pointer"
        transition="all 0.2s ease"
        onClick={onClose}
        _hover={{
          backgroundColor: 'color.blue.100',
        }}
        {...views?.closeButton}
      >
        <CloseIcon
          widthHeight={16}
          color="currentColor"
          filled={false}
          strokeWidth={2}
        />
      </View>
    </View>
  );
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentMessage.tsx">
import React from 'react';
import { View, Horizontal, Vertical, Text } from 'app-studio';
import { AgentMessage as AgentMessageType } from './AgentChat.props';
import { DefaultAgentChatStyles } from './AgentChat.style';
import { Loader } from '../../../Loader/Loader';
import { Avatar } from '../../../Avatar/Avatar';
import { MessageAttachmentPreview } from './MessageAttachmentPreview';

export interface AgentMessageProps {
  message: AgentMessageType;
  showTimestamp?: boolean;
  showAvatar?: boolean;
  isLast?: boolean;
  views?: {
    container?: any;
    content?: any;
    timestamp?: any;
    avatar?: any;
  };
}

/**
 * AgentMessage Component
 *
 * Renders individual messages in the chat with support for different message types,
 * attachments, function calls, code execution, and more.
 */
export const AgentMessage: React.FC<AgentMessageProps> = ({
  message,
  showTimestamp = true,
  showAvatar = true,
  isLast = false,
  views = {},
}) => {
  const isUser = message.role === 'user';
  const isThought = message.thought;
  const isLoading = message.isLoading;

  // Determine message styles
  const messageStyles = {
    ...DefaultAgentChatStyles.message,
    ...(isUser
      ? DefaultAgentChatStyles.userMessage
      : DefaultAgentChatStyles.botMessage),
    ...(isThought ? DefaultAgentChatStyles.thoughtMessage : {}),
    ...(isLoading ? DefaultAgentChatStyles.loadingMessage : {}),
    ...views.container,
  };

  // Format timestamp
  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  // Render message content based on type
  const renderMessageContent = () => {
    if (isLoading) {
      return (
        <Horizontal alignItems="center" gap={8}>
          <Loader size="sm" />
          <Text color="color.gray.600">Thinking...</Text>
        </Horizontal>
      );
    }

    return (
      <Vertical gap={8}>
        {/* Text content */}
        {message.text && (
          <Text {...DefaultAgentChatStyles.messageContent} {...views.content}>
            {message.text}
          </Text>
        )}

        {/* Inline data (images, files, etc.) */}
        {message.inlineData && (
          <View {...DefaultAgentChatStyles.inlineData}>
            {message.inlineData.mediaType === 'image' ? (
              <img
                src={message.inlineData.data}
                alt={message.inlineData.displayName || 'Uploaded image'}
                style={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: '8px',
                }}
              />
            ) : message.inlineData.mediaType === 'video' ? (
              <video
                src={message.inlineData.data}
                controls
                style={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: '8px',
                }}
              />
            ) : message.inlineData.mediaType === 'audio' ? (
              <audio
                src={message.inlineData.data}
                controls
                style={{ width: '100%' }}
              />
            ) : (
              <View
                padding={12}
                backgroundColor="color.gray.100"
                borderRadius="8px"
              >
                <Text fontSize="sm" fontWeight="500">
                  📄 {message.inlineData.displayName || 'File'}
                </Text>
                <Text fontSize="xs" color="color.gray.600">
                  {message.inlineData.mimeType}
                </Text>
              </View>
            )}
          </View>
        )}

        {/* Attachments */}
        {message.attachments && message.attachments.length > 0 && (
          <Horizontal gap={8} flexWrap="wrap">
            {message.attachments.map((attachment, index) => (
              <MessageAttachmentPreview key={index} attachment={attachment} />
            ))}
          </Horizontal>
        )}

        {/* Function Call */}
        {message.functionCall && (
          <View {...DefaultAgentChatStyles.functionCall}>
            <Text fontSize="sm" fontWeight="600" color="color.purple.700">
              🔧 Function Call: {message.functionCall.name}
            </Text>
            {message.functionCall.args && (
              <View marginTop={8}>
                <Text fontSize="xs" color="color.purple.600">
                  Arguments:
                </Text>
                <View
                  backgroundColor="color.purple.25"
                  padding={8}
                  borderRadius="4px"
                  marginTop={4}
                >
                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                    {JSON.stringify(message.functionCall.args, null, 2)}
                  </Text>
                </View>
              </View>
            )}
          </View>
        )}

        {/* Function Response */}
        {message.functionResponse && (
          <View {...DefaultAgentChatStyles.functionResponse}>
            <Text fontSize="sm" fontWeight="600" color="color.green.700">
              ✅ Function Response: {message.functionResponse.name}
            </Text>
            {message.functionResponse.response && (
              <View marginTop={8}>
                <View
                  backgroundColor="color.green.25"
                  padding={8}
                  borderRadius="4px"
                >
                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                    {typeof message.functionResponse.response === 'string'
                      ? message.functionResponse.response
                      : JSON.stringify(
                          message.functionResponse.response,
                          null,
                          2
                        )}
                  </Text>
                </View>
              </View>
            )}
          </View>
        )}

        {/* Executable Code */}
        {message.executableCode && (
          <View {...DefaultAgentChatStyles.codeBlock}>
            <Text
              fontSize="sm"
              fontWeight="600"
              color="color.gray.100"
              marginBottom={8}
            >
              💻 Code ({message.executableCode.language})
            </Text>
            <Text fontSize="sm" fontFamily="Monaco, Consolas, monospace">
              {message.executableCode.code}
            </Text>
          </View>
        )}

        {/* Code Execution Result */}
        {message.codeExecutionResult && (
          <View {...DefaultAgentChatStyles.functionResponse}>
            <Text fontSize="sm" fontWeight="600" color="color.green.700">
              📊 Execution Result: {message.codeExecutionResult.outcome}
            </Text>
            {message.codeExecutionResult.output && (
              <View marginTop={8}>
                <View
                  backgroundColor="color.green.25"
                  padding={8}
                  borderRadius="4px"
                >
                  <Text fontSize="xs" fontFamily="Monaco, Consolas, monospace">
                    {message.codeExecutionResult.output}
                  </Text>
                </View>
              </View>
            )}
          </View>
        )}

        {/* Rendered Content (for search results, etc.) */}
        {message.renderedContent && (
          <View
            marginTop={8}
            padding={12}
            backgroundColor="color.blue.50"
            borderRadius="8px"
            border="1px solid"
            borderColor="color.blue.200"
          >
            <div
              dangerouslySetInnerHTML={{ __html: message.renderedContent }}
            />
          </View>
        )}

        {/* Evaluation Status */}
        {message.evalStatus && (
          <View
            marginTop={8}
            padding={8}
            backgroundColor={
              message.evalStatus === 'PASS' ? 'color.green.50' : 'color.red.50'
            }
            borderRadius="8px"
            border="1px solid"
            borderColor={
              message.evalStatus === 'PASS'
                ? 'color.green.200'
                : 'color.red.200'
            }
          >
            <Text
              fontSize="sm"
              fontWeight="600"
              color={
                message.evalStatus === 'PASS'
                  ? 'color.green.700'
                  : 'color.red.700'
              }
            >
              Evaluation: {message.evalStatus}
            </Text>
            {message.evalScore !== undefined && (
              <Text fontSize="xs" color="color.gray.600">
                Score: {message.evalScore} / {message.evalThreshold}
              </Text>
            )}
            {message.failedMetric && (
              <Text fontSize="xs" color="color.red.600">
                Failed Metric: {message.failedMetric}
              </Text>
            )}
          </View>
        )}
      </Vertical>
    );
  };

  return (
    <Horizontal
      gap={12}
      alignItems="flex-start"
      justifyContent={isUser ? 'flex-end' : 'flex-start'}
      width="100%"
    >
      {/* Avatar for bot messages */}
      {showAvatar && !isUser && (
        <Avatar
          size="sm"
          backgroundColor="color.green.500"
          color="white"
          {...DefaultAgentChatStyles.botAvatar}
          {...views.avatar}
        >
          🤖
        </Avatar>
      )}

      {/* Message content */}
      <Vertical gap={4} maxWidth="80%">
        <View {...messageStyles}>{renderMessageContent()}</View>

        {/* Timestamp */}
        {showTimestamp && !isLoading && (
          <Text
            {...DefaultAgentChatStyles.timestamp}
            {...views.timestamp}
            textAlign={isUser ? 'right' : 'left'}
          >
            {formatTimestamp(message.timestamp)}
          </Text>
        )}
      </Vertical>

      {/* Avatar for user messages */}
      {showAvatar && isUser && (
        <Avatar
          size="sm"
          backgroundColor="color.blue.500"
          color="white"
          {...DefaultAgentChatStyles.userAvatar}
          {...views.avatar}
        >
          👤
        </Avatar>
      )}
    </Horizontal>
  );
};
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Session Types
 */
export interface AgentSession {
  id: string;
  userId: string;
  appName: string;
  state: any;
  events: AgentEvent[];
  createdAt: number;
  updatedAt: number;
  metadata?: {
    title?: string;
    description?: string;
    tags?: string[];
    messageCount?: number;
    lastActivity?: number;
  };
}

export interface AgentEvent {
  id: string;
  sessionId: string;
  type: string;
  data: any;
  timestamp: number;
  title?: string;
  author?: 'user' | 'bot' | 'system';
  content?: {
    parts?: any[];
  };
}

export interface SessionSummary {
  id: string;
  title: string;
  lastMessage: string;
  messageCount: number;
  createdAt: number;
  updatedAt: number;
  isActive: boolean;
}

/**
 * Component View Customization
 */
export interface AgentSessionViews {
  // Main container areas
  container?: ViewProps;
  header?: ViewProps;
  toolbar?: ViewProps;
  sessionList?: ViewProps;
  sessionActions?: ViewProps;
  filtersPanel?: ViewProps;

  // Session list items
  sessionItem?: ViewProps;
  activeSessionItem?: ViewProps;
  sessionInfo?: ViewProps;
  sessionTitle?: ViewProps;
  sessionDescription?: ViewProps;
  sessionMetadata?: ViewProps;
  sessionTimestamp?: ViewProps;
  sessionTags?: ViewProps;
  sessionStats?: ViewProps;

  // Action buttons
  createButton?: ViewProps;
  deleteButton?: ViewProps;
  exportButton?: ViewProps;
  importButton?: ViewProps;
  refreshButton?: ViewProps;
  selectButton?: ViewProps;
  duplicateButton?: ViewProps;

  // Search and filters
  searchInput?: ViewProps;
  filterDropdown?: ViewProps;
  sortDropdown?: ViewProps;
  dateRangePicker?: ViewProps;
  tagFilter?: ViewProps;

  // State displays
  emptyState?: ViewProps;
  loadingState?: ViewProps;
  errorState?: ViewProps;

  // Bulk operations
  bulkActions?: ViewProps;
  selectAllCheckbox?: ViewProps;
  bulkDeleteButton?: ViewProps;
  bulkExportButton?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentSessionEventHandlers {
  onSessionSelect?: (session: AgentSession) => void;
  onSessionCreate?: (session: AgentSession) => void;
  onSessionUpdate?: (session: AgentSession) => void;
  onSessionDelete?: (sessionId: string) => void;
  onSessionImport?: (session: AgentSession) => void;
  onSessionExport?: (session: AgentSession) => void;
  onError?: (error: Error) => void;
  onRefresh?: () => void;
}

/**
 * Session Filter and Sort Options
 */
export interface SessionFilters {
  searchQuery?: string;
  dateRange?: {
    start: Date;
    end: Date;
  };
  tags?: string[];
  messageCountRange?: {
    min: number;
    max: number;
  };
  isActive?: boolean;
}

export interface SessionSortOptions {
  field: 'createdAt' | 'updatedAt' | 'messageCount' | 'title';
  direction: 'asc' | 'desc';
}

/**
 * Main AgentSession Props Interface
 */
export interface AgentSessionProps
  extends ViewProps,
    AgentSessionEventHandlers {
  // Required props
  appName: string;
  userId: string;

  // Optional configuration
  apiBaseUrl?: string;

  // Feature toggles
  showSessionHistory?: boolean;
  enableSessionImport?: boolean;
  enableSessionExport?: boolean;
  enableSessionDelete?: boolean;
  enableSessionSearch?: boolean;
  enableAutoRefresh?: boolean;

  // Limits and constraints
  maxSessions?: number;
  refreshInterval?: number; // in milliseconds

  // UI customization
  showSessionInfo?: boolean;
  showSessionActions?: boolean;
  showCreateButton?: boolean;
  showRefreshButton?: boolean;
  compactMode?: boolean;

  // Styling and customization
  views?: AgentSessionViews;
  containerProps?: ViewProps;

  // Initial state
  initialSessions?: AgentSession[];
  selectedSessionId?: string;

  // Filtering and sorting
  defaultFilters?: SessionFilters;
  defaultSort?: SessionSortOptions;

  // Advanced features
  enableSessionTags?: boolean;
  enableSessionMetadata?: boolean;
  enableBulkOperations?: boolean;

  // Theme and appearance
  colorScheme?: 'blue' | 'purple' | 'green' | 'orange' | 'red' | 'gray';
  layout?: 'list' | 'grid' | 'compact';
  showPreviews?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}

/**
 * Session Action Types
 */
export type SessionAction =
  | 'create'
  | 'select'
  | 'delete'
  | 'export'
  | 'import'
  | 'refresh'
  | 'search'
  | 'filter'
  | 'sort';

/**
 * Session Status Types
 */
export type SessionStatus = 'active' | 'inactive' | 'archived' | 'error';

/**
 * Session Import/Export Format
 */
export interface SessionExportData {
  session: AgentSession;
  exportedAt: number;
  exportedBy: string;
  version: string;
}

export interface SessionImportOptions {
  overwriteExisting?: boolean;
  preserveIds?: boolean;
  updateTimestamps?: boolean;
}
</file>

<file path="src/components/adk/AgentSession/AgentSession/AgentSession.view.tsx">
import React from 'react';
import { View, Vertical, Horizontal, Text, Button } from 'app-studio';
import { AgentSessionProps } from './AgentSession.props';
import { useAgentSession } from './AgentSession.state';
import { DefaultAgentSessionStyles } from './AgentSession.style';
import { SessionListItem } from './SessionListItem';
import { SessionActions } from './SessionActions';
import { SessionFilters } from './SessionFilters';
import { Alert } from '../../../Alert/Alert';
import { Loader } from '../../../Loader/Loader';
import { TextField } from '../../../Form/Form';

export interface AgentSessionViewProps
  extends AgentSessionProps,
    ReturnType<typeof useAgentSession> {}

/**
 * AgentSession View Component
 *
 * Renders the complete session management interface with session list, actions, and filters
 */
const AgentSessionView: React.FC<AgentSessionViewProps> = ({
  // Props
  showSessionHistory = true,
  enableSessionImport = true,
  enableSessionExport = true,
  enableSessionDelete = true,
  enableSessionSearch = true,
  showSessionInfo = true,
  showSessionActions = true,
  showCreateButton = true,
  showRefreshButton = true,
  compactMode = false,
  views,
  containerProps,
  colorScheme = 'blue',
  layout = 'list',
  showPreviews = true,
  ariaLabel = 'Agent Session Manager',
  ariaDescribedBy,

  // State from hook
  sessions,
  selectedSession,
  isLoading,
  isCreating,
  error,
  searchQuery,
  filters,
  sortOptions,
  fetchSessions,
  createSession,
  selectSession,
  deleteSession,
  exportSession,
  handleFileImport,
  setSearchQuery,
  setFilters,
  setSortOptions,
  setError,
  fileInputRef,
  handleFileSelect,

  ...props
}) => {
  /**
   * Handle session creation
   */
  const handleCreateSession = async () => {
    try {
      await createSession({
        title: `Session ${new Date().toLocaleString()}`,
        description: 'New agent session',
      });
    } catch (error) {
      // Error is handled in the hook
    }
  };

  /**
   * Handle session selection
   */
  const handleSessionSelect = (sessionId: string) => {
    selectSession(sessionId);
  };

  /**
   * Handle session deletion
   */
  const handleSessionDelete = async (sessionId: string) => {
    if (window.confirm('Are you sure you want to delete this session?')) {
      await deleteSession(sessionId);
    }
  };

  /**
   * Handle session export
   */
  const handleSessionExport = (sessionId: string) => {
    const session = sessions.find((s) => s.id === sessionId);
    if (session) {
      exportSession(session);
    }
  };

  /**
   * Format session date
   */
  const formatDate = (timestamp: number) => {
    return new Date(timestamp).toLocaleDateString([], {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  /**
   * Get dynamic styles based on theme props
   */
  const getThemeStyles = () => {
    const colorStyles = {
      blue: { borderColor: 'color.blue.200' },
      purple: { borderColor: 'color.purple.200' },
      green: { borderColor: 'color.green.200' },
      orange: { borderColor: 'color.orange.200' },
      red: { borderColor: 'color.red.200' },
      gray: { borderColor: 'color.gray.200' },
    };

    const layoutStyles = {
      list: { flexDirection: 'column' as const },
      grid: { flexDirection: 'row' as const, flexWrap: 'wrap' as const },
      compact: { padding: '8px' },
    };

    return {
      ...colorStyles[colorScheme],
      ...layoutStyles[layout],
    };
  };

  return (
    <View
      {...DefaultAgentSessionStyles.container}
      {...getThemeStyles()}
      {...containerProps}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentSessionStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Sessions
            </Text>
            <Text fontSize="sm" color="color.gray.600">
              {sessions.length} session{sessions.length !== 1 ? 's' : ''}
            </Text>
          </Vertical>

          <Horizontal gap={8}>
            {showRefreshButton && (
              <Button
                variant="outline"
                size="sm"
                onClick={fetchSessions}
                disabled={isLoading}
                aria-label="Refresh sessions"
              >
                🔄
              </Button>
            )}

            {showCreateButton && (
              <Button
                variant="filled"
                size="sm"
                onClick={handleCreateSession}
                disabled={isCreating}
                aria-label="Create new session"
              >
                {isCreating ? <Loader size="xs" /> : '+ New Session'}
              </Button>
            )}
          </Horizontal>
        </Horizontal>
      </View>

      {/* Error Display */}
      {error && (
        <Alert variant="error" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {/* Search and Filters */}
      {enableSessionSearch && (
        <View
          padding={16}
          borderBottom="1px solid"
          borderBottomColor="color.gray.200"
        >
          <Vertical gap={12}>
            <TextField
              placeholder="Search sessions..."
              value={searchQuery}
              onChange={setSearchQuery}
              views={{
                container: views?.searchInput,
              }}
            />

            <SessionFilters
              filters={filters}
              sortOptions={sortOptions}
              onFiltersChange={setFilters}
              onSortChange={setSortOptions}
            />
          </Vertical>
        </View>
      )}

      {/* Session Actions */}
      {showSessionActions && (
        <SessionActions
          enableImport={enableSessionImport}
          enableExport={enableSessionExport}
          selectedSession={selectedSession}
          onImport={handleFileImport}
          onExport={handleSessionExport}
          views={{
            container: views?.sessionActions,
            importButton: views?.importButton,
            exportButton: views?.exportButton,
          }}
        />
      )}

      {/* Session List */}
      <View {...DefaultAgentSessionStyles.sessionList} {...views?.sessionList}>
        {isLoading && sessions.length === 0 ? (
          <View
            {...DefaultAgentSessionStyles.loadingState}
            {...views?.loadingState}
          >
            <Loader size="md" />
            <Text color="color.gray.600">Loading sessions...</Text>
          </View>
        ) : sessions.length === 0 ? (
          <View
            {...DefaultAgentSessionStyles.emptyState}
            {...views?.emptyState}
          >
            <Text fontSize="lg" color="color.gray.500" textAlign="center">
              No sessions found
            </Text>
            <Text fontSize="sm" color="color.gray.400" textAlign="center">
              Create a new session to get started
            </Text>
          </View>
        ) : (
          <Vertical gap={8} padding={16}>
            {sessions.map((session) => (
              <SessionListItem
                key={session.id}
                session={session}
                isSelected={selectedSession?.id === session.id}
                compactMode={compactMode}
                showInfo={showSessionInfo}
                enableDelete={enableSessionDelete}
                enableExport={enableSessionExport}
                onSelect={() => handleSessionSelect(session.id)}
                onDelete={() => handleSessionDelete(session.id)}
                onExport={() => handleSessionExport(session.id)}
                formatDate={formatDate}
                views={{
                  container:
                    selectedSession?.id === session.id
                      ? views?.activeSessionItem
                      : views?.sessionItem,
                  info: views?.sessionInfo,
                  deleteButton: views?.deleteButton,
                  exportButton: views?.exportButton,
                }}
              />
            ))}
          </Vertical>
        )}
      </View>

      {/* Hidden file input for import */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        style={{ display: 'none' }}
        onChange={handleFileSelect}
      />
    </View>
  );
};

export default AgentSessionView;
</file>

<file path="src/components/ChatInput/ChatInput.tsx">
import React, { forwardRef } from 'react';
import { ChatInputProps } from './ChatInput/ChatInput.props';
import { useChatInputState } from './ChatInput/ChatInput.state';
import ChatInputView from './ChatInput/ChatInput.view';

/**
 * Interface for the ChatInput component's imperative handle
 */

/**
 * ChatInput component
 *
 * A customizable chat input component with file upload support
 */
export const ChatInput = forwardRef<HTMLElement, ChatInputProps>(
  (props, ref) => {
    // Get state from custom hook
    const state = useChatInputState(props);

    // Render the view component with props and state
    return <ChatInputView {...props} {...state} />;
  }
);

ChatInput.displayName = 'ChatInput';
</file>

<file path="src/components/ChatInput/PromptExamples.tsx">
import React from 'react';
import { Horizontal, Text, View, useTheme } from 'app-studio';
import { PromptExample } from './ChatInput/ChatInput.type';

interface PromptExamplesProps {
  examples: PromptExample[];
  onSelect: (example: PromptExample) => void;
  views?: {
    container?: any;
    item?: any;
    text?: any;
  };
}

export const PromptExamples: React.FC<PromptExamplesProps> = ({
  examples,
  onSelect,
  views = {},
}) => {
  const { getColor } = useTheme();

  if (!examples || examples.length === 0) {
    return null;
  }

  return (
    <Horizontal
      gap={8}
      overflowX="auto"
      padding="8px 0"
      width="100%"
      {...views?.container}
    >
      {examples.map((example) => (
        <View
          key={example.id}
          as="button"
          type="button"
          padding="8px 12px"
          borderRadius="4px"
          backgroundColor="color.gray.100"
          border="none"
          cursor="pointer"
          transition="all 0.2s ease"
          onClick={() => onSelect(example)}
          _hover={{
            backgroundColor: 'color.gray.200',
          }}
          {...views?.item}
        >
          <Text fontSize="14px" color="color.gray.700" {...views?.text}>
            {example.text}
          </Text>
        </View>
      ))}
    </Horizontal>
  );
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.props.ts">
import { ViewProps } from 'app-studio';

/**
 * Core ADK Agent Types
 */
export interface AgentRunRequest {
  appName: string;
  userId: string;
  sessionId: string;
  newMessage: {
    role: string;
    parts: MessagePart[];
  };
  functionCallEventId?: string;
  streaming?: boolean;
}

export interface MessagePart {
  text?: string;
  inlineData?: {
    displayName: string;
    data: string | ArrayBuffer;
    mimeType: string;
  };
  functionCall?: {
    id: string;
    name: string;
    args: any;
  };
  functionResponse?: {
    id: string;
    name: string;
    response: any;
  };
  executableCode?: {
    language: string;
    code: string;
  };
  codeExecutionResult?: {
    outcome: string;
    output?: string;
  };
  thought?: boolean;
}

export interface AgentMessage {
  id: string;
  role: 'user' | 'bot';
  text?: string;
  parts?: MessagePart[];
  timestamp: number;
  isLoading?: boolean;
  thought?: boolean;
  eventId?: string;
  attachments?: MessageAttachment[];
  inlineData?: {
    displayName?: string;
    data: string;
    mimeType: string;
    mediaType?: 'image' | 'video' | 'audio' | 'document';
  };
  functionCall?: any;
  functionResponse?: any;
  executableCode?: any;
  codeExecutionResult?: any;
  renderedContent?: string;
  evalStatus?: string;
  failedMetric?: string;
  evalScore?: number;
  evalThreshold?: number;
}

export interface MessageAttachment {
  file: File;
  url: string;
  type: string;
}

export interface AgentSession {
  id: string;
  userId: string;
  appName: string;
  state: any;
  events: any[];
  createdAt: number;
  updatedAt: number;
}

export interface AgentEvent {
  id: string;
  sessionId: string;
  type: string;
  data: any;
  timestamp: number;
  title?: string;
}

/**
 * Component View Customization
 */
export interface AgentChatViews {
  // Main container areas
  container?: ViewProps;
  header?: ViewProps;
  messageList?: ViewProps;
  inputArea?: ViewProps;
  attachmentArea?: ViewProps;

  // Message components
  message?: ViewProps;
  userMessage?: ViewProps;
  botMessage?: ViewProps;
  systemMessage?: ViewProps;
  messageContent?: ViewProps;
  messageTimestamp?: ViewProps;
  messageAvatar?: ViewProps;
  messageActions?: ViewProps;

  // Input components
  inputField?: ViewProps;
  sendButton?: ViewProps;
  attachButton?: ViewProps;
  recordButton?: ViewProps;
  inputToolbar?: ViewProps;

  // State indicators
  loadingIndicator?: ViewProps;
  typingIndicator?: ViewProps;
  errorMessage?: ViewProps;
  emptyState?: ViewProps;

  // Function call components
  functionCall?: ViewProps;
  functionResponse?: ViewProps;
  functionArgs?: ViewProps;

  // Code execution components
  codeBlock?: ViewProps;
  codeOutput?: ViewProps;

  // File attachment components
  attachmentPreview?: ViewProps;
  attachmentItem?: ViewProps;
  attachmentRemoveButton?: ViewProps;

  // Thought components (for thinking mode)
  thoughtBubble?: ViewProps;
  thoughtContent?: ViewProps;
}

/**
 * Event Handlers
 */
export interface AgentChatEventHandlers {
  onSessionCreate?: (session: AgentSession) => void;
  onSessionUpdate?: (session: AgentSession) => void;
  onMessageSent?: (message: AgentMessage) => void;
  onMessageReceived?: (message: AgentMessage) => void;
  onError?: (error: Error) => void;
  onFileUpload?: (files: File[]) => void;
  onTypingStart?: () => void;
  onTypingStop?: () => void;
  onAudioRecordingStart?: () => void;
  onAudioRecordingStop?: (audioData: Blob) => void;
  onVideoRecordingStart?: () => void;
  onVideoRecordingStop?: (videoData: Blob) => void;
}

/**
 * Main AgentChat Props Interface
 */
export interface AgentChatProps extends ViewProps, AgentChatEventHandlers {
  // Required props
  appName: string;
  userId: string;

  // Optional configuration
  sessionId?: string;
  apiBaseUrl?: string;
  wsBaseUrl?: string;

  // Feature toggles
  enableFileUpload?: boolean;
  enableAudioRecording?: boolean;
  enableVideoRecording?: boolean;
  enableStreaming?: boolean;
  enableThoughts?: boolean;

  // Limits and constraints
  maxFileSize?: number;
  maxFiles?: number;
  allowedFileTypes?: string[];
  maxMessageLength?: number;

  // UI customization
  placeholder?: string;
  showTimestamps?: boolean;
  showAvatars?: boolean;
  showTypingIndicator?: boolean;
  autoScroll?: boolean;

  // Styling and customization
  views?: AgentChatViews;
  containerProps?: ViewProps;

  // Initial state
  initialMessages?: AgentMessage[];
  initialSession?: AgentSession;

  // Advanced features
  enableFunctionCalls?: boolean;
  enableCodeExecution?: boolean;
  enableEvaluation?: boolean;

  // Theme and appearance
  colorScheme?: 'blue' | 'purple' | 'green' | 'orange' | 'red' | 'gray';
  compact?: boolean;
  rounded?: boolean;

  // Accessibility
  ariaLabel?: string;
  ariaDescribedBy?: string;
}
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.state.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  AgentChatProps,
  AgentMessage,
  AgentSession,
  AgentRunRequest,
  MessageAttachment,
  MessagePart,
} from './AgentChat.props';
import { generateId } from '../../../../utils/generateId';

/**
 * Custom hook for managing AgentChat state and interactions
 */
export const useAgentChat = (props: AgentChatProps) => {
  const {
    appName,
    userId,
    sessionId: initialSessionId,
    apiBaseUrl = '',
    wsBaseUrl = '',
    enableStreaming = true,
    enableFileUpload = true,
    maxFileSize = 10 * 1024 * 1024, // 10MB
    maxFiles = 5,
    allowedFileTypes = [
      'image/*',
      'video/*',
      'audio/*',
      'application/pdf',
      'text/*',
    ],
    initialMessages = [],
    initialSession,
    onSessionCreate,
    onSessionUpdate,
    onMessageSent,
    onMessageReceived,
    onError,
    onFileUpload,
    onTypingStart,
    onTypingStop,
  } = props;

  // Core state
  const [messages, setMessages] = useState<AgentMessage[]>(initialMessages);
  const [currentSession, setCurrentSession] = useState<AgentSession | null>(
    initialSession || null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [inputValue, setInputValue] = useState('');
  const [selectedFiles, setSelectedFiles] = useState<MessageAttachment[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  // Refs
  const wsRef = useRef<WebSocket | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Generate or use provided session ID
  const sessionId = currentSession?.id || initialSessionId || generateId();

  /**
   * Create a new session
   */
  const createSession = useCallback(async () => {
    try {
      const response = await fetch(`${apiBaseUrl}/sessions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, appName }),
      });

      if (!response.ok) throw new Error('Failed to create session');

      const session: AgentSession = await response.json();
      setCurrentSession(session);
      onSessionCreate?.(session);
      return session;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error.message);
      onError?.(error);
      throw error;
    }
  }, [apiBaseUrl, userId, appName, onSessionCreate, onError]);

  /**
   * Send a message to the agent
   */
  const sendMessage = useCallback(
    async (text: string, attachments: MessageAttachment[] = []) => {
      if (!text.trim() && attachments.length === 0) return;

      try {
        setIsLoading(true);
        setError(null);
        setIsTyping(true);
        onTypingStart?.();

        // Ensure we have a session
        let session = currentSession;
        if (!session) {
          session = await createSession();
        }

        // Create user message
        const userMessage: AgentMessage = {
          id: generateId(),
          role: 'user',
          text,
          timestamp: Date.now(),
          attachments: attachments.length > 0 ? attachments : undefined,
        };

        // Add user message to chat
        setMessages((prev) => [...prev, userMessage]);
        onMessageSent?.(userMessage);

        // Prepare message parts
        const parts: MessagePart[] = [{ text }];

        // Add file attachments
        for (const attachment of attachments) {
          const fileData = await readFileAsBase64(attachment.file);
          // Ensure mimeType is compatible with MessagePart's inlineData
          const mimeType =
            typeof attachment.file.type === 'string'
              ? attachment.file.type
              : 'application/octet-stream'; // Fallback if type is not a string
          parts.push({
            inlineData: {
              displayName: attachment.file.name,
              data: fileData,
              mimeType: mimeType,
            },
          });
        }

        // Create agent run request
        const request: AgentRunRequest = {
          appName,
          userId,
          sessionId: session.id,
          newMessage: {
            role: 'user',
            parts,
          },
          streaming: enableStreaming,
        };

        // Send request
        if (enableStreaming) {
          await sendStreamingRequest(request);
        } else {
          await sendRegularRequest(request);
        }

        // Clear input and files
        setInputValue('');
        setSelectedFiles([]);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error.message);
        onError?.(error);
      } finally {
        setIsLoading(false);
        setIsTyping(false);
        onTypingStop?.();
      }
    },
    [
      currentSession,
      createSession,
      appName,
      userId,
      enableStreaming,
      onMessageSent,
      onError,
      onTypingStart,
      onTypingStop,
    ]
  );

  /**
   * Send streaming request using Server-Sent Events
   */
  const sendStreamingRequest = useCallback(
    async (request: AgentRunRequest) => {
      return new Promise<void>((resolve, reject) => {
        const eventSource = new EventSource(`${apiBaseUrl}/run_sse`);
        eventSourceRef.current = eventSource;

        // Send the request
        fetch(`${apiBaseUrl}/run_sse`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(request),
        }).catch(reject);

        let streamingMessage: AgentMessage | null = null;

        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            if (data.error) {
              reject(new Error(data.error));
              return;
            }

            if (data.content?.parts) {
              for (const part of data.content.parts) {
                // Handle streaming text responses
                if (part.text) {
                  if (!streamingMessage) {
                    streamingMessage = {
                      id: generateId(),
                      role: 'bot',
                      text: part.text,
                      timestamp: Date.now(),
                      eventId: data.id,
                      thought: part.thought,
                    };
                    setMessages((prev) => [...prev, streamingMessage!]);
                  } else {
                    streamingMessage.text =
                      (streamingMessage.text || '') + part.text;
                    setMessages((prev) =>
                      prev.map((msg) =>
                        msg.id === streamingMessage!.id
                          ? { ...streamingMessage! }
                          : msg
                      )
                    );
                  }
                }

                // Handle function calls
                if (part.functionCall) {
                  const functionCallMessage: AgentMessage = {
                    id: generateId(),
                    role: 'bot',
                    timestamp: Date.now(),
                    eventId: data.id,
                    functionCall: part.functionCall,
                  };
                  setMessages((prev) => [...prev, functionCallMessage]);
                  onMessageReceived?.(functionCallMessage);
                }

                // Handle function responses
                if (part.functionResponse) {
                  const functionResponseMessage: AgentMessage = {
                    id: generateId(),
                    role: 'bot',
                    timestamp: Date.now(),
                    eventId: data.id,
                    functionResponse: part.functionResponse,
                  };
                  setMessages((prev) => [...prev, functionResponseMessage]);
                  onMessageReceived?.(functionResponseMessage);
                }

                // Handle executable code blocks
                if (part.executableCode) {
                  const codeMessage: AgentMessage = {
                    id: generateId(),
                    role: 'bot',
                    timestamp: Date.now(),
                    eventId: data.id,
                    executableCode: part.executableCode,
                  };
                  setMessages((prev) => [...prev, codeMessage]);
                  onMessageReceived?.(codeMessage);
                }

                // Handle code execution results
                if (part.codeExecutionResult) {
                  const resultMessage: AgentMessage = {
                    id: generateId(),
                    role: 'bot',
                    timestamp: Date.now(),
                    eventId: data.id,
                    codeExecutionResult: part.codeExecutionResult,
                  };
                  setMessages((prev) => [...prev, resultMessage]);
                  onMessageReceived?.(resultMessage);
                }
              }
            }
          } catch (err) {
            console.error('Error parsing SSE data:', err);
          }
        };

        eventSource.onerror = () => {
          eventSource.close();
          resolve();
        };

        eventSource.addEventListener('close', () => {
          eventSource.close();
          resolve();
        });
      });
    },
    [apiBaseUrl, onMessageReceived]
  );

  /**
   * Send regular (non-streaming) request
   */
  const sendRegularRequest = useCallback(
    async (request: AgentRunRequest) => {
      const response = await fetch(`${apiBaseUrl}/run`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request),
      });

      if (!response.ok) throw new Error('Failed to send message');

      const data = await response.json();

      if (data.content?.parts) {
        for (const part of data.content.parts) {
          const botMessage: AgentMessage = {
            id: generateId(),
            role: 'bot',
            text: part.text,
            timestamp: Date.now(),
            eventId: data.id,
            thought: part.thought,
            functionCall: part.functionCall,
            functionResponse: part.functionResponse,
            executableCode: part.executableCode,
            codeExecutionResult: part.codeExecutionResult,
          };

          setMessages((prev) => [...prev, botMessage]);
          onMessageReceived?.(botMessage);
        }
      }
    },
    [apiBaseUrl, onMessageReceived]
  );

  /**
   * Handle file selection
   */
  const handleFileSelect = useCallback(
    (files: FileList | File[]) => {
      const fileArray = Array.from(files);
      const validFiles: MessageAttachment[] = [];

      for (const file of fileArray) {
        // Check file size
        if (file.size > maxFileSize) {
          setError(
            `File ${file.name} is too large. Maximum size is ${
              maxFileSize / 1024 / 1024
            }MB`
          );
          continue;
        }

        // Check file type
        const isAllowed = allowedFileTypes.some((type) => {
          if (type.endsWith('/*')) {
            return file.type.startsWith(type.slice(0, -1));
          }
          return file.type === type;
        });

        if (!isAllowed) {
          setError(`File type ${file.type} is not allowed`);
          continue;
        }

        // Check total file count
        if (selectedFiles.length + validFiles.length >= maxFiles) {
          setError(`Maximum ${maxFiles} files allowed`);
          break;
        }

        const attachment: MessageAttachment = {
          file,
          url: URL.createObjectURL(file),
          type: file.type, // Use the shared helper function
        };

        validFiles.push(attachment);
      }

      if (validFiles.length > 0) {
        setSelectedFiles((prev) => [...prev, ...validFiles]);
        // onFileUpload expects File[], so map UploadedFile back to File if necessary
        onFileUpload?.(validFiles.map((f) => f.file));
      }
    },
    [
      maxFileSize,
      allowedFileTypes,
      maxFiles,
      selectedFiles.length,
      onFileUpload,
    ]
  );

  /**
   * Remove selected file
   */
  const removeFile = useCallback((index: number) => {
    setSelectedFiles((prev) => {
      const newFiles = [...prev];
      URL.revokeObjectURL(newFiles[index].url);
      newFiles.splice(index, 1);
      return newFiles;
    });
  }, []);

  /**
   * Utility function to read file as base64
   * Handles both File and UploadedFile types.
   */
  const readFileAsBase64 = async (file: File): Promise<string> => {
    if (file instanceof File) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const result = e.target?.result as string;
          const base64Data = result.split(',')[1];
          resolve(base64Data);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    } else if (file) {
      const localUrl = URL.createObjectURL(file);
      // If it's an UploadedFile with a localUrl, fetch it
      const response = await fetch(localUrl);
      const blob = await response.blob();
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const result = e.target?.result as string;
          const base64Data = result.split(',')[1];
          resolve(base64Data);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error(
      'Cannot read file: neither File nor UploadedFile with localUrl'
    );
  };

  /**
   * Initialize session on mount
   */
  useEffect(() => {
    if (!currentSession && !initialSessionId) {
      createSession();
    }
  }, [currentSession, initialSessionId, createSession]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      // Cleanup file URLs
      selectedFiles.forEach((file) => URL.revokeObjectURL(file.url));
    };
  }, [selectedFiles]);

  return {
    // State
    messages,
    currentSession,
    isLoading,
    isTyping,
    error,
    inputValue,
    selectedFiles,
    isConnected,
    sessionId,

    // Actions
    sendMessage,
    setInputValue,
    handleFileSelect,
    removeFile,
    createSession,

    // Refs
    messagesEndRef,

    // Additional state setters for view component
    setError,
    setSelectedFiles,
  };
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/MessageAttachmentPreview.tsx">
import React from 'react';
import { View, Button, Image, Center } from 'app-studio';
import { MessageAttachment } from './AgentChat.props';
import { DefaultAgentChatStyles } from './AgentChat.style';
import { HoverCard } from '../../../HoverCard/HoverCard';
import { FileIcon, AudioIcon } from '../../../Icon/Icon';

export interface MessageAttachmentPreviewProps {
  attachment: MessageAttachment;
  onRemove?: () => void;
}

/**
 * MessageAttachmentPreview Component
 *
 * Shows a preview of attached files with the ability to remove them
 */
export const MessageAttachmentPreview: React.FC<
  MessageAttachmentPreviewProps
> = ({ attachment, onRemove }) => {
  const { file, url, type } = attachment;
  const lowerType = type.toLowerCase();
  const isImage = lowerType.startsWith('image/');
  const isVideo = lowerType.startsWith('video/');
  const isAudio = lowerType.startsWith('audio/');

  return (
    <View {...DefaultAgentChatStyles.attachmentPreview}>
      {onRemove && (
        <Button
          {...DefaultAgentChatStyles.attachmentRemove}
          onClick={(e) => {
            e.stopPropagation();
            onRemove();
          }}
          aria-label={`Remove ${file.name}`}
        >
          ×
        </Button>
      )}

      <HoverCard>
        <HoverCard.Trigger>
          {isImage && (
            <Image
              src={url}
              alt={file.name}
              width="60px"
              height="60px"
              objectFit="cover"
            />
          )}
          {isVideo && (
            <View
              as="video"
              src={url}
              width="60px"
              height="60px"
              style={{ objectFit: 'cover' }}
              muted
            />
          )}
          {isAudio && (
            <Center width="60px" height="60px" backgroundColor="color.gray.200">
              <AudioIcon widthHeight={24} color="color.gray.600" />
            </Center>
          )}
          {!isImage && !isVideo && !isAudio && (
            <Center width="60px" height="60px" backgroundColor="color.gray.200">
              <FileIcon widthHeight={24} color="color.gray.600" />
            </Center>
          )}
        </HoverCard.Trigger>
        <HoverCard.Content>
          {isImage && <Image src={url} alt={file.name} maxWidth="300px" />}
          {isVideo && (
            <View as="video" src={url} controls style={{ maxWidth: '300px' }} />
          )}
          {isAudio && <View as="audio" src={url} controls />}
        </HoverCard.Content>
      </HoverCard>
    </View>
  );
};
</file>

<file path="src/components/ChatInput/examples/AudioWaveformChatInput.tsx">
import React, { useState, useRef } from 'react';
import { View, Vertical, Text } from 'app-studio';
import ChatInputView from '../ChatInput/ChatInput.view';

export const AudioWaveformChatInputDemo = () => {
  const [inputValue, setInputValue] = useState('');
  const [submittedMessage, setSubmittedMessage] = useState('');
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  // Audio recording is handled internally by ChatInput's AudioRecorder.

  const handleSubmit = () => {
    if (inputValue.trim() || uploadedFiles.length > 0) {
      setSubmittedMessage(inputValue || 'Message with audio attachment');
      setInputValue('');
      setUploadedFiles([]);
    }
  };

  return (
    <Vertical gap={20} padding="20px" maxWidth="600px">
      <Text fontSize="18px" fontWeight="bold">
        Chat Input with Audio Waveform Demo
      </Text>

      <Text fontSize="14px" color="color.gray.600">
        Features: • Audio recording with live waveform visualization • Text
        input • File attachments
      </Text>

      <View
        border="1px solid"
        borderColor="color.gray.300"
        borderRadius="8px"
        padding="16px"
        backgroundColor="color.white"
      >
        <Vertical gap={12}>
          <ChatInputView
            value={inputValue}
            handleChange={setInputValue}
            handleSubmit={handleSubmit}
            placeholder="Type your message or record audio..."
            enableAudioRecording={true}
            uploadedFiles={uploadedFiles}
            setUploadedFiles={setUploadedFiles}
            removeUploadedFile={(index: number) => {
              setUploadedFiles((prevFiles) =>
                prevFiles.filter((_, i) => i !== index)
              );
            }}
            setPendingFiles={() => {}} // Mock function
            setIsUploading={() => {}} // Mock function
            getPendingFiles={() => []}
            clearPendingFiles={() => {}}
            onSubmit={handleSubmit}
            editableRef={useRef<HTMLDivElement>(null)}
            fileInputRef={useRef<HTMLInputElement>(null)}
            isUploading={false}
            isDraggingOver={false}
            selectedModel={''}
            handleModelChange={() => {}}
            modelOptions={[]}
            canAccessModel={() => true}
            isGuideTipShown={false}
            hideGuideTip={() => {}}
            handlePromptExampleSelect={() => {}}
            handleDragOver={() => {}}
            handleDragLeave={() => {}}
            views={{
              editableInput: {
                minHeight: '60px',
                maxHeight: '150px',
              },
            }}
          />
        </Vertical>
      </View>

      {submittedMessage && (
        <View
          padding="12px"
          backgroundColor="color.green.50"
          border="1px solid"
          borderColor="color.green.200"
          borderRadius="6px"
        >
          <Text fontSize="14px" fontWeight="medium" color="color.green.800">
            Submitted Message:
          </Text>
          <Text
            fontSize="14px"
            color="color.green.700"
            marginTop="4px"
            whiteSpace="pre-wrap"
          >
            {submittedMessage}
          </Text>
        </View>
      )}
    </Vertical>
  );
};
</file>

<file path="src/components/ChatInput/ChatUploader.tsx">
import React, { forwardRef, useEffect } from 'react';
import { Button, Horizontal } from 'app-studio';
import { useUpload } from '../Uploader/Uploader/Uploader.state';
import { AttachmentIcon, LoadingSpinnerIcon } from '../Icon/Icon';

interface ChatUploaderProps {
  loading: boolean;
  disabled: boolean;
  isAgentRunning: boolean;
  isUploading: boolean;
  hideAttachments?: boolean;
  sandboxId?: string;
  setPendingFiles: React.Dispatch<React.SetStateAction<File[]>>;
  setUploadedFiles: React.Dispatch<React.SetStateAction<File[]>>;
  setIsUploading: React.Dispatch<React.SetStateAction<boolean>>;
  views?: {
    button?: any;
    icon?: any;
    text?: any;
    tooltip?: any;
  };
}

/**
 * Handle local files without uploading to server
 */
const handleLocalFiles = (
  files: File[],
  setPendingFiles: React.Dispatch<React.SetStateAction<File[]>>,
  setUploadedFiles: React.Dispatch<React.SetStateAction<File[]>>
) => {
  // Filter files that exceed size limit
  const filteredFiles = files.filter((file) => {
    if (file.size > 50 * 1024 * 1024) {
      console.error(`File size exceeds 50MB limit: ${file.name}`);
      return false;
    }
    return true;
  });

  // Add files to pending files
  setPendingFiles((prevFiles) => [...prevFiles, ...filteredFiles]);

  // Add files to uploaded files
  setUploadedFiles((prev) => [...prev, ...filteredFiles]);
};

/**
 * Handle files based on whether a sandboxId is available
 */
const handleFiles = async (
  files: File[],
  sandboxId: string | undefined,
  setPendingFiles: React.Dispatch<React.SetStateAction<File[]>>,
  setUploadedFiles: React.Dispatch<React.SetStateAction<File[]>>,
  setIsUploading: React.Dispatch<React.SetStateAction<boolean>>
) => {
  // If no sandboxId, just handle files locally
  handleLocalFiles(files, setPendingFiles, setUploadedFiles);
};

export const ChatUploader = forwardRef<HTMLInputElement, ChatUploaderProps>(
  (
    {
      loading,
      disabled,
      isAgentRunning,
      isUploading,
      sandboxId,
      hideAttachments,
      setPendingFiles,
      setUploadedFiles,
      setIsUploading,
      views = {},
    },
    ref
  ) => {
    // Validate file size (50MB limit for chat)
    const validateFile = (file: File): string | null => {
      if (file.size > 50 * 1024 * 1024) {
        return `File size exceeds 50MB limit`;
      }
      return null;
    };

    // Handle multiple file selection
    const handleMultipleFileSelect = async (files: File[]) => {
      await handleFiles(
        files,
        sandboxId,
        setPendingFiles,
        setUploadedFiles,
        setIsUploading
      );
    };

    // Use the Uploader hook for file handling
    const { fileInputRef, handleClick, handleFileChange } = useUpload({
      accept: '*/*',
      maxSize: 50 * 1024 * 1024, // 50MB limit
      multiple: true,
      onMultipleFileSelect: handleMultipleFileSelect,
      validateFile,
    });

    // Clean up object URLs when component unmounts
    useEffect(() => {
      return () => {
        setUploadedFiles((prev) => {
          // prev.forEach((file) => {
          //   if (file) {
          //     URL.revokeObjectURL(file);
          //   }
          // });
          return prev;
        });
      };
    }, [setUploadedFiles]);

    return (
      <>
        {hideAttachments && (
          <Button
            type="button"
            onClick={handleClick}
            variant="ghost"
            height="36px"
            padding="0 12px"
            border={'1px solid'}
            borderRadius="8px"
            backgroundColor="transparent"
            color="color.gray.500"
            disabled={loading || (disabled && !isAgentRunning) || isUploading}
            _hover={{
              backgroundColor: 'color.gray.100',
            }}
            {...views?.button}
          >
            <Horizontal gap={4} alignItems="center">
              {isUploading ? (
                <LoadingSpinnerIcon
                  widthHeight={16}
                  color="currentColor"
                  filled={false}
                  style={{ animation: 'spin 1s linear infinite' }}
                  {...views?.icon}
                />
              ) : (
                <AttachmentIcon
                  widthHeight={16}
                  color="currentColor"
                  filled={false}
                  {...views?.icon}
                />
              )}
            </Horizontal>
          </Button>
        )}

        <input
          type="file"
          ref={ref || fileInputRef}
          style={{ display: 'none' }}
          onChange={handleFileChange}
          multiple
          accept="*/*"
        />
      </>
    );
  }
);

ChatUploader.displayName = 'ChatUploader';
</file>

<file path="src/components/ChatInput/index.ts">
export { ChatInput } from './ChatInput';
export { AttachmentGroup } from './AttachmentGroup';
export { EditableInput } from './EditableInput';
export { ChatUploader } from './ChatUploader';
export { GuideTip } from './GuideTip';
export { PromptExamples } from './PromptExamples';
export { AudioRecorder } from './AudioRecorder';
</file>

<file path="src/components/ChatInput/ChatInput/ChatInput.style.ts">
import { ViewProps } from 'app-studio';
import { Shape, Size, Variant } from './ChatInput.type';

/**
 * Default styles for the ChatInput component
 */
export const DefaultChatInputStyles = {
  container: {
    width: '100%',
    maxWidth: '100%',
    borderRadius: '12px',
    backgroundColor: 'color.white',
    transition: 'all 0.2s ease',
  },
  content: {
    width: '100%',
    padding: '12px',
    borderRadius: '12px',
    backgroundColor: 'color.white',
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: 'color.gray.200',
  },
  textarea: {
    width: '100%',
    minHeight: '40px',
    maxHeight: '200px',
    padding: '8px 12px',
    fontSize: '14px',
    lineHeight: '1.5',
    color: 'color.gray.900',
    backgroundColor: 'color.white',
    border: 'none',
    outline: 'none',
    resize: 'none',
    overflow: 'auto',
  },
  attachments: {
    display: 'flex',
    flexWrap: 'wrap',
    gap: '6px',
    padding: '8px 0',
  },
  attachmentItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
    padding: '4px 8px',
    borderRadius: '6px',
    backgroundColor: 'color.gray.100',
  },
  attachmentName: {
    fontSize: '12px',
    fontWeight: '500',
    color: 'color.gray.700',
  },
  attachmentSize: {
    fontSize: '10px',
    color: 'color.gray.500',
  },
  attachmentRemove: {
    padding: '2px',
    borderRadius: '50%',
    cursor: 'pointer',
    color: 'color.gray.500',
    backgroundColor: 'transparent',
    transition: 'all 0.2s ease',
  },
  submitButton: {
    height: '36px',
    minWidth: '36px',
    padding: '0 12px',
    borderRadius: '8px',
    backgroundColor: 'theme.primary',
    color: 'color.white',
    transition: 'all 0.2s ease',
  },
  fileButton: {
    height: '36px',
    padding: '0 12px',
    borderRadius: '8px',
    backgroundColor: 'transparent',
    color: 'color.gray.500',
    transition: 'all 0.2s ease',
  },
  modelSelector: {
    height: '36px',
    padding: '0 12px',
    borderRadius: '8px',
    backgroundColor: 'transparent',
    color: 'color.gray.500',
    transition: 'all 0.2s ease',
  },
  loadingIndicator: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: '8px',
    padding: '8px 0',
  },
};

/**
 * Shape styles for the ChatInput component
 */
export const Shapes: Record<Shape, ViewProps> = {
  default: {
    borderRadius: '8px',
  },
  sharp: {
    borderRadius: '0px',
  },
  rounded: {
    borderRadius: '8px',
  },
};

/**
 * Size styles for the ChatInput component
 */
export const Sizes: Record<Size, ViewProps> = {
  xs: {
    fontSize: '10px',
    padding: '4px 8px',
  },
  sm: {
    fontSize: '12px',
    padding: '6px 10px',
  },
  md: {
    fontSize: '14px',
    padding: '8px 12px',
  },
  lg: {
    fontSize: '16px',
    padding: '10px 14px',
  },
  xl: {
    fontSize: '20px',
    padding: '12px 16px',
  },
};

/**
 * Variant styles for the ChatInput component
 */
export const Variants: Record<Variant, ViewProps> = {
  default: {
    backgroundColor: 'color.white',
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: 'color.gray.200',
  },
  outline: {
    backgroundColor: 'transparent',
    borderWidth: '1px',
    borderStyle: 'solid',
    borderColor: 'color.gray.300',
  },
  none: {
    backgroundColor: 'transparent',
    border: 'none',
  },
};
</file>

<file path="src/components/ChatInput/MessageInput.tsx">
import React, { forwardRef } from 'react';
import { Button, Element, Horizontal, View, useTheme } from 'app-studio';
import { ChatUploader } from './ChatUploader';
import { ModelOption } from './ChatInput/ChatInput.type';

interface MessageInputProps {
  value: string;
  onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: (e: React.FormEvent) => void;
  placeholder?: string;
  loading?: boolean;
  disabled?: boolean;
  isAgentRunning?: boolean;
  onStopAgent?: () => void;
  isDraggingOver?: boolean;
  uploadedFiles: File[];

  fileInputRef: React.RefObject<HTMLInputElement>;
  isUploading: boolean;
  sandboxId?: string;
  setPendingFiles: React.Dispatch<React.SetStateAction<File[]>>;
  setUploadedFiles: React.Dispatch<React.SetStateAction<File[]>>;
  setIsUploading: React.Dispatch<React.SetStateAction<boolean>>;
  hideAttachments?: boolean;

  selectedModel: string;
  onModelChange: (model: string) => void;
  modelOptions: ModelOption[];
  subscriptionStatus?: string;
  canAccessModel: (model: string) => boolean;

  views?: {
    container?: any;
    textarea?: any;
    buttonGroup?: any;
    submitButton?: any;
    submitIcon?: any;
    modelSelector?: any;
  };
}

export const MessageInput = forwardRef<HTMLTextAreaElement, MessageInputProps>(
  (
    {
      value,
      onChange,
      onSubmit,
      placeholder = 'Describe what you need help with...',
      loading = false,
      disabled = false,
      isAgentRunning = false,
      onStopAgent,
      isDraggingOver = false,
      uploadedFiles,

      fileInputRef,
      isUploading,
      sandboxId,
      setPendingFiles,
      setUploadedFiles,
      setIsUploading,
      hideAttachments = true,

      selectedModel,
      onModelChange,
      modelOptions,
      subscriptionStatus,
      canAccessModel,

      views = {},
    },
    ref
  ) => {
    const { getColor } = useTheme();

    // Handle textarea resize
    const handleTextareaResize = (
      e: React.ChangeEvent<HTMLTextAreaElement>
    ) => {
      const textarea = e.target;
      textarea.style.height = 'auto';
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
    };

    // Handle combined change event
    const handleCombinedChange = (
      e: React.ChangeEvent<HTMLTextAreaElement>
    ) => {
      onChange(e);
      handleTextareaResize(e);
    };

    // Handle key down event
    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        onSubmit(e as unknown as React.FormEvent);
      }
    };

    return (
      <View
        width="100%"
        position="relative"
        backgroundColor={isDraggingOver ? 'color.blue.50' : undefined}
        transition="background-color 0.2s ease"
        {...views?.container}
      >
        <Element
          as="textarea"
          ref={ref}
          value={value}
          onChange={handleCombinedChange}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          disabled={disabled && !isAgentRunning}
          width="100%"
          minHeight="40px"
          maxHeight="200px"
          padding="8px 12px"
          fontSize="14px"
          lineHeight="1.5"
          color="color.gray.900"
          backgroundColor="transparent"
          border="none"
          outline="none"
          resize="none"
          overflow="auto"
          {...views?.textarea}
        />

        <Horizontal
          justifyContent="space-between"
          alignItems="center"
          padding="4px 8px"
          {...views?.buttonGroup}
        >
          <Horizontal gap={8} alignItems="center">
            <ChatUploader
              ref={fileInputRef}
              loading={loading}
              disabled={disabled}
              isAgentRunning={isAgentRunning}
              isUploading={isUploading}
              sandboxId={sandboxId}
              setPendingFiles={setPendingFiles}
              setUploadedFiles={setUploadedFiles}
              setIsUploading={setIsUploading}
              hideAttachments={hideAttachments}
            />

            {/* Model selector */}
            <View
              as="select"
              value={selectedModel}
              onChange={(e: React.ChangeEvent<HTMLSelectElement>) =>
                onModelChange(e.target.value)
              }
              height="36px"
              padding="0 12px"
              borderRadius="8px"
              backgroundColor="transparent"
              color="color.gray.500"
              border="none"
              outline="none"
              cursor="pointer"
              transition="all 0.2s ease"
              _hover={{
                backgroundColor: 'color.gray.100',
              }}
              {...views?.modelSelector}
            >
              {modelOptions.map((model) => (
                <option key={model.id} value={model.id}>
                  {model.name}
                </option>
              ))}
            </View>
          </Horizontal>

          <Button
            type="submit"
            onClick={onSubmit}
            height="36px"
            minWidth="36px"
            padding="0 12px"
            borderRadius="8px"
            backgroundColor={isAgentRunning ? 'theme.error' : 'theme.primary'}
            color="color.white"
            disabled={
              (!value.trim() && uploadedFiles.length === 0) ||
              loading ||
              (disabled && !isAgentRunning)
            }
            _hover={{
              backgroundColor: isAgentRunning
                ? 'color.red.600'
                : 'color.blue.600',
            }}
            {...views?.submitButton}
          >
            {isAgentRunning ? (
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                {...views?.submitIcon}
              >
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              </svg>
            ) : loading ? (
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                style={{ animation: 'spin 1s linear infinite' }}
                {...views?.submitIcon}
              >
                <line x1="12" y1="2" x2="12" y2="6"></line>
                <line x1="12" y1="18" x2="12" y2="22"></line>
                <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
                <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
                <line x1="2" y1="12" x2="6" y2="12"></line>
                <line x1="18" y1="12" x2="22" y2="12"></line>
                <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
                <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
              </svg>
            ) : (
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                {...views?.submitIcon}
              >
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
              </svg>
            )}
          </Button>
        </Horizontal>
      </View>
    );
  }
);

MessageInput.displayName = 'MessageInput';
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.style.ts">
import { ViewProps } from 'app-studio';

/**
 * Default styles for AgentChat component
 * Following the app-studio design system with 4px grid, Inter/Geist fonts, and neutral palette
 */
export const DefaultAgentChatStyles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    backgroundColor: 'color.white',
    borderRadius: '12px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    fontFamily: 'Inter, system-ui, sans-serif',
    position: 'relative',
  } as ViewProps,

  header: {
    padding: '16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  messageList: {
    flex: 1,
    overflowY: 'auto',
    backgroundColor: 'color.white',
    minHeight: '300px',
    maxHeight: '600px',
  } as ViewProps,

  emptyState: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '200px',
    padding: '32px',
  } as ViewProps,

  inputArea: {
    padding: '16px',
    borderTop: '1px solid',
    borderTopColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
    flexShrink: 0,
  } as ViewProps,

  attachmentArea: {
    padding: '12px 16px',
    borderTop: '1px solid',
    borderTopColor: 'color.gray.200',
    backgroundColor: 'color.gray.100',
    flexShrink: 0,
  } as ViewProps,

  message: {
    padding: '12px',
    borderRadius: '8px',
    maxWidth: '80%',
    wordBreak: 'break-word',
  } as ViewProps,

  userMessage: {
    backgroundColor: 'color.blue.500',
    color: 'white',
    alignSelf: 'flex-end',
    marginLeft: 'auto',
  } as ViewProps,

  botMessage: {
    backgroundColor: 'color.gray.100',
    color: 'color.gray.900',
    alignSelf: 'flex-start',
    marginRight: 'auto',
  } as ViewProps,

  thoughtMessage: {
    backgroundColor: 'color.yellow.50',
    color: 'color.yellow.800',
    border: '1px solid',
    borderColor: 'color.yellow.200',
    fontStyle: 'italic',
  } as ViewProps,

  loadingMessage: {
    backgroundColor: 'color.gray.50',
    color: 'color.gray.600',
    border: '1px dashed',
    borderColor: 'color.gray.300',
  } as ViewProps,

  messageHeader: {
    marginBottom: '4px',
  } as ViewProps,

  messageContent: {
    lineHeight: 1.5,
  } as ViewProps,

  messageFooter: {
    marginTop: '8px',
  } as ViewProps,

  timestamp: {
    fontSize: '12px',
    color: 'color.gray.500',
    marginTop: '4px',
  } as ViewProps,

  avatar: {
    width: '32px',
    height: '32px',
    borderRadius: '50%',
    backgroundColor: 'color.gray.300',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '14px',
    fontWeight: '600',
    color: 'white',
    flexShrink: 0,
  } as ViewProps,

  userAvatar: {
    backgroundColor: 'color.blue.500',
  } as ViewProps,

  botAvatar: {
    backgroundColor: 'color.green.500',
  } as ViewProps,

  attachmentPreview: {
    position: 'relative',
    display: 'inline-block',
    width: '60px',
    height: '60px',
    backgroundColor: 'color.gray.100',
    borderRadius: '8px',
    border: '1px solid',
    borderColor: 'color.gray.200',
    overflow: 'hidden',
    cursor: 'pointer',
  } as ViewProps,

  attachmentRemove: {
    position: 'absolute',
    top: '2px',
    right: '2px',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    backgroundColor: 'color.black.900',
    color: 'white',
    border: 'none',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '12px',
    zIndex: 1,
  } as ViewProps,

  typingIndicator: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    padding: '12px',
    backgroundColor: 'color.gray.100',
    borderRadius: '8px',
    maxWidth: '80px',
    alignSelf: 'flex-start',
  } as ViewProps,

  typingDot: {
    width: '6px',
    height: '6px',
    borderRadius: '50%',
    backgroundColor: 'color.gray.500',
  } as ViewProps,

  functionCall: {
    backgroundColor: 'color.purple.50',
    border: '1px solid',
    borderColor: 'color.purple.200',
    borderRadius: '8px',
    padding: '12px',
    marginTop: '8px',
  } as ViewProps,

  functionResponse: {
    backgroundColor: 'color.green.50',
    border: '1px solid',
    borderColor: 'color.green.200',
    borderRadius: '8px',
    padding: '12px',
    marginTop: '8px',
  } as ViewProps,

  codeBlock: {
    backgroundColor: 'color.gray.900',
    color: 'color.gray.100',
    borderRadius: '8px',
    padding: '12px',
    fontFamily: 'Monaco, Consolas, monospace',
    fontSize: '14px',
    overflow: 'auto',
    marginTop: '8px',
  } as ViewProps,

  inlineData: {
    marginTop: '8px',
    borderRadius: '8px',
    overflow: 'hidden',
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,

  errorMessage: {
    backgroundColor: 'color.red.50',
    color: 'color.red.800',
    border: '1px solid',
    borderColor: 'color.red.200',
    borderRadius: '8px',
    padding: '12px',
    margin: '8px 16px',
  } as ViewProps,

  loadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 10,
  } as ViewProps,

  runProgress: {
    padding: '12px 16px',
    borderBottom: '1px solid',
    borderBottomColor: 'color.gray.200',
    backgroundColor: 'color.gray.50',
  } as ViewProps,
};

/**
 * Animation styles for typing indicator
 */
export const TypingAnimationStyles = {
  dot1: {
    animationDelay: '0ms',
  },
  dot2: {
    animationDelay: '150ms',
  },
  dot3: {
    animationDelay: '300ms',
  },
};

/**
 * Responsive breakpoints for AgentChat
 */
export const AgentChatBreakpoints = {
  mobile: '(max-width: 768px)',
  tablet: '(max-width: 1024px)',
  desktop: '(min-width: 1025px)',
};

/**
 * Size variants for AgentChat
 */
export const AgentChatSizes = {
  sm: {
    container: { height: '400px' },
    messageList: { minHeight: '200px', maxHeight: '300px' },
  },
  md: {
    container: { height: '500px' },
    messageList: { minHeight: '300px', maxHeight: '400px' },
  },
  lg: {
    container: { height: '600px' },
    messageList: { minHeight: '400px', maxHeight: '500px' },
  },
  xl: {
    container: { height: '700px' },
    messageList: { minHeight: '500px', maxHeight: '600px' },
  },
};

/**
 * Theme variants for AgentChat
 */
export const AgentChatThemes = {
  light: {
    container: { backgroundColor: 'color.white' },
    header: { backgroundColor: 'color.gray.50' },
    messageList: { backgroundColor: 'color.white' },
    inputArea: { backgroundColor: 'color.gray.50' },
  },
  dark: {
    container: { backgroundColor: 'color.gray.900' },
    header: { backgroundColor: 'color.gray.800' },
    messageList: { backgroundColor: 'color.gray.900' },
    inputArea: { backgroundColor: 'color.gray.800' },
  },
};
</file>

<file path="src/components/adk/AgentChat/AgentChat/AgentChat.view.tsx">
import React, { useEffect } from 'react';
import { View, Vertical, Horizontal, Text } from 'app-studio';
import { ChatInput } from '../../../ChatInput/ChatInput';
import { AgentChatProps } from './AgentChat.props';
import { useAgentChat } from './AgentChat.state';
import { DefaultAgentChatStyles } from './AgentChat.style';
import { AgentMessage } from './AgentMessage';
import { AgentTypingIndicator } from './AgentTypingIndicator';
import { MessageAttachmentPreview } from './MessageAttachmentPreview';
import { Loader } from '../../../Loader/Loader';
import { Alert } from '../../../Alert/Alert';
import { AgentRunProgress } from './AgentRunProgress';

export interface AgentChatViewProps
  extends Omit<AgentChatProps, 'sessionId'>,
    ReturnType<typeof useAgentChat> {}

/**
 * AgentChat View Component
 *
 * Renders the complete chat interface with message list, input area, and controls
 */
const AgentChatView: React.FC<AgentChatViewProps> = ({
  // Props
  placeholder = 'Type your message...',
  showTimestamps = true,
  showAvatars = true,
  showTypingIndicator = true,
  autoScroll = true,
  enableFileUpload = true,
  enableAudioRecording = false,
  enableVideoRecording = false,
  views,
  containerProps,
  colorScheme = 'blue',
  compact = false,
  rounded = true,
  ariaLabel = 'Agent Chat',
  ariaDescribedBy,

  // State from hook
  messages,
  currentSession,
  isLoading,
  isTyping,
  error,
  inputValue,
  selectedFiles,
  sessionId,
  sendMessage,
  setInputValue,
  handleFileSelect,
  removeFile,
  messagesEndRef,
  setError,
  setSelectedFiles,

  ...props
}) => {
  /**
   * Auto-scroll to bottom when new messages arrive
   */
  useEffect(() => {
    if (autoScroll && messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, autoScroll]);

  /**
   * Handle message send from ChatInput
   */
  const handleSubmit = async (
    message: string,
    _options?: { model_name?: string; enable_thinking?: boolean }
  ) => {
    if (message.trim() || selectedFiles.length > 0) {
      await sendMessage(message, selectedFiles);
    }
  };

  /**
   * Get pending files for ChatInput
   */
  const getPendingFiles = () => {
    return selectedFiles.map((f) => f.file);
  };

  /**
   * Clear pending files for ChatInput
   */
  const clearPendingFiles = () => {
    selectedFiles.forEach((file) => URL.revokeObjectURL(file.url));
    setSelectedFiles([]);
  };

  /**
   * Get dynamic styles based on theme props
   */
  const getThemeStyles = () => {
    const baseStyles = {
      borderRadius: rounded ? '12px' : '4px',
      padding: compact ? '8px' : '16px',
    };

    const colorStyles = {
      blue: { borderColor: 'color.blue.200' },
      purple: { borderColor: 'color.purple.200' },
      green: { borderColor: 'color.green.200' },
      orange: { borderColor: 'color.orange.200' },
      red: { borderColor: 'color.red.200' },
      gray: { borderColor: 'color.gray.200' },
    };

    return {
      ...baseStyles,
      ...colorStyles[colorScheme],
    };
  };

  return (
    <View
      {...DefaultAgentChatStyles.container}
      {...getThemeStyles()}
      {...containerProps}
      {...views?.container}
      {...props}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
    >
      {/* Header */}
      <View {...DefaultAgentChatStyles.header} {...views?.header}>
        <Horizontal justifyContent="space-between" alignItems="center">
          <Vertical gap={4}>
            <Text fontSize="lg" fontWeight="600">
              Agent Chat
            </Text>
            {currentSession && (
              <Text fontSize="sm" color="color.gray.600">
                Session: {sessionId?.slice(0, 8)}...
              </Text>
            )}
          </Vertical>

          {isLoading && (
            <Horizontal alignItems="center" gap={8}>
              <Loader size="sm" />
              <Text fontSize="sm" color="color.gray.600">
                Processing...
              </Text>
            </Horizontal>
          )}
        </Horizontal>
      </View>

      {/* Progress of agent run */}
      <AgentRunProgress messages={messages} isTyping={isTyping} />

      {/* Error Display */}
      {error && (
        <Alert
          variant="error"
          title=""
          description={error}
          onClose={() => setError?.(null)}
        >
          {error}
        </Alert>
      )}

      {/* Message List */}
      <View {...DefaultAgentChatStyles.messageList} {...views?.messageList}>
        <Vertical gap={16} padding={16}>
          {messages.length === 0 ? (
            <View {...DefaultAgentChatStyles.emptyState}>
              <Text color="color.gray.500" textAlign="center">
                Start a conversation with the agent
              </Text>
            </View>
          ) : (
            messages.map((message, index) => (
              <AgentMessage
                key={message.id}
                message={message}
                showTimestamp={showTimestamps}
                showAvatar={showAvatars}
                isLast={index === messages.length - 1}
                views={{
                  container:
                    message.role === 'user'
                      ? views?.userMessage
                      : views?.botMessage,
                  ...views?.message,
                }}
              />
            ))
          )}

          {/* Typing Indicator */}
          {showTypingIndicator && isTyping && <AgentTypingIndicator />}

          {/* Loading Message */}
          {isLoading && (
            <AgentMessage
              message={{
                id: 'loading',
                role: 'bot',
                text: '',
                timestamp: Date.now(),
                isLoading: true,
              }}
              showTimestamp={false}
              showAvatar={showAvatars}
              isLast={true}
            />
          )}

          {/* Scroll anchor */}
          <div ref={messagesEndRef} />
        </Vertical>
      </View>

      {/* File Attachments Preview */}
      {selectedFiles.length > 0 && (
        <View
          {...DefaultAgentChatStyles.attachmentArea}
          {...views?.attachmentArea}
        >
          <Horizontal gap={8} flexWrap="wrap">
            {selectedFiles.map((file, index) => (
              <MessageAttachmentPreview
                key={index}
                attachment={file}
                onRemove={() => removeFile(index)}
              />
            ))}
          </Horizontal>
        </View>
      )}

      {/* Input Area */}
      <View {...DefaultAgentChatStyles.inputArea} {...views?.inputArea}>
        <ChatInput
          onSubmit={handleSubmit}
          getPendingFiles={getPendingFiles}
          clearPendingFiles={clearPendingFiles}
          value={inputValue}
          onChange={setInputValue}
          placeholder={placeholder}
          loading={isLoading}
          disabled={isLoading}
          hideAttachments={!enableFileUpload}
          enableAudioRecording={enableAudioRecording}
          onAudioRecordingStart={props.onAudioRecordingStart}
          onAudioRecordingStop={props.onAudioRecordingStop}
          views={{
            container: views?.inputField,
          }}
        />
      </View>

      {/* Fullscreen Loading Overlay */}
      {isTyping && (
        <View {...DefaultAgentChatStyles.loadingOverlay}>
          <Horizontal gap={8} alignItems="center">
            <Loader size="md" />
            <Text color="color.gray.700">Thinking...</Text>
          </Horizontal>
        </View>
      )}
    </View>
  );
};

export default AgentChatView;
</file>

<file path="src/components/ChatInput/ChatInput/ChatInput.state.ts">
import { useState, useRef, useEffect } from 'react';
import { ChatInputProps } from './ChatInput.props';
import { ModelOption, PromptExample } from './ChatInput.type';

/**
 * Custom hook for managing ChatInput state
 */
export const useChatInputState = (props: ChatInputProps) => {
  const {
    value: controlledValue,
    onChange: controlledOnChange,
    onSubmit,
    autoFocus = true,
    loading = false,
    disabled = false,
    isAgentRunning = false,
    onStopAgent,
    sandboxId,
  } = props;

  // Determine if the component is controlled
  const isControlled =
    controlledValue !== undefined && controlledOnChange !== undefined;

  // State for uncontrolled input
  const [uncontrolledValue, setUncontrolledValue] = useState('');
  const value = isControlled ? controlledValue : uncontrolledValue;

  // State for file uploads
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [pendingFiles, setPendingFiles] = useState<File[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [isDraggingOver, setIsDraggingOver] = useState(false);

  // State for model selection
  const [selectedModel, setSelectedModel] = useState('gpt-4');
  const [modelOptions] = useState<ModelOption[]>([
    { id: 'gpt-3.5-turbo', name: 'GPT-3.5' },
    { id: 'gpt-4', name: 'GPT-4' },
    { id: 'gpt-4-thinking', name: 'GPT-4 (Thinking)', isThinking: true },
    { id: 'claude-3-5-sonnet', name: 'Claude 3.5 Sonnet' },
  ]);

  // Refs for DOM elements
  const editableRef = useRef<HTMLDivElement | null>(null);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  // State for UI features
  const [isGuideTipShown, setIsGuideTipShown] = useState(
    props.showGuideTip || false
  );

  // Focus the editable div on mount if autoFocus is true
  useEffect(() => {
    if (autoFocus && editableRef.current) {
      editableRef.current.focus();
    }
  }, [autoFocus]);

  // Clean up object URLs when component unmounts
  useEffect(() => {
    return () => {
      uploadedFiles.forEach((file) => {
        // if (file.localUrl) {
        //   URL.revokeObjectURL(file);
        // }
      });
    };
  }, [uploadedFiles]);

  // Handle input change for contenteditable
  const handleChange = (newValue: string) => {
    if (isControlled && controlledOnChange) {
      controlledOnChange(newValue);
    } else {
      setUncontrolledValue(newValue);
    }
  };

  // Handle form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (
      (!(value as string).trim() && uploadedFiles.length === 0) ||
      loading ||
      (disabled && !isAgentRunning)
    ) {
      return;
    }

    if (isAgentRunning && onStopAgent) {
      onStopAgent();
      return;
    }

    let message = value;

    // Add file information to the message if files are uploaded
    if (uploadedFiles.length > 0) {
      const fileInfo = uploadedFiles
        .map((file) => `[Uploaded File: ${URL.createObjectURL(file)}}]`)
        .join('\n');
      message = message ? `${message}\n\n${fileInfo}` : fileInfo;
    }

    // Determine model and thinking mode
    let baseModelName = selectedModel;
    let thinkingEnabled = false;

    if (selectedModel.endsWith('-thinking')) {
      baseModelName = selectedModel.replace(/-thinking$/, '');
      thinkingEnabled = true;
    }

    // Call the onSubmit callback
    onSubmit(message as string, {
      model_name: baseModelName,
      enable_thinking: thinkingEnabled,
    });

    // Clear the input if uncontrolled
    if (!isControlled) {
      setUncontrolledValue('');
    }

    // Clear uploaded files
    setUploadedFiles([]);
  };

  // Handle removing an uploaded file
  const removeUploadedFile = (index: number) => {
    setUploadedFiles((prev) => prev.filter((_, i) => i !== index));

    if (!sandboxId && pendingFiles.length > index) {
      setPendingFiles((prev) => prev.filter((_, i) => i !== index));
    }
  };

  // Handle drag events
  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingOver(true);
  };

  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingOver(false);
  };

  // Mock function for subscription status
  const subscriptionStatus = 'active';

  // Mock function to check if user can access a model
  const canAccessModel = (_model: string) => true;

  // Handle guide tip close
  const hideGuideTip = () => {
    setIsGuideTipShown(false);
    if (props.onGuideClose) {
      props.onGuideClose();
    }
  };

  // Handle prompt example selection
  const handlePromptExampleSelect = (example: PromptExample) => {
    if (isControlled && controlledOnChange) {
      controlledOnChange(example.text);
    } else {
      setUncontrolledValue(example.text);
    }

    if (props.onPromptExampleSelect) {
      props.onPromptExampleSelect(example);
    }

    // Focus the input after selecting an example
    if (editableRef.current) {
      editableRef.current.focus();
    }
  };

  return {
    value,
    handleChange,
    handleSubmit,
    editableRef,
    fileInputRef,
    isUploading,
    isDraggingOver,
    uploadedFiles,
    pendingFiles,
    removeUploadedFile,
    setPendingFiles,
    setUploadedFiles,
    setIsUploading,
    selectedModel,
    handleModelChange: setSelectedModel,
    modelOptions,
    subscriptionStatus,
    canAccessModel,
    handleDragOver,
    handleDragLeave,
    isGuideTipShown,
    hideGuideTip,
    handlePromptExampleSelect,
  };
};
</file>

<file path="src/components/ChatInput/EditableInput.tsx">
import React, {
  forwardRef,
  useEffect,
  useRef,
  useState,
  useCallback,
} from 'react';
import { View, Text, Vertical, useElementPosition } from 'app-studio';

export interface Suggestion {
  id: string;
  text: string;
  description?: string;
}

interface MentionData {
  id: string;
  name: string;
  avatar?: string;
  description?: string;
}

interface EditableInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  autoFocus?: boolean;
  suggestions?: Suggestion[];
  onSuggestionSelect?: (suggestion: Suggestion) => void;
  showSuggestions?: boolean;
  mentionData?: MentionData[];
  mentionTrigger?: string;
  onMentionSelect?: (mention: MentionData) => void;
  maxHeight?: string;
  minHeight?: string;
  views?: {
    container?: any;
    input?: any;
    placeholder?: any;
    suggestionsContainer?: any;
    suggestionItem?: any;
    mentionContainer?: any;
    mentionItem?: any;
  };
}

export const EditableInput = forwardRef<HTMLDivElement, EditableInputProps>(
  (
    {
      value,
      onChange,
      placeholder = 'Type your message...',
      disabled = false,
      autoFocus = true,
      suggestions = [],
      onSuggestionSelect,
      showSuggestions = false,
      mentionData = [],
      mentionTrigger = '@',
      onMentionSelect,
      maxHeight = '200px',
      minHeight = '40px',
      views = {},
    },
    ref
  ) => {
    const lastValueRef = useRef(value);
    const [selectedSuggestionIndex, setSelectedSuggestionIndex] = useState(-1);
    const [showPlaceholder, setShowPlaceholder] = useState(!value);
    const containerRef = useRef<HTMLDivElement>(null);
    const [isFocused, setIsFocused] = useState(false);

    // Mention-specific state
    const [showMentions, setShowMentions] = useState(false);
    const [mentionQuery, setMentionQuery] = useState('');
    const [mentionStartPos, setMentionStartPos] = useState(-1);
    const [selectedMentionIndex, setSelectedMentionIndex] = useState(-1);
    const [filteredMentions, setFilteredMentions] = useState<MentionData[]>([]);

    // Use useElementPosition for intelligent dropdown positioning
    const { ref: positionRef, relation } = useElementPosition({
      trackChanges: true,
      trackOnHover: true,
      trackOnScroll: true,
      trackOnResize: true,
    });

    // Positioning state for dropdowns
    const [mentionPosition, setMentionPosition] = useState({ x: 0, y: 0 });
    const [suggestionPosition, setSuggestionPosition] = useState({
      x: 0,
      y: 0,
    });

    // Update the content of the editable div when the value prop changes
    useEffect(() => {
      const editableDiv = ref as React.RefObject<HTMLDivElement>;
      if (editableDiv.current && value !== lastValueRef.current) {
        editableDiv.current.textContent = value;
        lastValueRef.current = value;
        setShowPlaceholder(!value);
      }
    }, [value, ref]);

    // Auto-focus effect
    useEffect(() => {
      if (autoFocus && ref && typeof ref === 'object' && ref.current) {
        ref.current.focus();
      }
    }, [autoFocus, ref]);

    // Get cursor position
    const getCursorPosition = () => {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return -1;

      const range = selection.getRangeAt(0);
      const preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(
        ref && typeof ref === 'object' && ref.current
          ? ref.current
          : document.body
      );
      preCaretRange.setEnd(range.endContainer, range.endOffset);
      return preCaretRange.toString().length;
    };

    // Check for mention trigger and filter mentions
    const checkForMentions = useCallback(
      (text: string, cursorPos: number) => {
        const beforeCursor = text.substring(0, cursorPos);
        const triggerIndex = beforeCursor.lastIndexOf(mentionTrigger);

        if (triggerIndex !== -1) {
          const afterTrigger = beforeCursor.substring(triggerIndex + 1);
          const hasSpaceAfterTrigger = afterTrigger.includes(' ');

          if (!hasSpaceAfterTrigger) {
            const query = afterTrigger.toLowerCase();
            const filtered = mentionData.filter((mention) =>
              mention.name.toLowerCase().includes(query)
            );

            setMentionQuery(query);
            setMentionStartPos(triggerIndex);
            setFilteredMentions(filtered);
            setShowMentions(filtered.length > 0);
            setSelectedMentionIndex(0);

            // Calculate position for mentions dropdown
            const position = calculateDropdownPosition();
            setMentionPosition(position);
            return;
          }
        }

        setShowMentions(false);
        setMentionQuery('');
        setMentionStartPos(-1);
        setSelectedMentionIndex(-1);
      },
      [mentionData, mentionTrigger]
    );

    // Sync the position ref with the container ref for positioning calculations
    useEffect(() => {
      if (containerRef.current && positionRef) {
        (positionRef as any).current = containerRef.current;
      }
    }, [containerRef, positionRef]);

    // Calculate optimal position for dropdowns using useElementPosition
    const calculateDropdownPosition = useCallback(
      (dropdownHeight: number = 200) => {
        if (!containerRef.current) return { x: 0, y: 0 };

        const containerRect = containerRef.current.getBoundingClientRect();

        // Use relation data for intelligent positioning if available
        if (relation) {
          const useTopPlacement = relation.space.vertical === 'top';
          return {
            x: containerRect.left,
            y: useTopPlacement
              ? containerRect.top - dropdownHeight - 8
              : containerRect.bottom + 8,
          };
        }

        // Fallback to manual calculation if relation data is not available
        const viewportHeight = window.innerHeight;
        const availableSpace = {
          top: containerRect.top,
          bottom: viewportHeight - containerRect.bottom,
        };

        const useTopPlacement =
          availableSpace.bottom < dropdownHeight + 8 &&
          availableSpace.top > availableSpace.bottom;

        return {
          x: containerRect.left,
          y: useTopPlacement
            ? containerRect.top - dropdownHeight - 8
            : containerRect.bottom + 8,
        };
      },
      [relation]
    );

    // Handle focus events
    const handleFocus = useCallback(() => {
      setIsFocused(true);
      // Calculate position for suggestions when focused
      const position = calculateDropdownPosition();
      setSuggestionPosition(position);
    }, [calculateDropdownPosition]);

    const handleBlur = useCallback(() => {
      // Delay hiding to allow for dropdown interactions
      setTimeout(() => {
        setIsFocused(false);
        setSelectedSuggestionIndex(-1);
      }, 150);
    }, []);

    // Handle input events
    const handleInput = (e: React.FormEvent<HTMLDivElement>) => {
      const newValue = e.currentTarget.textContent || '';
      if (newValue !== lastValueRef.current) {
        onChange(newValue);
        lastValueRef.current = newValue;
        setShowPlaceholder(!newValue);

        // Check for mentions
        const cursorPos = getCursorPosition();
        checkForMentions(newValue, cursorPos);
      }
    };

    // Handle mention selection
    const handleMentionSelect = useCallback(
      (mention: MentionData) => {
        if (ref && typeof ref === 'object' && ref.current) {
          const currentText = ref.current.textContent || '';
          const beforeMention = currentText.substring(0, mentionStartPos);
          const afterMention = currentText.substring(
            mentionStartPos + mentionTrigger.length + mentionQuery.length
          );
          const newText =
            beforeMention + mentionTrigger + mention.name + ' ' + afterMention;

          onChange(newText);
          lastValueRef.current = newText;
          ref.current.textContent = newText;

          // Set cursor position after the mention
          const newCursorPos =
            beforeMention.length +
            mentionTrigger.length +
            mention.name.length +
            1;
          setTimeout(() => {
            if (ref.current) {
              const range = document.createRange();
              const selection = window.getSelection();
              const textNode = ref.current.firstChild;
              if (textNode && selection) {
                range.setStart(
                  textNode,
                  Math.min(newCursorPos, textNode.textContent?.length || 0)
                );
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
              }
            }
          }, 0);
        }

        setShowMentions(false);
        setMentionQuery('');
        setMentionStartPos(-1);
        setSelectedMentionIndex(-1);

        if (onMentionSelect) {
          onMentionSelect(mention);
        }
      },
      [
        mentionStartPos,
        mentionTrigger,
        mentionQuery,
        onChange,
        onMentionSelect,
        ref,
      ]
    );

    // Handle suggestion selection
    const handleSuggestionSelect = useCallback(
      (suggestion: Suggestion) => {
        if (onSuggestionSelect) {
          onSuggestionSelect(suggestion);
        }
        setSelectedSuggestionIndex(-1);
      },
      [onSuggestionSelect]
    );

    // Handle key down events
    const handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {
      // Handle mention navigation
      if (showMentions && filteredMentions.length > 0) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          setSelectedMentionIndex((prev) =>
            prev < filteredMentions.length - 1 ? prev + 1 : 0
          );
          return;
        }
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          setSelectedMentionIndex((prev) =>
            prev > 0 ? prev - 1 : filteredMentions.length - 1
          );
          return;
        }
        if (
          (e.key === 'Tab' || e.key === 'Enter') &&
          selectedMentionIndex >= 0
        ) {
          e.preventDefault();
          handleMentionSelect(filteredMentions[selectedMentionIndex]);
          return;
        }
        if (e.key === 'Escape') {
          setShowMentions(false);
          setSelectedMentionIndex(-1);
          return;
        }
      }

      // Handle suggestion navigation
      if (showSuggestions && suggestions.length > 0) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          setSelectedSuggestionIndex((prev) =>
            prev < suggestions.length - 1 ? prev + 1 : 0
          );
          return;
        }
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          setSelectedSuggestionIndex((prev) =>
            prev > 0 ? prev - 1 : suggestions.length - 1
          );
          return;
        }
        if (e.key === 'Tab' && selectedSuggestionIndex >= 0) {
          e.preventDefault();
          handleSuggestionSelect(suggestions[selectedSuggestionIndex]);
          return;
        }
        if (e.key === 'Escape') {
          setSelectedSuggestionIndex(-1);
          return;
        }
      }

      // Allow Enter for line breaks (remove submission on Enter)
      // Submission should only happen via the send button
    };

    return (
      <View
        ref={containerRef}
        width="100%"
        position="relative"
        {...views?.container}
      >
        {/* Input Container */}
        <View
          width="100%"
          minHeight={minHeight}
          maxHeight={maxHeight}
          overflowY="auto"
          position="relative"
        >
          {/* Placeholder */}
          {showPlaceholder && (
            <Text
              position="absolute"
              top="8px"
              left="8px"
              color="color.gray.400"
              pointerEvents="none"
              fontSize="14px"
              lineHeight="1.5"
              zIndex={1}
              {...views?.placeholder}
            >
              {placeholder}
            </Text>
          )}

          {/* Editable Input */}
          <View
            as="div"
            ref={ref}
            contentEditable={!disabled}
            suppressContentEditableWarning={true}
            onInput={handleInput}
            onKeyDown={handleKeyDown}
            onFocus={handleFocus}
            onBlur={handleBlur}
            role="textbox"
            aria-multiline="true"
            aria-placeholder={placeholder}
            width="100%"
            minHeight="24px"
            padding="8px"
            outline="none"
            whiteSpace="pre-wrap"
            wordBreak="break-word"
            fontSize="14px"
            lineHeight="1.5"
            color="color.gray.900"
            backgroundColor="transparent"
            {...views?.input}
          />
        </View>

        {/* Mentions Dropdown */}
        {showMentions && filteredMentions.length > 0 && (
          <View
            position="fixed"
            left={mentionPosition.x}
            top={mentionPosition.y}
            width={containerRef.current?.offsetWidth || 300}
            backgroundColor="color.white"
            border="2px solid"
            borderColor="color.blue.300"
            borderRadius="8px"
            boxShadow="0 8px 24px rgba(0, 0, 0, 0.15)"
            zIndex={9999}
            maxHeight="200px"
            overflowY="auto"
            {...views?.mentionContainer}
          >
            <Vertical gap={0}>
              {filteredMentions.map((mention, index) => (
                <View
                  key={mention.id}
                  as="button"
                  type="button"
                  width="100%"
                  padding="12px 16px"
                  backgroundColor={
                    index === selectedMentionIndex
                      ? 'color.blue.50'
                      : 'transparent'
                  }
                  border="none"
                  cursor="pointer"
                  textAlign="left"
                  transition="background-color 0.2s ease"
                  onClick={() => handleMentionSelect(mention)}
                  onMouseEnter={() => setSelectedMentionIndex(index)}
                  _hover={{
                    backgroundColor: 'color.blue.50',
                  }}
                  {...views?.mentionItem}
                >
                  <Vertical gap={4}>
                    <Text
                      fontSize="14px"
                      color="color.gray.900"
                      fontWeight="medium"
                    >
                      {mentionTrigger}
                      {mention.name}
                    </Text>
                    {mention.description && (
                      <Text fontSize="12px" color="color.gray.600">
                        {mention.description}
                      </Text>
                    )}
                  </Vertical>
                </View>
              ))}
              {/* Debug info - can be removed in production */}
              {process.env.NODE_ENV === 'development' && (
                <div style={{ fontSize: '8px', opacity: 0.7, padding: '4px' }}>
                  Mentions (Trigger: {mentionTrigger})
                  {relation && (
                    <>
                      <br />
                      Space: {relation.space.vertical}-
                      {relation.space.horizontal}
                    </>
                  )}
                </div>
              )}
            </Vertical>
          </View>
        )}

        {/* Suggestions Dropdown - Only show on focus and when no value */}
        {showSuggestions &&
          suggestions.length > 0 &&
          !showMentions &&
          isFocused &&
          !value && (
            <View
              position="fixed"
              left={suggestionPosition.x}
              top={suggestionPosition.y}
              width={containerRef.current?.offsetWidth || 300}
              backgroundColor="color.white"
              border="2px solid"
              borderColor="color.green.300"
              borderRadius="8px"
              boxShadow="0 8px 24px rgba(0, 0, 0, 0.15)"
              zIndex={9998}
              maxHeight="200px"
              overflowY="auto"
              {...views?.suggestionsContainer}
            >
              <Vertical gap={0}>
                {suggestions.map((suggestion, index) => (
                  <View
                    key={suggestion.id}
                    as="button"
                    type="button"
                    width="100%"
                    padding="12px 16px"
                    backgroundColor={
                      index === selectedSuggestionIndex
                        ? 'color.blue.50'
                        : 'transparent'
                    }
                    border="none"
                    cursor="pointer"
                    textAlign="left"
                    transition="background-color 0.2s ease"
                    onClick={() => handleSuggestionSelect(suggestion)}
                    onMouseEnter={() => setSelectedSuggestionIndex(index)}
                    _hover={{
                      backgroundColor: 'color.blue.50',
                    }}
                    {...views?.suggestionItem}
                  >
                    <Vertical gap={4}>
                      <Text
                        fontSize="14px"
                        color="color.gray.900"
                        fontWeight="medium"
                      >
                        {suggestion.text}
                      </Text>
                      {suggestion.description && (
                        <Text fontSize="12px" color="color.gray.600">
                          {suggestion.description}
                        </Text>
                      )}
                    </Vertical>
                  </View>
                ))}
                {/* Debug info - can be removed in production */}
                {process.env.NODE_ENV === 'development' && (
                  <div
                    style={{ fontSize: '8px', opacity: 0.7, padding: '4px' }}
                  >
                    Suggestions (Focus-triggered)
                    {relation && (
                      <>
                        <br />
                        Space: {relation.space.vertical}-
                        {relation.space.horizontal}
                      </>
                    )}
                  </div>
                )}
              </Vertical>
            </View>
          )}
      </View>
    );
  }
);

EditableInput.displayName = 'EditableInput';
</file>

<file path="src/components/ChatInput/ChatInput/ChatInput.type.ts">
import { ViewProps } from 'app-studio';

/**
 * Size options for the ChatInput component
 */
export type Size = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

/**
 * Shape options for the ChatInput component
 */
export type Shape = 'default' | 'sharp' | 'rounded';

/**
 * Variant options for the ChatInput component
 */
export type Variant = 'default' | 'outline' | 'none';

/**
 * Prompt example interface
 */
export interface PromptExample {
  id: string;
  text: string;
}

/**
 * Model option interface
 */
export interface ModelOption {
  id: string;
  name: string;
  description?: string;
  isThinking?: boolean;
}

/**
 * Style customization interface for ChatInput
 */
export interface ChatInputStyles {
  textarea?: ViewProps;
  container?: ViewProps;
  content?: ViewProps;
  editableInput?: ViewProps;
  header?: ViewProps;
  title?: ViewProps;
  guideTip?: ViewProps;
  guideTipVideo?: ViewProps;
  guideTipClose?: ViewProps;
  promptExamples?: ViewProps;
  promptExampleItem?: ViewProps;
  attachments?: ViewProps;
  attachmentItem?: ViewProps;
  attachmentName?: ViewProps;
  attachmentSize?: ViewProps;
  attachmentRemove?: ViewProps;
  submitButton?: ViewProps;
  fileButton?: ViewProps;
  recordButton?: ViewProps;
  modelSelector?: ViewProps;
  loadingIndicator?: ViewProps;
  bottomTip?: ViewProps;
}
</file>

<file path="src/components/ChatInput/ChatInput/ChatInput.props.ts">
import { ViewProps } from 'app-studio';
import {
  ChatInputStyles,
  ModelOption,
  PromptExample,
  Shape,
  Size,
  Variant,
} from './ChatInput.type';
import { Suggestion } from '../EditableInput';

/**
 * Props for the ChatInput component
 */
export interface ChatInputProps extends ViewProps {
  /**
   * Get the pending files
   */
  getPendingFiles: () => File[];

  /**
   * Clear the pending files
   */
  clearPendingFiles: () => void;
  /**
   * Callback function when the form is submitted
   */
  onSubmit: (
    message: string,
    options?: { model_name?: string; enable_thinking?: boolean }
  ) => void;

  /**
   * Placeholder text for the input
   */
  placeholder?: string;

  /**
   * Whether the input is in a loading state
   */
  loading?: boolean;

  /**
   * Whether the input is disabled
   */
  disabled?: boolean;

  /**
   * Whether an agent is currently running
   */
  isAgentRunning?: boolean;

  /**
   * Callback function to stop the agent
   */
  onStopAgent?: () => void;

  /**
   * Whether to auto focus the input
   */
  autoFocus?: boolean;

  /**
   * Controlled value for the input
   */
  value?: string;

  /**
   * Callback function when the input value changes
   */
  onChange?: (value: string) => void;

  /**
   * Callback function when the file browser is opened
   */
  onFileBrowse?: () => void;

  /**
   * ID of the sandbox
   */
  sandboxId?: string;

  /**
   * Whether to hide the attachment button
   */
  hideAttachments?: boolean;

  /**
   * Enable audio recording button
   */
  enableAudioRecording?: boolean;

  /**
   * Callback when audio recording starts
   */
  onAudioRecordingStart?: () => void;

  /**
   * Callback when audio recording stops
   */
  onAudioRecordingStop?: (audio: Blob) => void;

  /**
   * Title for the chat input
   */
  title?: string;

  /**
   * Whether to show the guide tip
   */
  showGuideTip?: boolean;

  /**
   * URL for the guide video
   */
  guideVideoUrl?: string;

  /**
   * Callback function when the guide tip is closed
   */
  onGuideClose?: () => void;

  /**
   * List of prompt examples
   */
  promptExamples?: PromptExample[];

  /**
   * List of suggestions for auto-completion
   */
  suggestions?: Suggestion[];

  /**
   * Callback function when a prompt example is selected
   */
  onPromptExampleSelect?: (example: PromptExample) => void;

  /**
   * Data for mention auto-completion
   */
  mentionData?: Array<{
    id: string;
    name: string;
    avatar?: string;
    description?: string;
  }>;

  /**
   * Trigger character for mentions (default: '@')
   */
  mentionTrigger?: string;

  /**
   * Callback function when a mention is selected
   */
  onMentionSelect?: (mention: {
    id: string;
    name: string;
    avatar?: string;
    description?: string;
  }) => void;

  /**
   * Error message to display at the bottom
   */
  errorMessage?: string;

  /**
   * Size of the input
   */
  size?: Size;

  /**
   * Shape of the input
   */
  shape?: Shape;

  /**
   * Variant of the input
   */
  variant?: Variant;

  /**
   * Style customization
   */
  views?: ChatInputStyles;
}

/**
 * Props for the ChatInput view component
 */
export interface ChatInputViewProps extends ChatInputProps {
  /**
   * Current value of the input
   */
  value?: string;

  /**
   * Callback function when the input value changes
   */
  handleChange: (value: string) => void;

  /**
   * Callback function when the form is submitted
   */
  handleSubmit: (e: React.FormEvent) => void;

  /**
   * Reference to the editable div element
   */
  editableRef: React.RefObject<HTMLDivElement>;

  /**
   * Reference to the file input element
   */
  fileInputRef: React.RefObject<HTMLInputElement>;

  /**
   * Whether files are being uploaded
   */
  isUploading: boolean;

  leftButtons?: React.ReactNode;
  rightButtons?: React.ReactNode;

  /**
   * Whether the user is dragging files over the input
   */
  isDraggingOver: boolean;

  /**
   * List of uploaded files
   */
  uploadedFiles: File[];

  /**
   * Callback function to remove an uploaded file
   */
  removeUploadedFile: (index: number) => void;

  /**
   * Callback function to set pending files
   */
  setPendingFiles: React.Dispatch<React.SetStateAction<File[]>>;

  /**
   * Callback function to set uploaded files
   */
  setUploadedFiles: React.Dispatch<React.SetStateAction<File[]>>;

  /**
   * Callback function to set whether files are being uploaded
   */
  setIsUploading: React.Dispatch<React.SetStateAction<boolean>>;

  /**
   * Currently selected model
   */
  selectedModel: string;

  /**
   * Callback function when the model changes
   */
  handleModelChange: (model: string) => void;

  /**
   * List of available models
   */
  modelOptions: ModelOption[];

  /**
   * Subscription status
   */
  subscriptionStatus?: string;

  /**
   * Whether the user can access the selected model
   */
  canAccessModel: (model: string) => boolean;

  /**
   * Whether the guide tip is shown
   */
  isGuideTipShown: boolean;

  /**
   * Callback function to hide the guide tip
   */
  hideGuideTip: () => void;

  /**
   * Callback function to handle prompt example selection
   */
  handlePromptExampleSelect: (example: PromptExample) => void;

  /**
   * Callback function to handle drag over events
   */
  handleDragOver: (e: React.DragEvent<HTMLDivElement>) => void;

  /**
   * Callback function to handle drag leave events
   */
  handleDragLeave: (e: React.DragEvent<HTMLDivElement>) => void;

  /**
   * List of suggestions for auto-completion
   */
  suggestions?: Suggestion[];
}
</file>

<file path="src/components/ChatInput/AudioRecorder.tsx">
import React, { useCallback, useEffect } from 'react';
import { Horizontal, View } from 'app-studio';
import { MicrophoneIcon, StopIcon } from '../Icon/Icon';
import { AudioWaveform } from '../AudioInput/AudioWaveform/AudioWaveform';
import { useAudioRecording } from '../AudioInput/useAudioRecording';

interface AudioRecorderProps {
  onRecordingComplete: (file: File) => void;
  onRecordingStart?: () => void;
  views?: { button?: any };
}

export const AudioRecorder: React.FC<AudioRecorderProps> = ({
  onRecordingComplete,
  onRecordingStart,
  views = {},
}) => {
  const {
    recording,
    paused,
    audioBlob,
    analyserNode,
    startRecording,
    stopRecording,
  } = useAudioRecording();

  useEffect(() => {
    if (audioBlob) {
      const file = new File([audioBlob], `recording-${Date.now()}.webm`, {
        type: audioBlob.type || 'audio/webm;codecs=opus',
      });
      onRecordingComplete(file);
    }
  }, [audioBlob]);

  const handleStart = useCallback(() => {
    startRecording();
    onRecordingStart?.();
  }, []);

  return (
    <Horizontal alignItems="center" gap={4}>
      {recording && analyserNode && (
        <AudioWaveform analyserNode={analyserNode} isPaused={paused} />
      )}
      <View
        as="button"
        type="button"
        onClick={recording ? stopRecording : handleStart}
        height="40px"
        width="40px"
        display="flex"
        alignItems="center"
        justifyContent="center"
        backgroundColor={recording ? 'theme.error' : 'color.gray.100'}
        color={recording ? 'color.white' : 'color.gray.600'}
        borderRadius="50%"
        border="none"
        cursor="pointer"
        _hover={{
          backgroundColor: recording ? 'color.red.600' : 'color.gray.200',
        }}
        {...views.button}
      >
        {recording ? (
          <StopIcon widthHeight={16} color="currentColor" filled={false} />
        ) : (
          <MicrophoneIcon
            widthHeight={16}
            color="currentColor"
            filled={false}
          />
        )}
      </View>
    </Horizontal>
  );
};
</file>

<file path="src/components/ChatInput/AttachmentGroup.tsx">
import React, { useCallback } from 'react';
import { Vertical, View, Image, Center, Button } from 'app-studio';
import { FileIcon, AudioIcon } from '../Icon/Icon';
import { HoverCard } from '../HoverCard/HoverCard';
import { DefaultAgentChatStyles } from '../adk/AgentChat/AgentChat/AgentChat.style';
import { Text } from '../Text/Text';

interface AttachmentGroupProps {
  files: File[];
  sandboxId?: string;
  onRemove: (index: number) => void;
  layout?: 'inline' | 'grid';
  maxHeight?: string;
  showPreviews?: boolean;
  views?: {
    container?: any;
    item?: any;
    name?: any;
    size?: any;
    removeButton?: any;
  };
}

export const AttachmentGroup: React.FC<AttachmentGroupProps> = ({
  files,
  sandboxId,
  onRemove,
  layout = 'inline',
  maxHeight = '120px',
  showPreviews = false,
  views = {},
}) => {
  if (files.length === 0) {
    return null;
  }

  const formatFileSize = useCallback((bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }, []);

  return (
    <View
      display="flex"
      flexWrap="wrap"
      gap="6px"
      padding="8px 0"
      maxHeight={maxHeight}
      overflowY="auto"
      {...views?.container}
    >
      {files.map((file, index) => {
        const previewUrl =
          URL.createObjectURL(file) ||
          (file as any)?.path ||
          (file as any)?.url ||
          '';
        const isImage = file.type.startsWith('image/');
        const isVideo = file.type.startsWith('video/');
        const isAudio = file.type.startsWith('audio/');
        return (
          <Vertical
            key={index}
            alignItems="center"
            gap="6px"
            padding="4px 8px"
            borderRadius="6px"
            backgroundColor="color.gray.100"
            animate={{
              from: { opacity: 0, scale: 0.9 },
              to: { opacity: 1, scale: 1 },
            }}
            animationDuration={0.2}
            {...views?.item}
          >
            {showPreviews && (
              <HoverCard>
                <HoverCard.Trigger>
                  {isImage && (
                    <Image
                      src={previewUrl}
                      alt={file.name}
                      width="60px"
                      height="60px"
                      objectFit="cover"
                    />
                  )}
                  {isVideo && (
                    <View
                      as="video"
                      src={previewUrl}
                      alt={file.name}
                      controls={false}
                      muted={true}
                      width="60px"
                      height="60px"
                      objectFit="cover"
                    />
                  )}
                  {isAudio && (
                    <Center
                      width="60px"
                      height="60px"
                      backgroundColor="color.gray.200"
                    >
                      <AudioIcon widthHeight={24} color="color.black" />
                    </Center>
                  )}
                  {!isImage && !isVideo && !isAudio && (
                    <Center
                      width="60px"
                      height="60px"
                      backgroundColor="color.gray.200"
                    >
                      <FileIcon widthHeight={24} color="color.black" />
                    </Center>
                  )}

                  {onRemove && (
                    <Button
                      {...DefaultAgentChatStyles.attachmentRemove}
                      onClick={(e) => {
                        e.stopPropagation();
                        onRemove(index);
                      }}
                      aria-label={`Remove ${file.name}`}
                    >
                      ×
                    </Button>
                  )}
                </HoverCard.Trigger>
                <HoverCard.Content>
                  {isImage && (
                    <Image src={previewUrl} alt={file.name} maxWidth="100%" />
                  )}
                  {isVideo && (
                    <View
                      as="video"
                      src={previewUrl}
                      controls
                      maxWidth="100%"
                    />
                  )}
                  {isAudio && (
                    <View as="audio" src={previewUrl} controls width={'100%'} />
                  )}
                  <Text
                    marginTop="4px"
                    truncateText={true}
                    textOverflow="ellipsis"
                    overflow="hidden"
                    width={'100%'}
                    {...views?.name}
                  >
                    {file.name} ({formatFileSize(file.size)})
                  </Text>
                </HoverCard.Content>
              </HoverCard>
            )}
          </Vertical>
        );
      })}
    </View>
  );
};
</file>

<file path="src/components/ChatInput/ChatInput/ChatInput.view.tsx">
import React, { useCallback } from 'react';
import { Horizontal, Text, View, useTheme } from 'app-studio';
import { ChatInputViewProps } from './ChatInput.props';
import {
  DefaultChatInputStyles,
  Shapes,
  Sizes,
  Variants,
} from './ChatInput.style';
import { AttachmentGroup } from '../AttachmentGroup';
import { EditableInput } from '../EditableInput';
import { Uploader } from '../../Uploader/Uploader';
import { PromptExamples } from '../PromptExamples';
import { Loader } from '../../Loader/Loader';
import {
  StopIcon,
  SendIcon,
  LoadingSpinnerIcon,
  AttachmentIcon,
} from '../../Icon/Icon';
import { AudioRecorder } from '../AudioRecorder';

const ChatInputView: React.FC<ChatInputViewProps> = ({
  // Props from parent
  onSubmit,
  placeholder = 'Say what you want and Kimmy will surprise you',
  loading = false,
  disabled = false,
  isAgentRunning = false,
  enableAudioRecording = false,
  leftButtons,
  rightButtons,
  onStopAgent,
  loadingText = 'Agent is working...',
  autoFocus = true,
  sandboxId,
  hideAttachments = false,
  attachmentText = '',
  promptExamples = [],
  suggestions = [],
  errorMessage,
  size = 'md',
  shape = 'rounded',
  variant = 'default',
  views = {},
  mentionData = [],
  mentionTrigger = '@',
  onMentionSelect,
  onAudioRecordingStart,
  onAudioRecordingStop,

  // Props from state
  value,
  handleChange,
  handleSubmit,
  editableRef,
  fileInputRef,
  isUploading,
  isDraggingOver,
  uploadedFiles,
  removeUploadedFile,
  setPendingFiles,
  setUploadedFiles,
  setIsUploading,
  selectedModel,
  handleModelChange,
  modelOptions,
  subscriptionStatus,
  canAccessModel,
  isGuideTipShown,
  hideGuideTip,
  handlePromptExampleSelect,
  handleDragOver,
  handleDragLeave,

  // Other props
  ...props
}) => {
  const {
    /* getColor */
  } = useTheme();

  // Combine styles
  const containerStyles = {
    ...DefaultChatInputStyles.container,
    ...Shapes[shape],
    ...views?.container,
  };

  const contentStyles = {
    ...DefaultChatInputStyles.content,
    ...Sizes[size],
    ...Variants[variant],
    ...views?.content,
  };

  // Determine if the submit button should be enabled
  const hasText = (value?.trim().length ?? 0) > 0 || uploadedFiles.length > 0;

  const handleRecordingComplete = useCallback(
    (file: File) => {
      setPendingFiles((prev) => [...prev, file]);

      setUploadedFiles((prev) => [...prev, file]);
      onAudioRecordingStop?.(file);
    },
    [setPendingFiles, setUploadedFiles, onAudioRecordingStop]
  );

  // Handle multiple file uploads for the Uploader component
  const handleMultipleFileUpload = useCallback(
    (files: File[]) => {
      // Filter files that exceed size limit (50MB)
      const filteredFiles = files.filter((file) => {
        if (file.size > 50 * 1024 * 1024) {
          console.error(`File size exceeds 50MB limit: ${file.name}`);
          return false;
        }
        return true;
      });

      if (filteredFiles.length > 0) {
        // Add files to pending files
        setPendingFiles((prevFiles) => [...prevFiles, ...filteredFiles]);

        // Add files to uploaded files
        setUploadedFiles((prev) => [...prev, ...filteredFiles]);
      }
    },
    [setPendingFiles, setUploadedFiles]
  );

  // Combine mention data with uploaded files
  const combinedMentionData = [
    ...(mentionData || []),
    ...uploadedFiles.map((file, index) => ({
      id: `file-${index}`,
      name: file.name,
    })),
  ];

  return (
    <View
      display="flex"
      flexDirection="column"
      // Width and maxWidth will come from containerStyles
      boxSizing="border-box"
      {...containerStyles}
      {...props}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={(e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        e.stopPropagation();
        handleDragLeave(e);

        if (e.dataTransfer.files.length > 0) {
          const files = Array.from(e.dataTransfer.files) as File[];
          handleMultipleFileUpload(files);
        }
      }}
    >
      {/* Prompt Examples */}
      {promptExamples.length > 0 && (
        <PromptExamples
          examples={promptExamples}
          onSelect={handlePromptExampleSelect}
          views={{
            container: views?.promptExamples,
            item: views?.promptExampleItem,
          }}
        />
      )}

      {isAgentRunning && (
        <Horizontal
          justifyContent="center"
          alignItems="center"
          gap={8}
          padding="8px 0"
          animate={{
            from: { opacity: 0, y: -10 },
            to: { opacity: 1, y: 0 },
            duration: '0.3s',
          }}
          // animationDuration="0.3s"
          {...views?.loadingIndicator}
        >
          <LoadingSpinnerIcon
            widthHeight={12}
            color="currentColor"
            filled={false}
            style={{ animation: 'spin 1s linear infinite' }}
          />
          <Text color="color.gray.500">{loadingText}</Text>
        </Horizontal>
      )}

      <View position="relative" width="100%" overflow="visible">
        {/* Input Area */}
        <View
          as="form"
          onSubmit={handleSubmit}
          overflow="visible"
          display="flex"
          flexDirection="column"
          position="relative"
          // transition="background-color 0.2s ease"
          // Apply base styles first, then override with conditional background color

          {...contentStyles}
          {...containerStyles}
          paddingHorizontal={16}
          paddingVertical={10}
          backgroundColor={isDraggingOver ? 'color.blue.50' : undefined}
        >
          {/* Attachments */}
          <AttachmentGroup
            files={uploadedFiles}
            sandboxId={sandboxId}
            onRemove={removeUploadedFile}
            showPreviews={true}
            views={{
              container: views?.attachments,
              item: views?.attachmentItem,
              name: views?.attachmentName,
              size: views?.attachmentSize,
              removeButton: views?.attachmentRemove,
            }}
          />

          {/* Editable Input */}
          <EditableInput
            ref={editableRef}
            value={value || ''}
            onChange={handleChange}
            placeholder={placeholder}
            disabled={disabled && !isAgentRunning}
            autoFocus={autoFocus}
            suggestions={suggestions || []}
            showSuggestions={suggestions && suggestions.length > 0 && !value}
            onSuggestionSelect={(suggestion) => {
              handleChange(suggestion.text);
            }}
            mentionData={combinedMentionData}
            mentionTrigger={mentionTrigger}
            onMentionSelect={onMentionSelect}
            views={{
              container: {},
              input: views?.editableInput,
            }}
          />

          {/* Bottom Controls */}
          <Horizontal
            justifyContent="space-between"
            alignItems="center"
            marginTop="8px"
          >
            <Horizontal gap={8} alignItems="center">
              {/* File Upload Button */}
              {!hideAttachments && (
                <Uploader
                  accept="*/*"
                  icon={<AttachmentIcon widthHeight={16} />}
                  maxSize={50 * 1024 * 1024} // 50MB limit
                  multiple={true}
                  onMultipleFileSelect={handleMultipleFileUpload}
                  isLoading={isUploading}
                  text={attachmentText}
                  fileType="file"
                  renderError={({ errorMessage }) => null}
                  views={{
                    container: {
                      height: '36px',
                      //margin: '0 12px',
                      // borderRadius: '8px',
                      // backgroundColor: 'transparent',
                      // border: '1px solid',
                      // borderColor: 'color.gray.300',
                      cursor: 'pointer',
                      _hover: {
                        backgroundColor: 'color.gray.100',
                      },
                      ...views?.fileButton,
                    },
                  }}
                  containerProps={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: 4,
                    borderRadius: shape === 'rounded' ? '50%' : 4,
                    padding: 10,
                  }}
                  textProps={{
                    fontSize: '14px',
                    color: 'color.gray.600',
                  }}
                  validateFile={(file: File) => {
                    if (file.size > 50 * 1024 * 1024) {
                      return 'File size exceeds 50MB limit';
                    }
                    return null;
                  }}
                />
              )}
              {leftButtons}
            </Horizontal>

            {/* Submit Button */}
            <Horizontal gap={8} alignItems="center">
              {enableAudioRecording && (
                <AudioRecorder
                  onRecordingStart={onAudioRecordingStart}
                  onRecordingComplete={handleRecordingComplete}
                  views={{ button: views?.recordButton }}
                />
              )}
              <View
                as="button"
                type="button"
                onClick={handleSubmit}
                height="40px"
                width="40px"
                display="flex"
                alignItems="center"
                justifyContent="center"
                backgroundColor={
                  isAgentRunning
                    ? 'theme.error'
                    : hasText
                    ? 'theme.primary'
                    : 'color.gray.300'
                }
                color="color.white"
                borderRadius={shape === 'rounded' ? '50%' : 4}
                border="none"
                cursor={hasText ? 'pointer' : 'not-allowed'}
                disabled={!hasText || loading || (disabled && !isAgentRunning)}
                transition="all 0.2s ease"
                _hover={{
                  backgroundColor: isAgentRunning
                    ? 'color.red.600'
                    : hasText
                    ? 'color.blue.600'
                    : 'color.gray.300',
                }}
                {...views?.submitButton}
              >
                {isAgentRunning ? (
                  <StopIcon
                    widthHeight={16}
                    color="currentColor"
                    filled={false}
                  />
                ) : loading ? (
                  <Loader type="quarter" size={16} color="color.white" />
                ) : (
                  <SendIcon
                    widthHeight={16}
                    color="currentColor"
                    filled={false}
                  />
                )}
              </View>

              {rightButtons}
            </Horizontal>
          </Horizontal>
        </View>
      </View>

      {/* Bottom Tip (Error Message) */}
      {errorMessage && (
        <Text color="theme.error" marginTop="4px" {...views?.bottomTip}>
          {errorMessage}
        </Text>
      )}

      {/* Agent Running Indicator */}
    </View>
  );
};

export default ChatInputView;
</file>

</files>
