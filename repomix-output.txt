This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/components/Flow
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  components/
    Flow/
      examples/
        default.tsx
        flowchart.tsx
        index.tsx
        list.tsx
      Flow/
        Flow.props.ts
        Flow.state.ts
        Flow.style.ts
        Flow.type.ts
        Flow.view.tsx
      Flow.tsx

================================================================
Files
================================================================

================
File: src/components/Flow/examples/flowchart.tsx
================
import React, { useState } from 'react';
import { Flow } from '../Flow';
import { Text, View } from 'app-studio';
import { FlowNode, NodeConnection } from '../Flow/Flow.type';

export const FlowchartExample = () => {
  // Initial flowchart data
  const [nodes, setNodes] = useState<FlowNode[]>([
    {
      id: 'start',
      type: 'start',
      position: { x: 400, y: 100 },
      data: {
        label: 'Start',
      },
    },
    {
      id: 'node-1',
      position: { x: 400, y: 250 },
      data: {
        label: '',
      },
    },
    {
      id: 'node-2',
      position: { x: 250, y: 400 },
      data: {
        label: '',
      },
    },
    {
      id: 'node-3',
      position: { x: 550, y: 400 },
      data: {
        label: '',
      },
    },
    {
      id: 'node-4',
      position: { x: 250, y: 550 },
      data: {
        label: '',
      },
    },
    {
      id: 'node-5',
      position: { x: 550, y: 550 },
      data: {
        label: '',
      },
    },
  ]);

  const [edges, setEdges] = useState<NodeConnection[]>([
    { id: 'edge-start-1', source: 'start', target: 'node-1' },
    { id: 'edge-1-2', source: 'node-1', target: 'node-2' },
    { id: 'edge-1-3', source: 'node-1', target: 'node-3' },
    { id: 'edge-2-4', source: 'node-2', target: 'node-4' },
    { id: 'edge-3-5', source: 'node-3', target: 'node-5' },
  ]);

  const [selectedNodeId, setSelectedNodeId] = useState<string | undefined>(
    undefined
  );

  const [viewport, setViewport] = useState({ zoom: 1, x: 0, y: 0 });

  return (
    <View width="100%" height="600px" padding={20}>
      <Text fontWeight="bold" marginBottom={4}>
        Flowchart Example
      </Text>
      <View
        height="500px"
        border="1px solid"
        borderColor="color.gray.200"
        borderRadius={8}
        overflow="hidden"
      >
        <Flow
          nodes={nodes}
          edges={edges}
          onNodesChange={setNodes}
          onEdgesChange={setEdges}
          selectedNodeId={selectedNodeId}
          onNodeSelect={setSelectedNodeId}
          viewport={viewport}
          onViewportChange={setViewport}
          onNodeAdd={(newNode: FlowNode) => {
            console.log('Node added:', newNode);
            // The nodes are already updated by the Flow component
          }}
        />
      </View>
    </View>
  );
};

================
File: src/components/Flow/examples/default.tsx
================
import React, { useState } from 'react';
import { Flow } from '../Flow';
import { Text, Vertical, View, Horizontal } from 'app-studio';
import { FlowNode, NodeConnection } from '../Flow/Flow.type';

export const DefaultFlow = () => {
  // Initial workflow data
  const [nodes, setNodes] = useState<FlowNode[]>([
    {
      id: 'node-1',
      position: { x: 50, y: 50 }, // Added initial positions for clarity
      data: {
        label: 'New Record',
        subtitle: 'Airtable',
        number: 1,
        icon: (
          <View
            width={32}
            height={32}
            backgroundColor="color.yellow.100"
            borderRadius={4}
            display="flex"
            alignItems="center"
            justifyContent="center"
          >
            <Text color="color.yellow.600">üìä</Text>
          </View>
        ),
      },
    },
    {
      id: 'node-2',
      position: { x: 50, y: 200 }, // Added initial positions
      data: {
        label: 'Respond on UI',
        subtitle: 'Human Input',
        number: 2,
        icon: (
          <View
            width={32}
            height={32}
            backgroundColor="color.blue.100"
            borderRadius={4}
            display="flex"
            alignItems="center"
            justifyContent="center"
          >
            <Text color="color.blue.600">‚Ü©Ô∏è</Text>
          </View>
        ),
      },
    },
    {
      id: 'node-3',
      position: { x: 50, y: 350 }, // Added initial positions
      data: {
        label: 'Wait for Approval',
        subtitle: 'Approval (Legacy)',
        number: 3,
        icon: (
          <View
            width={32}
            height={32}
            backgroundColor="color.green.100"
            borderRadius={4}
            display="flex"
            alignItems="center"
            justifyContent="center"
          >
            <Text color="color.green.600">‚úì</Text>
          </View>
        ),
      },
    },
  ]);

  const [edges, setEdges] = useState<NodeConnection[]>([
    { id: 'edge-1-2', source: 'node-1', target: 'node-2' },
    { id: 'edge-2-3', source: 'node-2', target: 'node-3' },
  ]);

  const [selectedNodeId, setSelectedNodeId] = useState<string | undefined>(
    undefined
  );

  return (
    <Vertical gap={20} width="100%" maxWidth={800}>
      <Text marginBottom={10} fontWeight="bold">
        Workflow Builder
      </Text>

      <Horizontal gap={20} alignItems="flex-start">
        <Vertical gap={10} flex={1}>
          <View
            height={400}
            border="1px solid"
            borderColor="color.gray.200"
            borderRadius={8}
          >
            <Flow
              nodes={nodes}
              edges={edges}
              onNodesChange={setNodes}
              onEdgesChange={setEdges}
              selectedNodeId={selectedNodeId}
              onNodeSelect={setSelectedNodeId}
              onNodeAdd={(newNode: FlowNode) => {
                console.log('Node added:', newNode);
                // Example of how to update nodes if onNodeAdd was to manage state here
                // setNodes((nds) => [...nds, newNode]);
              }}
              direction="vertical" // Note: 'vertical' direction with current FlowView only stacks vertically.
              // x/y positioning logic in useFlowState will calculate positions,
              // but FlowView's simple layout won't reflect complex x/y placements.
              views={{
                node: {
                  // Example: container style for each node in FlowView
                  // width: '90%', // This was present, FlowNodeView now has minWidth by default
                },
                // Example: content style within each node in FlowView
                // content: {
                //   width: '100%',
                // },
              }}
            />
          </View>

          {selectedNodeId && (
            <View
              padding={10}
              backgroundColor="color.gray.100"
              borderRadius={4}
            >
              <Text>Selected: {selectedNodeId}</Text>
              <Text>
                {nodes.find((node) => node.id === selectedNodeId)?.data?.label}
              </Text>
            </View>
          )}
        </Vertical>

        <Vertical gap={10} flex={1}>
          <Text fontWeight="bold">Features:</Text>
          <View padding={10} backgroundColor="color.gray.50" borderRadius={4}>
            <Vertical gap={10}>
              <Text>‚Ä¢ Click on a node to select it</Text>
              <Text>
                ‚Ä¢ Use the + button below a node to add a new node vertically
              </Text>
              <Text>
                ‚Ä¢ Use the + button on the left side to add a node (position
                calculated for a full layout engine)
              </Text>
              <Text>
                ‚Ä¢ Use the + button on the right side to add a node (position
                calculated for a full layout engine)
              </Text>
              <Text>
                ‚Ä¢ If a node already has a connection in that direction, the new
                node will be added at the same level (logic in state, visual in
                full layout engine)
              </Text>
              <Text>
                ‚Ä¢ If a node doesnt have a connection in that direction, a new
                node will be created directly connected to it (logic in state,
                visual in full layout engine)
              </Text>
              <Text>
                ‚Ä¢ Nodes can be added in multiple directions (left, right, below)
              </Text>
              <Text>
                ‚Ä¢ Each node can have multiple children in different directions
              </Text>
              <Text fontWeight="bold" marginTop={10}>
                Note on current view:
              </Text>
              <Text>
                The current visual rendering is simplified and primarily stacks
                nodes vertically. Full left/right positioning requires a more
                complex layout engine (e.g., react-flow or xyflow).
              </Text>
            </Vertical>
          </View>
        </Vertical>
      </Horizontal>
    </Vertical>
  );
};

================
File: src/components/Flow/examples/index.tsx
================
export * from './default';
export * from './flowchart';
// Add other Flow examples if any in the future

================
File: src/components/Flow/examples/list.tsx
================
// This example demonstrates a custom list-based workflow visualizer.
// It does NOT use the Tree component, but showcases a similar visual pattern for sequential steps.
import React, { useState } from 'react';
import { Text, Vertical, Horizontal, View } from 'app-studio';
import { PlusIcon, ChevronIcon } from '../../Icon/Icon'; // Assuming Icon path is correct
import { TreeNode } from '../../Tree/Tree/Tree.type'; // TreeNode is used for structure, not for Tree component

// Custom node type for this specific workflow visualizer
interface WorkflowStepNode extends Omit<TreeNode, 'children' | 'label'> {
  // Omit Tree-specifics if not needed
  id: string;
  label: string; // Keep label
  number: number;
  subtitle: string;
  icon?: React.ReactNode; // Made icon optional and use ReactNode for consistency
  iconColor?: string; // This might be part of the icon's props itself
}

export const FlowList = () => {
  // Initial workflow data
  const [nodes, setNodes] = useState<WorkflowStepNode[]>([
    {
      id: 'wf-node-1',
      label: 'New Record',
      subtitle: 'Airtable',
      number: 1,
      icon: (
        <View
          width={32}
          height={32}
          backgroundColor="color.yellow.100"
          borderRadius={4}
          display="flex"
          alignItems="center"
          justifyContent="center"
        >
          <Text color="color.yellow.600">üìä</Text>
        </View>
      ),
    },
    {
      id: 'wf-node-2',
      label: 'Respond on UI',
      subtitle: 'Human Input',
      number: 2,
      icon: (
        <View
          width={32}
          height={32}
          backgroundColor="color.blue.100"
          borderRadius={4}
          display="flex"
          alignItems="center"
          justifyContent="center"
        >
          <Text color="color.blue.600">‚Ü©Ô∏è</Text>
        </View>
      ),
    },
    {
      id: 'wf-node-3',
      label: 'Wait for Approval',
      subtitle: 'Approval (Legacy)',
      number: 3,
      icon: (
        <View
          width={32}
          height={32}
          backgroundColor="color.green.100"
          borderRadius={4}
          display="flex"
          alignItems="center"
          justifyContent="center"
        >
          <Text color="color.green.600">‚úì</Text>
        </View>
      ),
    },
    {
      id: 'wf-node-4',
      label: 'Delete Row',
      subtitle: 'Google Sheets',
      number: 4,
      icon: (
        <View
          width={32}
          height={32}
          backgroundColor="color.red.100" // Changed color for variety
          borderRadius={4}
          display="flex"
          alignItems="center"
          justifyContent="center"
        >
          <Text color="color.red.600">üìó</Text>
        </View>
      ),
    },
  ]);

  // Function to add a new node after a specific node
  const addNodeAfter = (afterNodeId: string) => {
    const newNodesList = [...nodes];
    const afterIndex = newNodesList.findIndex(
      (node) => node.id === afterNodeId
    );

    if (afterIndex !== -1) {
      const newNodeNumber = newNodesList[afterIndex].number + 1;

      // Increment numbers for all subsequent nodes
      for (let i = afterIndex + 1; i < newNodesList.length; i++) {
        newNodesList[i].number += 1;
      }

      // Create new node
      const newNodeId = `wf-node-${Date.now()}-${Math.random()
        .toString(36)
        .substring(2, 6)}`;
      const newNode: WorkflowStepNode = {
        id: newNodeId,
        label: 'New Step',
        subtitle: 'Select Action Type',
        number: newNodeNumber,
        icon: (
          <View
            width={32}
            height={32}
            backgroundColor="color.gray.100"
            borderRadius={4}
            display="flex"
            alignItems="center"
            justifyContent="center"
          >
            <Text color="color.gray.600">+</Text>
          </View>
        ),
      };

      // Insert the new node
      newNodesList.splice(afterIndex + 1, 0, newNode);
      setNodes(newNodesList);
    } else if (nodes.length === 0) {
      // Handle adding the first node
      const newNodeId = `wf-node-${Date.now()}-${Math.random()
        .toString(36)
        .substring(2, 6)}`;
      const newNode: WorkflowStepNode = {
        id: newNodeId,
        label: 'First Step',
        subtitle: 'Configure this step',
        number: 1,
        icon: (
          /* similar icon */ <View
            width={32}
            height={32}
            backgroundColor="color.gray.100"
            borderRadius={4}
            display="flex"
            alignItems="center"
            justifyContent="center"
          >
            <Text color="color.gray.600">+</Text>
          </View>
        ),
      };
      setNodes([newNode]);
    }
  };

  const lastNodeId = nodes.length > 0 ? nodes[nodes.length - 1].id : null;

  return (
    <Vertical gap={0} width="100%" maxWidth={500} alignItems="center">
      <Text marginBottom={20} fontWeight="bold">
        Workflow List Visualizer
      </Text>

      {nodes.map((node, index) => (
        <React.Fragment key={node.id}>
          {/* Node */}
          <View
            width="90%"
            padding={16}
            borderRadius={8}
            border="1px solid"
            // Example of conditional styling for a specific node (e.g., selected)
            borderColor={index === 1 ? 'color.purple.400' : 'color.gray.200'}
            backgroundColor="white"
            marginBottom={0} // Connectors will handle spacing
            position="relative"
            zIndex={1} // Ensure node is above connector line part behind it
            boxShadow={index === 1 ? '0 0 0 2px color.purple.100' : 'none'}
          >
            <Horizontal gap={12} alignItems="center">
              {node.icon}
              <Vertical gap={2} flexGrow={1} overflow="hidden">
                <Horizontal gap={4} alignItems="center">
                  <Text fontWeight="bold" isTruncated>
                    {node.number}. {node.label}
                  </Text>
                  <ChevronIcon orientation="down" size={16} />
                </Horizontal>
                <Text color="color.gray.500" isTruncated>
                  {node.subtitle}
                </Text>
              </Vertical>
            </Horizontal>
          </View>

          {/* Connector with Add Button (if not the last node) */}
          {index < nodes.length - 1 && (
            <Vertical
              alignItems="center"
              height={40} // Space for line and button
              position="relative"
              width="100%" // To center the button
            >
              <View // Connector line
                width={2}
                height="100%"
                backgroundColor="color.gray.300"
                position="absolute"
                zIndex={0} // Behind button
              />
              <View // Add button
                as="button"
                aria-label={`Add step after ${node.label}`}
                backgroundColor="color.gray.200"
                width={28}
                height={28}
                borderRadius="50%" // Make it circular
                display="flex"
                alignItems="center"
                justifyContent="center"
                cursor="pointer"
                onClick={() => addNodeAfter(node.id)}
                zIndex={1} // Above line
                _hover={{
                  backgroundColor: 'color.gray.300',
                }}
                border="none"
              >
                <PlusIcon size={16} color="color.gray.700" />
              </View>
            </Vertical>
          )}
        </React.Fragment>
      ))}

      {/* Final add button (always shown, or shown if nodes exist) */}
      {/* This button adds after the last node, or as the first node if list is empty. */}
      <Vertical
        alignItems="center"
        height={40}
        position="relative"
        width="100%"
      >
        {nodes.length > 0 /* Show line only if there are preceding nodes */ && (
          <View // Connector line part for the final add button
            width={2}
            height="50%" // Line from top to center
            backgroundColor="color.gray.300"
            position="absolute"
            top={0}
            zIndex={0}
          />
        )}
        <View // The final add button itself
          as="button"
          aria-label={
            nodes.length > 0
              ? `Add step after ${nodes[nodes.length - 1].label}`
              : 'Add first step'
          }
          backgroundColor="color.gray.200"
          width={28}
          height={28}
          borderRadius="50%"
          display="flex"
          alignItems="center"
          justifyContent="center"
          cursor="pointer"
          onClick={() => addNodeAfter(lastNodeId || '')} // Pass last node ID or handle empty string for first node
          zIndex={1}
          _hover={{
            backgroundColor: 'color.gray.300',
          }}
          border="none"
        >
          <PlusIcon size={16} color="color.gray.700" />
        </View>
      </Vertical>
    </Vertical>
  );
};

================
File: src/components/Flow/Flow/Flow.props.ts
================
import { ViewProps } from 'app-studio';
import {
  Size,
  Variant,
  FlowNode,
  NodeConnection,
  FlowComponentType,
  FlowViewport,
  FlowEdgePipedViews,
} from './Flow.type';

/**
 * Props for the Flow component
 */
export interface FlowProps extends Omit<ViewProps, 'position'> {
  /**
   * Child elements for compound component pattern
   * Note: Flow component primarily uses `nodes` and `edges` props for data.
   * Children could be used for custom overlays or context providers if needed.
   */
  children?: React.ReactNode;

  /**
   * Array of nodes in the flow
   */
  nodes?: FlowNode[];

  /**
   * Array of edges/connections between nodes
   */
  edges?: NodeConnection[];

  /**
   * Size of the flow nodes
   * @default 'md'
   */
  size?: Size;

  /**
   * Visual variant of the flow nodes (affects node appearance)
   * @default 'default'
   */
  variant?: Variant;

  /**
   * Direction of the flow layout (influences default new node placement)
   * @default 'vertical'
   */
  direction?: 'vertical' | 'horizontal';

  /**
   * Whether to show the controls (zoom, etc.)
   * @default true
   */
  showControls?: boolean;

  /**
   * Whether to allow adding nodes
   * @default true
   */
  allowAddingNodes?: boolean;

  /**
   * Whether to allow deleting nodes (functionality not fully implemented in this simplified version)
   * @default true
   */
  allowDeletingNodes?: boolean;

  /**
   * Whether to allow connecting nodes (functionality not fully implemented in this simplified version)
   * @default true
   */
  allowConnectingNodes?: boolean;

  /**
   * Callback when nodes change (e.g., added, position changed)
   */
  onNodesChange?: (nodes: FlowNode[]) => void;

  /**
   * Callback when edges change (e.g., added)
   */
  onEdgesChange?: (edges: NodeConnection[]) => void;

  /**
   * Callback when a node is selected
   */
  onNodeSelect?: (nodeId: string) => void;

  /**
   * Callback when a node is added by user interaction
   * The `newNode` passed will have an ID and default data, but its position
   * will be determined by the `addNodeAfter` logic in `useFlowState`.
   */
  onNodeAdd?: (newNode: FlowNode) => void;

  /**
   * Callback when a node is deleted
   */
  onNodeDelete?: (nodeId: string) => void;

  /**
   * Callback when a connection is created
   */
  onConnect?: (connection: NodeConnection) => void;

  /**
   * ID of the selected node (controlled mode)
   */
  selectedNodeId?: string;

  /**
   * Initial viewport state (zoom, pan)
   */
  initialViewport?: FlowViewport;

  /**
   * Controlled viewport state
   */
  viewport?: FlowViewport;

  /**
   * Callback when viewport changes
   */
  onViewportChange?: (viewport: FlowViewport) => void;

  /**
   * Custom views for styling different parts of the component
   */
  views?: {
    container?: ViewProps; // Styles for the main flow container
    node?: {
      // Styles for FlowNodeView
      container?: ViewProps; // Styles for the node's root View
      content?: ViewProps; // Styles for the Horizontal content wrapper inside the node
      icon?: ViewProps; // Styles for the node's icon View
    };
    edge?: FlowEdgePipedViews;
    controls?: {
      // Styles for FlowControlsView
      container?: ViewProps; // Styles for the controls container
      button?: ViewProps; // Styles for individual control buttons
    };
    addButton?: {
      // Styles for FlowAddNodeButtonView
      container?: ViewProps; // Styles for the add button itself
      icon?: ViewProps; // Styles for the plus icon inside the button
    };
    fixedControlsContainer?: ViewProps; // Styles for the fixed controls container
  };
}

/**
 * Type for the Flow component with sub-components
 */
export type FlowType = FlowComponentType<FlowProps>;

================
File: src/components/Flow/Flow.tsx
================
import React from 'react';
import { FlowProps, FlowType } from './Flow/Flow.props';
import { useFlowState } from './Flow/Flow.state';
import { FlowNode } from './Flow/Flow.type';
import {
  FlowView,
  FlowNodeView,
  FlowEdgeView,
  FlowControlsView,
  FlowAddNodeButtonView,
} from './Flow/Flow.view';

/**
 * Flow component for creating workflow diagrams.
 *
 * @example
 * ```tsx
 * // Basic usage
 * const initialNodes = [
 *   {
 *     id: 'node-1',
 *     position: { x: 50, y: 50 },
 *     data: { label: 'Node 1', subtitle: 'Description' },
 *   },
 *   {
 *     id: 'node-2',
 *     position: { x: 50, y: 200 },
 *     data: { label: 'Node 2', subtitle: 'Description' },
 *   },
 * ];
 *
 * const initialEdges = [
 *   { id: 'edge-1-2', source: 'node-1', target: 'node-2' },
 * ];
 *
 * <Flow nodes={initialNodes} edges={initialEdges} />
 * ```
 */
const FlowComponent: React.FC<FlowProps> = ({
  children, // Not typically used for rendering nodes/edges, but available
  nodes: controlledNodes, // Renamed from initialNodes to reflect potential controlled nature
  edges: controlledEdges, // Renamed from initialEdges
  size = 'md',
  variant = 'default',
  direction = 'vertical',
  showControls = true,
  allowAddingNodes = true,
  // allowDeletingNodes = true, // Prop exists, but delete functionality not fully wired in UI
  // allowConnectingNodes = true, // Prop exists, but connecting functionality not fully wired in UI
  onNodesChange,
  onEdgesChange,
  onNodeSelect,
  onNodeAdd,
  // onNodeDelete,
  // onConnect,
  selectedNodeId,
  initialViewport,
  viewport: controlledViewport,
  onViewportChange,
  views,
  ...props
}) => {
  const flowState = useFlowState({
    initialNodes: controlledNodes, // Pass controlledNodes as initial if they exist
    initialEdges: controlledEdges, // Pass controlledEdges as initial
    nodes: controlledNodes, // For controlled mode
    edges: controlledEdges, // For controlled mode
    onNodesChange,
    onEdgesChange,
    onNodeSelect,
    selectedNodeId,
    direction,
    initialViewport,
    viewport: controlledViewport,
    onViewportChange,
  });

  // Handler for adding a node after another node, invoked by FlowView
  const handleAddNode = (
    afterNodeId: string,
    position?: 'below' | 'right' | 'left' | 'middle',
    edgeId?: string
  ) => {
    // Create a unique ID for the new node.
    // Consider a more robust UUID generator for production.
    const newNodeId = `node-${Date.now()}-${Math.random()
      .toString(36)
      .substring(2, 6)}`;
    const newNodeData: Omit<FlowNode, 'position'> = {
      // Data for the new node, position determined by addNodeAfter
      id: newNodeId,
      data: {
        label: 'New Step',
        subtitle: 'Select Action Type',
        // Numbering might need recalculation based on all nodes or context
        number: flowState.nodes.length + 1,
      },
    };

    // Add the node using state logic, which returns the fully formed node including position
    const addedNode = flowState.addNodeAfter(
      afterNodeId,
      newNodeData,
      position,
      edgeId
    );

    // Call the onNodeAdd callback if provided by the parent component
    if (onNodeAdd) {
      onNodeAdd(addedNode); // Pass the full new node, including its calculated position
    }
  };

  // The FlowView component expects specific props from the state and handlers.
  return React.createElement(FlowView, {
    nodes: flowState.nodes,
    edges: flowState.edges,
    selectedNodeId: flowState.selectedNodeId,
    onNodeSelect: flowState.selectNode,
    onAddNode: handleAddNode, // Pass the refined handler
    baseId: flowState.baseId,
    viewport: flowState.viewport,
    onZoomIn: flowState.zoomIn,
    onZoomOut: flowState.zoomOut,
    onReset: flowState.resetViewport,
    onViewportChange: flowState.updateViewport, // Pass the updateViewport function
    // Pass the new functions for node drag and drop and dimensions
    onNodePositionChange: flowState.updateNodePosition,
    onNodeDimensionsChange: flowState.updateNodeDimensions,
    // Pass the function to organize nodes in a tree structure
    onOrganize: flowState.organizeTreeNodes,
    // Pass through other relevant props
    size,
    variant,
    direction,
    showControls,
    allowAddingNodes,
    views,
    ...props, // Spread remaining ViewProps
  });
};

export const Flow = FlowComponent as FlowType;

// Assign the sub-components to the main component for compound usage (if any)
// These are primarily for potential direct use or a more componentized future version.
// The current FlowView renders these internally or has placeholders.
Flow.Node = FlowNodeView;
Flow.Edge = FlowEdgeView; // Note: FlowEdgeView is a simplified placeholder
Flow.Controls = FlowControlsView;
Flow.AddNodeButton = FlowAddNodeButtonView;

================
File: src/components/Flow/Flow/Flow.state.ts
================
import { useState, useCallback, useMemo } from 'react';
import {
  FlowNode,
  NodeConnection,
  FlowViewport,
  NodePosition,
} from './Flow.type';

interface UseFlowStateProps {
  /**
   * Initial nodes
   */
  initialNodes?: FlowNode[];

  /**
   * Initial edges/connections
   */
  initialEdges?: NodeConnection[];

  /**
   * Controlled nodes
   */
  nodes?: FlowNode[];

  /**
   * Controlled edges/connections
   */
  edges?: NodeConnection[];

  /**
   * Callback when nodes change
   */
  onNodesChange?: (nodes: FlowNode[]) => void;

  /**
   * Callback when edges change
   */
  onEdgesChange?: (edges: NodeConnection[]) => void;

  /**
   * Callback when a node is selected
   */
  onNodeSelect?: (nodeId: string) => void;

  /**
   * Controlled selected node ID
   */
  selectedNodeId?: string;

  /**
   * Direction of the flow
   */
  direction?: 'vertical' | 'horizontal';

  /**
   * Initial viewport state (zoom, pan)
   */
  initialViewport?: FlowViewport;

  /**
   * Controlled viewport state
   */
  viewport?: FlowViewport;

  /**
   * Callback when viewport changes
   */
  onViewportChange?: (viewport: FlowViewport) => void;
}

/**
 * Custom hook for managing Flow component state
 */
export const useFlowState = ({
  initialNodes = [],
  initialEdges = [],
  nodes: controlledNodes,
  edges: controlledEdges,
  onNodesChange,
  onEdgesChange,
  onNodeSelect,
  selectedNodeId: controlledSelectedNodeId,
  direction = 'vertical',
  initialViewport = { zoom: 1, x: 0, y: 0 },
  viewport: controlledViewport,
  onViewportChange,
}: UseFlowStateProps) => {
  // Generate a unique ID for accessibility.
  // For production, consider using React.useId() if available and appropriate for your React version.
  const baseId = useMemo(
    () => `flow-${Math.random().toString(36).substring(2, 9)}`,
    []
  );

  // State for nodes (uncontrolled mode)
  const [uncontrolledNodes, setUncontrolledNodes] =
    useState<FlowNode[]>(initialNodes);

  // State for edges (uncontrolled mode)
  const [uncontrolledEdges, setUncontrolledEdges] =
    useState<NodeConnection[]>(initialEdges);

  // State for selected node (uncontrolled mode)
  const [uncontrolledSelectedNodeId, setUncontrolledSelectedNodeId] = useState<
    string | undefined
  >(undefined);

  // State for viewport (uncontrolled mode)
  const [uncontrolledViewport, setUncontrolledViewport] =
    useState<FlowViewport>(initialViewport);

  // Determine if we're in controlled or uncontrolled mode for nodes
  const isNodesControlled = controlledNodes !== undefined;
  const currentNodes = isNodesControlled ? controlledNodes : uncontrolledNodes;

  // Determine if we're in controlled or uncontrolled mode for edges
  const isEdgesControlled = controlledEdges !== undefined;
  const currentEdges = isEdgesControlled ? controlledEdges : uncontrolledEdges;

  // Determine if we're in controlled or uncontrolled mode for selected node
  const isSelectedNodeControlled = controlledSelectedNodeId !== undefined;
  const currentSelectedNodeId = isSelectedNodeControlled
    ? controlledSelectedNodeId
    : uncontrolledSelectedNodeId;

  // Determine if we're in controlled or uncontrolled mode for viewport
  const isViewportControlled = controlledViewport !== undefined;
  const currentViewport = isViewportControlled
    ? controlledViewport
    : uncontrolledViewport;

  // Function to update nodes
  const updateNodes = useCallback(
    (newNodes: FlowNode[]) => {
      if (!isNodesControlled) {
        setUncontrolledNodes(newNodes);
      }
      if (onNodesChange) {
        onNodesChange(newNodes);
      }
    },
    [isNodesControlled, onNodesChange]
  );

  // Function to update edges
  const updateEdges = useCallback(
    (newEdges: NodeConnection[]) => {
      if (!isEdgesControlled) {
        setUncontrolledEdges(newEdges);
      }
      if (onEdgesChange) {
        onEdgesChange(newEdges);
      }
    },
    [isEdgesControlled, onEdgesChange]
  );

  // Function to select a node
  const selectNode = useCallback(
    (nodeId: string) => {
      if (!isSelectedNodeControlled) {
        setUncontrolledSelectedNodeId(nodeId);
      }
      if (onNodeSelect) {
        onNodeSelect(nodeId);
      }
    },
    [isSelectedNodeControlled, onNodeSelect]
  );

  // Function to add a node (simple append, not typically used directly by UI)
  const addNode = useCallback(
    (node: FlowNode) => {
      const newNodes = [...currentNodes, node];
      updateNodes(newNodes);
      // Note: This simpler addNode doesn't create edges.
      // onNodeAdd prop from FlowProps is typically called with node from addNodeAfter.
    },
    [currentNodes, updateNodes]
  );

  const addNodeAfter = useCallback(
    (
      afterNodeId: string | null, // Allow null for first node
      newNodeData: Omit<FlowNode, 'position'>,
      position?: 'below' | 'right' | 'left' | 'middle',
      edgeId?: string
    ): FlowNode => {
      // Handle adding the first node if afterNodeId is null or a specific marker
      if (afterNodeId === null || afterNodeId === '') {
        // Determine a default position for the first node
        // This could be improved to be center of viewport or configurable
        const firstNodePosition = { x: 150, y: 100 }; // Example default position

        const positionedNewNode: FlowNode = {
          ...newNodeData,
          position: firstNodePosition,
        };
        updateNodes([...currentNodes, positionedNewNode]);
        // No edge is created for the first node by default
        return positionedNewNode;
      }

      const afterNode = currentNodes.find((node) => node.id === afterNodeId);
      if (!afterNode) {
        console.warn(
          `addNodeAfter: Could not find node with id ${afterNodeId}. Adding node at default position.`
        );
        // Fallback: add node at a default position if afterNode is not found
        const fallbackPosition = { x: 100, y: currentNodes.length * 100 + 100 };
        const positionedNewNode = {
          ...newNodeData,
          position: fallbackPosition,
        } as FlowNode;
        updateNodes([...currentNodes, positionedNewNode]);
        return positionedNewNode;
      }

      // Existing logic for positioning relative to afterNode
      const newPosition = {
        x: afterNode.position?.x || 0,
        y: afterNode.position?.y || 0,
      };

      const placementPosition =
        position || (direction === 'vertical' ? 'below' : 'right');

      // ... (rest of the existing addNodeAfter logic for relative positioning)
      // Ensure this logic correctly uses newPosition, placementPosition, etc.
      // The existing logic for hasConnectionInDirection, getFurthestNodePosition,
      // and calculating newPosition based on placementPosition seems reasonable.

      // Handle the special case of adding a node in the middle of an edge
      if (position === 'middle' && edgeId) {
        const edge = currentEdges.find((e) => e.id === edgeId);
        if (edge) {
          const sourceNode = currentNodes.find((n) => n.id === edge.source);
          const targetNode = currentNodes.find((n) => n.id === edge.target);

          if (sourceNode && targetNode) {
            // Calculate the midpoint between source and target nodes
            const midX = (sourceNode.position.x + targetNode.position.x) / 2;
            const midY = (sourceNode.position.y + targetNode.position.y) / 2;

            // Position the new node at the midpoint
            const nodeWithPosition: FlowNode = {
              ...newNodeData,
              position: { x: midX, y: midY },
            };

            // Add the new node
            const newNodes = [...currentNodes, nodeWithPosition];
            updateNodes(newNodes);

            // Remove the original edge
            const newEdges = currentEdges.filter((e) => e.id !== edgeId);

            // Create two new edges: source -> new node and new node -> target
            const sourceToNewEdge: NodeConnection = {
              id: `edge-${edge.source}-${nodeWithPosition.id}`,
              source: edge.source,
              target: nodeWithPosition.id,
            };

            const newToTargetEdge: NodeConnection = {
              id: `edge-${nodeWithPosition.id}-${edge.target}`,
              source: nodeWithPosition.id,
              target: edge.target,
            };

            // Add the new edges
            updateEdges([...newEdges, sourceToNewEdge, newToTargetEdge]);

            return nodeWithPosition;
          }
        }
      }

      // Example of how the existing logic continues:
      const hasConnectionInDirection = (
        dir: 'below' | 'right' | 'left' | 'middle'
      ): boolean => {
        if (dir === 'middle') {
          return false; // Middle position is handled separately above
        } else if (dir === 'below') {
          return currentEdges.some((edge) => {
            const targetNode = currentNodes.find((n) => n.id === edge.target);
            const targetY = targetNode?.position?.y || 0;
            const sourceY = afterNode.position?.y || 0;
            return (
              edge.source === afterNodeId &&
              targetY > sourceY &&
              Math.abs(
                (targetNode?.position?.x || 0) - (afterNode.position?.x || 0)
              ) < 100 // Increased alignment tolerance for better tree structure
            ); // Check if somewhat aligned
          });
        } else if (dir === 'right') {
          return currentEdges.some((edge) => {
            const targetNode = currentNodes.find((n) => n.id === edge.target);
            const targetX = targetNode?.position?.x || 0;
            const sourceX = afterNode.position?.x || 0;
            return (
              edge.source === afterNodeId &&
              targetX > sourceX &&
              Math.abs(
                (targetNode?.position?.y || 0) - (afterNode.position?.y || 0)
              ) < 100 // Increased alignment tolerance for better tree structure
            );
          });
        } else if (dir === 'left') {
          return currentEdges.some((edge) => {
            const targetNode = currentNodes.find((n) => n.id === edge.target);
            const targetX = targetNode?.position?.x || 0;
            const sourceX = afterNode.position?.x || 0;
            return (
              edge.source === afterNodeId &&
              targetX < sourceX &&
              Math.abs(
                (targetNode?.position?.y || 0) - (afterNode.position?.y || 0)
              ) < 100 // Increased alignment tolerance for better tree structure
            );
          });
        }
        return false;
      };

      const getFurthestNodePosition = (
        dir: 'below' | 'right' | 'left' | 'middle'
      ): { x: number; y: number } => {
        if (dir === 'middle') {
          return {
            x: afterNode.position?.x || 0,
            y: afterNode.position?.y || 0,
          };
        }

        let furthestNode = afterNode;
        if (dir === 'below') {
          currentEdges.forEach((edge) => {
            if (edge.source === afterNodeId) {
              const targetNode = currentNodes.find((n) => n.id === edge.target);
              if (
                targetNode &&
                (targetNode.position?.y || 0) >
                  (furthestNode.position?.y || 0) &&
                Math.abs(
                  (targetNode.position?.x || 0) - (afterNode.position?.x || 0)
                ) < 100 // Increased tolerance for better tree alignment
              ) {
                furthestNode = targetNode;
              }
            }
          });
        } else if (dir === 'right') {
          currentEdges.forEach((edge) => {
            if (edge.source === afterNodeId) {
              const targetNode = currentNodes.find((n) => n.id === edge.target);
              if (
                targetNode &&
                (targetNode.position?.x || 0) >
                  (furthestNode.position?.x || 0) &&
                Math.abs(
                  (targetNode.position?.y || 0) - (afterNode.position?.y || 0)
                ) < 100 // Increased tolerance for better tree alignment
              ) {
                furthestNode = targetNode;
              }
            }
          });
        } else if (dir === 'left') {
          currentEdges.forEach((edge) => {
            if (edge.source === afterNodeId) {
              const targetNode = currentNodes.find((n) => n.id === edge.target);
              if (
                targetNode &&
                (targetNode.position?.x || 0) <
                  (furthestNode.position?.x || 0) &&
                Math.abs(
                  (targetNode.position?.y || 0) - (afterNode.position?.y || 0)
                ) < 100 // Increased tolerance for better tree alignment
              ) {
                furthestNode = targetNode;
              }
            }
          });
        }
        return {
          x: furthestNode.position?.x || 0,
          y: furthestNode.position?.y || 0,
        };
      };

      // Get the dimensions of the afterNode, or use default values if not measured
      const afterNodeWidth = afterNode.measured?.width || 200; // Default width if not measured
      const afterNodeHeight = afterNode.measured?.height || 60; // Default height if not measured

      // Increase default spacing between nodes for better layout
      const spacing = 150;

      if (hasConnectionInDirection(placementPosition)) {
        const furthestPosition = getFurthestNodePosition(placementPosition);
        // Find the furthest node to get its dimensions
        const furthestNode = currentNodes.find(
          (n) =>
            n.position.x === furthestPosition.x &&
            n.position.y === furthestPosition.y
        );
        const furthestNodeWidth = furthestNode?.measured?.width || 200;
        const furthestNodeHeight = furthestNode?.measured?.height || 60;

        if (placementPosition === 'below') {
          newPosition.x = afterNode.position?.x || 0;
          // Use full node height plus spacing for better vertical separation
          newPosition.y = furthestPosition.y + furthestNodeHeight + spacing;
        } else if (placementPosition === 'right') {
          // Use full node width plus spacing for better horizontal separation
          newPosition.x = furthestPosition.x + furthestNodeWidth + spacing;
          newPosition.y = afterNode.position?.y || 0;
        } else if (placementPosition === 'left') {
          // For left placement, we need to account for the width of the new node
          // Since we don't know it yet, we use a default or the afterNode's width as an estimate
          const estimatedNewNodeWidth = afterNodeWidth; // Use the source node width as estimate
          newPosition.x =
            furthestPosition.x -
            furthestNodeWidth -
            spacing -
            estimatedNewNodeWidth / 2;
          newPosition.y = afterNode.position?.y || 0;
        }
      } else {
        if (placementPosition === 'below') {
          // Use full node height plus spacing for better vertical separation
          newPosition.y += afterNodeHeight + spacing;
        } else if (placementPosition === 'right') {
          // Use full node width plus spacing for better horizontal separation
          newPosition.x += afterNodeWidth + spacing;
        } else if (placementPosition === 'left') {
          // For left placement, estimate the new node width
          const estimatedNewNodeWidth = afterNodeWidth; // Use the source node width as estimate
          newPosition.x -= afterNodeWidth + spacing + estimatedNewNodeWidth / 2;
        }
      }
      // End of existing logic section to be preserved

      const nodeWithPosition: FlowNode = {
        ...newNodeData,
        position: newPosition,
      };

      const newNodes = [...currentNodes, nodeWithPosition];
      updateNodes(newNodes);

      // Create the edge from the source node to the new node
      const newEdge: NodeConnection = {
        id: `edge-${afterNodeId}-${nodeWithPosition.id}`, // afterNodeId will be valid here
        source: afterNodeId,
        target: nodeWithPosition.id,
      };

      // Update the edges
      const newEdges = [...currentEdges, newEdge];
      updateEdges(newEdges);

      return nodeWithPosition;
    },
    [currentNodes, currentEdges, updateNodes, updateEdges, direction]
  );

  // Function to delete a node
  const deleteNode = useCallback(
    (nodeId: string) => {
      const newNodes = currentNodes.filter((node) => node.id !== nodeId);
      updateNodes(newNodes);

      const newEdges = currentEdges.filter(
        (edge) => edge.source !== nodeId && edge.target !== nodeId
      );
      updateEdges(newEdges);

      if (currentSelectedNodeId === nodeId && !isSelectedNodeControlled) {
        setUncontrolledSelectedNodeId(undefined);
      }
    },
    [
      currentNodes,
      currentEdges,
      updateNodes,
      updateEdges,
      currentSelectedNodeId,
      isSelectedNodeControlled,
    ]
  );

  // Function to connect two nodes
  const connectNodes = useCallback(
    (connection: NodeConnection) => {
      const newEdges = [...currentEdges, connection];
      updateEdges(newEdges);
    },
    [currentEdges, updateEdges]
  );

  // Function to update viewport
  const updateViewport = useCallback(
    (newViewport: FlowViewport) => {
      if (!isViewportControlled) {
        setUncontrolledViewport(newViewport);
      }
      if (onViewportChange) {
        onViewportChange(newViewport);
      }
    },
    [isViewportControlled, onViewportChange]
  );

  // Function to zoom in
  const zoomIn = useCallback(() => {
    const newZoom = Math.min(currentViewport.zoom + 0.1, 2); // Limit max zoom to 2x
    updateViewport({
      ...currentViewport,
      zoom: newZoom,
    });
  }, [currentViewport, updateViewport]);

  // Function to zoom out
  const zoomOut = useCallback(() => {
    const newZoom = Math.max(currentViewport.zoom - 0.1, 0.5); // Limit min zoom to 0.5x
    updateViewport({
      ...currentViewport,
      zoom: newZoom,
    });
  }, [currentViewport, updateViewport]);

  // Function to reset viewport
  const resetViewport = useCallback(() => {
    updateViewport({ zoom: 1, x: 0, y: 0 });
  }, [updateViewport]);

  // Function to update a node's position
  const updateNodePosition = useCallback(
    (nodeId: string, newPosition: NodePosition) => {
      const newNodes = currentNodes.map((node) => {
        if (node.id === nodeId) {
          // Create a new node object with the updated position
          return { ...node, position: newPosition };
        }
        return node;
      });
      updateNodes(newNodes);
    },
    [currentNodes, updateNodes]
  );

  // Function to update a node's measured dimensions
  const updateNodeDimensions = useCallback(
    (nodeId: string, dimensions: { width: number; height: number }) => {
      const newNodes = currentNodes.map((node) => {
        if (node.id === nodeId) {
          // Create a new node object with the updated dimensions
          return {
            ...node,
            measured: { ...node.measured, ...dimensions },
          };
        }
        return node;
      });
      updateNodes(newNodes);
    },
    [currentNodes, updateNodes]
  );

  // Function to organize child nodes in a tree structure
  const organizeTreeNodes = useCallback(() => {
    // Create a map of parent nodes to their children
    const parentToChildren: Record<string, FlowNode[]> = {};

    // Identify parent-child relationships from edges
    currentEdges.forEach((edge) => {
      if (!parentToChildren[edge.source]) {
        parentToChildren[edge.source] = [];
      }

      const childNode = currentNodes.find((node) => node.id === edge.target);
      if (childNode) {
        parentToChildren[edge.source].push(childNode);
      }
    });

    // Process each parent node and organize its children
    const processedNodes: FlowNode[] = [...currentNodes];

    Object.keys(parentToChildren).forEach((parentId) => {
      const parentNode = currentNodes.find((node) => node.id === parentId);
      if (!parentNode) return;

      const children = parentToChildren[parentId];
      if (children.length === 0) return;

      // Determine if this is a horizontal or vertical arrangement based on the first child
      const firstChild = children[0];
      const isHorizontal =
        Math.abs(firstChild.position.x - parentNode.position.x) >
        Math.abs(firstChild.position.y - parentNode.position.y);

      if (isHorizontal) {
        // Organize children horizontally
        // Sort children by x position
        const sortedChildren = [...children].sort(
          (a, b) => a.position.x - b.position.x
        );

        // Align all children to the same y as the parent
        sortedChildren.forEach((child) => {
          const index = processedNodes.findIndex((n) => n.id === child.id);
          if (index !== -1) {
            processedNodes[index] = {
              ...processedNodes[index],
              position: {
                ...processedNodes[index].position,
                y: parentNode.position.y,
              },
            };
          }
        });
      } else {
        // Organize children vertically
        // Sort children by y position
        const sortedChildren = [...children].sort(
          (a, b) => a.position.y - b.position.y
        );

        // Align all children to the same x as the parent
        sortedChildren.forEach((child) => {
          const index = processedNodes.findIndex((n) => n.id === child.id);
          if (index !== -1) {
            processedNodes[index] = {
              ...processedNodes[index],
              position: {
                ...processedNodes[index].position,
                x: parentNode.position.x,
              },
            };
          }
        });
      }
    });

    // Update all nodes with their new positions
    updateNodes(processedNodes);
  }, [currentNodes, currentEdges, updateNodes]);

  return {
    baseId,
    nodes: currentNodes,
    edges: currentEdges,
    selectedNodeId: currentSelectedNodeId,
    viewport: currentViewport,
    updateNodes, // Exposing for potential direct manipulation if needed, though usually through actions
    updateEdges, // Exposing for potential direct manipulation
    updateViewport, // Exposing for potential direct manipulation
    selectNode,
    addNode,
    addNodeAfter,
    deleteNode,
    connectNodes,
    updateNodePosition, // New function for drag and drop
    updateNodeDimensions, // New function for measuring node dimensions
    organizeTreeNodes, // New function to organize nodes in a tree structure
    zoomIn,
    zoomOut,
    resetViewport,
  };
};

================
File: src/components/Flow/Flow/Flow.style.ts
================
import { ViewProps } from 'app-studio';
import { Size, Variant } from './Flow.type';

/**
 * Default styles for the Flow component
 */
export const DefaultFlowStyles = {
  container: {
    width: '100%',
    height: '100%',
    position: 'relative', // Required for absolute positioning of edges, controls
    overflow: 'auto', // Changed from hidden to auto to allow scrolling if content overflows
    backgroundColor: 'color.gray.50',
  } as ViewProps,
  node: {
    backgroundColor: 'white',
    borderRadius: 16,
    border: '2px solid',
    borderColor: 'color.gray.300',
    padding: 16, // Base padding, can be overridden by size
    minWidth: 200, // Base minWidth, can be overridden by size
    minHeight: 60, // Ensure minimum height for nodes
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative', // For proper positioning of connections
  } as ViewProps,
  startNode: {
    backgroundColor: 'color.blue.100',
    borderColor: 'color.blue.300',
    borderRadius: 32, // More rounded for start node
  } as ViewProps,
  selectedNode: {
    borderColor: 'color.blue.400',
    boxShadow: '0 0 0 2px color.blue.100', // Use CSS var for theme compatibility
  } as ViewProps,
  edge: {
    // Styles for the SVG path in FlowEdgeView
    stroke: 'color.blue.400',
    strokeWidth: 2.5,
    fill: 'none',
    strokeDasharray: 'none', // Remove any dashes
    strokeLinecap: 'round', // Round the ends of the line
    strokeLinejoin: 'round', // Round the corners
  } as ViewProps,
  edgeArrow: {
    // Styles for the arrow marker in FlowEdgeView
    fill: 'color.blue.400',
  } as ViewProps,
  edgeLabel: {
    // Styles for the label in FlowEdgeView
    backgroundColor: 'white',
    padding: '2px 6px',
    borderRadius: 4,
    fontSize: 12,
    border: '1px solid',
    borderColor: 'color.gray.200',
  } as ViewProps,
  controls: {
    position: 'absolute',
    bottom: 16,
    right: 16,
    display: 'flex',
    gap: 8,
    zIndex: 10, // Ensure controls are above other elements
  } as ViewProps,
  controlButton: {
    width: 32,
    height: 32,
    borderRadius: 16, // Makes it circular
    backgroundColor: 'white',
    border: '1px solid',
    borderColor: 'color.gray.200',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    _hover: {
      backgroundColor: 'color.gray.100',
    },
  } as ViewProps,
  addNodeButton: {
    // For the small '+' buttons
    width: 28,
    height: 28,
    borderRadius: 14, // Makes it circular
    backgroundColor: 'color.blue.100',
    border: '1px solid',
    borderColor: 'color.blue.300',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
    _hover: {
      backgroundColor: 'color.blue.200',
      transform: 'scale(1.1)',
    },
  } as ViewProps,
  nodeContent: {
    // Wrapper for icon and text inside a node
    display: 'flex',
    alignItems: 'center',
    gap: 12,
  } as ViewProps,
  nodeIcon: {
    // Container for the icon in a node
    width: 32,
    height: 32,
    borderRadius: 4,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexShrink: 0, // Prevent icon from shrinking
  } as ViewProps,
  nodeInfo: {
    // Container for label and subtitle
    display: 'flex',
    flexDirection: 'column',
    gap: 2,
    flexGrow: 1, // Allow text to take available space
    overflow: 'hidden', // Prevent long text from breaking layout
  } as ViewProps,
};

/**
 * Size variations for the FlowNodeView component
 * These apply to the node's container.
 */
export const FlowNodeSizes: Record<Size, ViewProps> = {
  sm: {
    fontSize: 12, // Affects text if not overridden
    padding: 12,
    minWidth: 160,
  },
  md: {
    fontSize: 14,
    padding: 16,
    minWidth: 200,
  },
  lg: {
    fontSize: 16,
    padding: 20,
    minWidth: 240,
  },
};

/**
 * Variant styles for the FlowNodeView component
 * These apply to the node's container.
 */
export const FlowNodeVariants: Record<Variant, ViewProps> = {
  default: {
    // Base styles are in DefaultFlowStyles.node
    // This variant doesn't add much beyond default
  },
  outline: {
    borderWidth: 2,
    borderColor: 'color.gray.300', // Slightly stronger border
  },
  filled: {
    backgroundColor: 'color.gray.100', // Node itself is filled
    borderColor: 'color.gray.300',
  },
};

/**
 * Node states (applied to FlowNodeView container)
 */
export const FlowNodeStates = {
  // default state is inherent in DefaultFlowStyles.node
  selected: DefaultFlowStyles.selectedNode, // Reference the one defined above
  hover: {
    borderColor: 'color.gray.300', // Subtle hover effect
    boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)', // Slightly more pronounced shadow
  },
};

================
File: src/components/Flow/Flow/Flow.type.ts
================
import { ViewProps } from 'app-studio';
// Forward declaration for FlowProps to break circular dependency
// The actual FlowProps is defined in Flow.props.ts
// eslint-disable-next-line @typescript-eslint/no-empty-interface
interface FlowPropsPlaceholder {}

/**
 * Size options for FlowNodeView
 */
export type Size = 'sm' | 'md' | 'lg';

/**
 * Variant options for FlowNodeView
 */
export type Variant = 'default' | 'outline' | 'filled';

/**
 * Position of a node in the flow
 */
export interface NodePosition {
  x: number;
  y: number;
}

/**
 * Connection between nodes
 */
export interface NodeConnection {
  /**
   * Unique ID for the connection (edge)
   * Recommended to be `edge-${sourceNodeId}-${targetNodeId}` or similar
   */
  id: string;

  /**
   * Source node ID
   */
  source: string;

  /**
   * Target node ID
   */
  target: string;

  /**
   * Optional label for the connection
   */
  label?: string;

  /**
   * Optional custom styling for the connection (applied to FlowEdgeView path)
   */
  style?: ViewProps;
}

/**
 * Flow node data structure
 */
export interface FlowNode {
  /**
   * Unique identifier for the node
   */
  id: string;

  /**
   * Node type (used for rendering different node types)
   */
  type?: 'default' | 'start' | 'end' | 'decision' | 'process' | string;

  /**
   * Position of the node. Essential for layout in a full flow library.
   */
  position: NodePosition; // Made position mandatory for clarity in a flow context

  /**
   * Measured dimensions of the node after rendering
   * Used for better positioning and edge connections
   */
  measured?: {
    width?: number;
    height?: number;
  };

  /**
   * Data associated with the node
   */
  data?: {
    /**
     * Label text for the node
     */
    label?: string;

    /**
     * Subtitle text for the node
     */
    subtitle?: string;

    /**
     * Optional icon to display
     */
    icon?: React.ReactNode;

    /**
     * Optional number/index for the node
     */
    number?: number;

    /**
     * Any additional data
     */
    [key: string]: any;
  };

  /**
   * Whether the node is selected (typically managed by state, not set directly on node data)
   * This field can be used if nodes are passed with pre-selected state, but `selectedNodeId` prop is preferred.
   */
  selected?: boolean;

  /**
   * Custom styling for the node (applied to FlowNodeView container)
   */
  style?: ViewProps;
}

/**
 * Flow viewport state (relevant for pan and zoom, not used in simplified view)
 */
export interface FlowViewport {
  zoom: number;
  x: number;
  y: number;
}

/**
 * Props for the FlowNodeView component (individual node)
 */
export interface FlowNodeProps extends ViewProps {
  node: FlowNode;
  onSelect?: (nodeId: string) => void;
  isSelected?: boolean;
  size?: Size; // Size prop for individual node styling
  variant?: Variant; // Variant prop for individual node styling
  views?: {
    // Custom views for sub-parts of the node
    container?: ViewProps; // Styles for the node's root View
    content?: ViewProps; // Styles for the Horizontal content wrapper
    icon?: ViewProps; // Styles for the icon View
  };
}

/**
 * Props for the FlowEdgeView component (connection line)
 */
export interface FlowEdgePipedViews {
  container?: ViewProps; // For the root <View> of the edge itself
  labelContainer?: ViewProps; // For the <View> around the edge label text
  labelText?: ViewProps; // For the <Text> of the edge label
  button?: {
    // For the add node button on the edge
    container?: ViewProps;
    icon?: ViewProps;
  };
}

/**
 * Props for the FlowEdgeView component (connection line)
 */
export interface FlowEdgeProps extends ViewProps {
  edge: NodeConnection;
  sourceNode: FlowNode; // Source node for path calculation
  targetNode: FlowNode; // Target node for path calculation
  views?: FlowEdgePipedViews;
  nodeSize?: Size; // To help calculate node dimensions for edge connection
  onAddNode?: (
    sourceNodeId: string,
    position: 'below' | 'right' | 'left' | 'middle',
    edgeId?: string
  ) => void;
  allowAddingNodes?: boolean;
}

/**
 * Props for the FlowControlsView component (zoom/pan buttons)
 */
export interface FlowControlsProps extends ViewProps {
  onZoomIn?: () => void;
  onZoomOut?: () => void;
  onReset?: () => void;
  onOrganize?: () => void; // New prop for organizing nodes in a tree structure
  views?: {
    container?: ViewProps;
    button?: ViewProps;
    // controls?: ViewProps; // This seems redundant if 'container' is for the whole controls group
  };
}

/**
 * Props for the FlowAddNodeButtonView component (the small '+' button)
 */
export interface FlowAddNodeButtonProps extends Omit<ViewProps, 'position'> {
  // HTML position attribute
  onClick?: () => void;
  /**
   * Visual position relative to the element it's attached to (for styling hints, not layout)
   */
  attachmentPosition?: 'top' | 'right' | 'bottom' | 'left';
  views?: {
    container?: ViewProps;
    icon?: ViewProps;
  };
}

/**
 * Flow component type with sub-components.
 * P represents the props of the main Flow component (e.g., FlowProps).
 */
export interface FlowComponentType<P = FlowPropsPlaceholder>
  extends React.FC<P> {
  Node: React.FC<FlowNodeProps>;
  Edge: React.FC<FlowEdgeProps>; // Placeholder, not fully implemented
  Controls: React.FC<FlowControlsProps>;
  AddNodeButton: React.FC<FlowAddNodeButtonProps>;
}

================
File: src/components/Flow/Flow/Flow.view.tsx
================
import React from 'react';
import { View, Text, ViewProps, Horizontal } from 'app-studio';
import { PlusIcon, MinusIcon, RefreshIcon } from '../../Icon/Icon'; // Assuming Icon components are correctly pathed

import {
  FlowNode as FlowNodeType, // Renamed to avoid conflict with component name
  NodeConnection,
  FlowNodeProps,
  FlowEdgeProps,
  FlowControlsProps,
  FlowAddNodeButtonProps,
  FlowViewport,
  NodePosition,
} from './Flow.type';
import { FlowProps } from './Flow.props'; // For picking props for InternalFlowViewProps

import {
  DefaultFlowStyles,
  FlowNodeSizes,
  FlowNodeVariants,
  FlowNodeStates,
} from './Flow.style';

// Flow Node component
export const FlowNodeView: React.FC<
  FlowNodeProps & {
    // Add new props for drag and drop and dimensions
    onNodeDrag?: (nodeId: string, newPosition: NodePosition) => void;
    onNodeDimensionsChange?: (
      nodeId: string,
      dimensions: { width: number; height: number }
    ) => void;
    viewportZoom?: number;
  }
> = ({
  node,
  onSelect,
  isSelected,
  size = 'md',
  variant = 'default',
  views,
  onNodeDrag,
  onNodeDimensionsChange,
  viewportZoom = 1,
  ...props
}) => {
  // State for tracking drag operations
  const [isDragging, setIsDragging] = React.useState(false);
  const dragStartRef = React.useRef<{
    x: number;
    y: number;
    nodeX: number;
    nodeY: number;
  } | null>(null);

  // Reference for the node element to measure dimensions
  const nodeRef = React.useRef<HTMLDivElement>(null);

  const handleClick = () => {
    if (onSelect) {
      onSelect(node.id);
    }
  };

  // Handle mouse down to start dragging
  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.button !== 0 || !onNodeDrag) return; // Only left mouse button and if drag is enabled

    e.preventDefault();
    e.stopPropagation(); // Prevent panning the viewport when dragging a node

    setIsDragging(true);
    dragStartRef.current = {
      x: e.clientX,
      y: e.clientY,
      nodeX: node.position.x,
      nodeY: node.position.y,
    };

    // Add global event listeners for mouse move and up
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  // Handle mouse move during drag
  const handleMouseMove = (e: MouseEvent) => {
    if (!isDragging || !dragStartRef.current || !onNodeDrag) return;

    // Calculate the delta, adjusting for viewport zoom
    const dx = (e.clientX - dragStartRef.current.x) / viewportZoom;
    const dy = (e.clientY - dragStartRef.current.y) / viewportZoom;

    // Update the node position
    onNodeDrag(node.id, {
      x: dragStartRef.current.nodeX + dx,
      y: dragStartRef.current.nodeY + dy,
    });
  };

  // Handle mouse up to end dragging
  const handleMouseUp = () => {
    setIsDragging(false);
    dragStartRef.current = null;

    // Remove global event listeners
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  };

  // Use ResizeObserver to measure node dimensions
  React.useLayoutEffect(() => {
    if (nodeRef.current && onNodeDimensionsChange) {
      const observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const { width, height } = entry.contentRect;
          // Only update if dimensions have changed
          if (
            node.measured?.width !== width ||
            node.measured?.height !== height
          ) {
            onNodeDimensionsChange(node.id, { width, height });
          }
        }
      });

      observer.observe(nodeRef.current);

      // Clean up observer on unmount
      return () => observer.disconnect();
    }

    // Return empty cleanup function when conditions aren't met
    return () => {};
  }, [
    node.id,
    onNodeDimensionsChange,
    node.measured?.width,
    node.measured?.height,
  ]);

  const nodeSpecificStyles = {
    ...FlowNodeSizes[size],
    ...FlowNodeVariants[variant],
  };

  // Apply specific styles based on node type
  const nodeTypeStyles = (() => {
    switch (node.type) {
      case 'start':
        return DefaultFlowStyles.startNode;
      default:
        return {};
    }
  })();

  // Simplified content for flowchart-style nodes
  const renderNodeContent = () => {
    // If node has no data or label, render an empty node
    if (!node.data || !node.data.label) {
      return null;
    }

    return (
      <Horizontal {...DefaultFlowStyles.nodeContent} {...views?.content}>
        {node.data?.icon && (
          <View {...DefaultFlowStyles.nodeIcon} {...views?.icon}>
            {node.data.icon}
          </View>
        )}
        <View {...DefaultFlowStyles.nodeInfo}>
          <Horizontal gap={4} alignItems="center" justifyContent="center">
            {node.data?.number != null && ( // Check for null/undefined
              <Text fontWeight="bold">{node.data.number}. </Text>
            )}
            <Text fontWeight="bold" textAlign="center">
              {node.data?.label}
            </Text>
          </Horizontal>
          {node.data?.subtitle && (
            <Text color="color.gray.500" fontSize="sm" textAlign="center">
              {node.data.subtitle}
            </Text>
          )}
        </View>
      </Horizontal>
    );
  };

  return (
    <View
      ref={nodeRef}
      {...DefaultFlowStyles.node}
      {...nodeSpecificStyles}
      {...nodeTypeStyles}
      {...(isSelected ? FlowNodeStates.selected : {})}
      onClick={handleClick}
      onMouseDown={handleMouseDown}
      cursor={isDragging ? 'grabbing' : onNodeDrag ? 'grab' : 'pointer'}
      _hover={FlowNodeStates.hover} // Apply hover state styles
      {...node.style} // Apply per-node custom style
      {...views?.container}
      {...props} // Allow overriding all styles via props
    >
      {renderNodeContent()}
    </View>
  );
};

// Flow Edge component
export const FlowEdgeView: React.FC<FlowEdgeProps> = ({
  edge,
  sourceNode,
  targetNode,
  views,
  nodeSize = 'md',
  onAddNode,
  allowAddingNodes = true,
  ...props
}) => {
  if (!sourceNode || !targetNode) {
    return null;
  }

  const sourceX = sourceNode.position.x;
  const sourceY = sourceNode.position.y;
  const targetX = targetNode.position.x;
  const targetY = targetNode.position.y;

  const isHorizontal =
    Math.abs(targetX - sourceX) > Math.abs(targetY - sourceY);

  const lineColor = 'color.blue.500';
  const lineThickness = 1;

  const handleAddNodeInMiddle = () => {
    if (onAddNode) {
      onAddNode(edge.source, 'middle', edge.id);
    }
  };

  const midX = (sourceX + targetX) / 2;
  const midY = (sourceY + targetY) / 2;

  if (isHorizontal) {
    const direction = targetX > sourceX ? 1 : -1;

    return (
      <View
        position="absolute"
        pointerEvents="none"
        {...views?.container}
        {...props}
      >
        {/* Horizontal line from source to midpoint */}
        <View
          position="absolute"
          left={sourceX}
          top={sourceY}
          width={Math.abs(midX - sourceX)}
          height={lineThickness}
          backgroundColor={lineColor}
          style={{
            transform: `translateX(${direction > 0 ? 0 : -100}%)`,
          }}
        />
        {/* Vertical line at midpoint */}
        <View
          position="absolute"
          left={midX}
          top={Math.min(sourceY, targetY)}
          width={lineThickness}
          height={Math.abs(targetY - sourceY)}
          backgroundColor={lineColor}
        />
        {/* Horizontal line from midpoint to target */}
        <View
          position="absolute"
          left={midX}
          top={targetY}
          width={Math.abs(targetX - midX)}
          height={lineThickness}
          backgroundColor={lineColor}
          style={{
            transform: `translateX(${direction > 0 ? 0 : -100}%)`,
          }}
        />

        {/* Add Node Button in the middle of the horizontal connection */}
        {allowAddingNodes && onAddNode && (
          <View
            position="absolute"
            left={midX}
            top={midY}
            transform="translate(-50%, -50%)"
            zIndex={5}
            pointerEvents="auto"
          >
            <FlowAddNodeButtonView
              onClick={() => onAddNode(edge.source, 'middle', edge.id)}
              aria-label={`Add node between ${
                sourceNode.data?.label || sourceNode.id
              } and ${targetNode.data?.label || targetNode.id}`}
              views={views?.button}
            />
          </View>
        )}

        {edge.label && (
          <View
            position="absolute"
            left={midX}
            top={midY}
            transform="translate(-50%, -50%)"
            backgroundColor="white"
            padding={2}
            borderRadius={4}
            border="1px solid"
            borderColor="color.gray.200"
            zIndex={10}
            {...views?.labelContainer}
          >
            <Text fontSize="xs" textAlign="center" {...views?.labelText}>
              {edge.label}
            </Text>
          </View>
        )}
      </View>
    );
  } else {
    // For vertical connections
    const direction = targetY > sourceY ? 1 : -1;

    return (
      <View
        position="absolute"
        pointerEvents="none"
        {...views?.container}
        {...props}
      >
        {/* Vertical line from source to midpoint */}
        <View
          position="absolute"
          left={sourceX}
          top={sourceY}
          width={lineThickness}
          height={Math.abs(midY - sourceY)}
          backgroundColor={lineColor}
          style={{
            transform: `translateY(${direction > 0 ? 0 : -100}%)`,
          }}
        />
        {/* Horizontal line at midpoint */}
        <View
          position="absolute"
          left={Math.min(sourceX, targetX)}
          top={midY}
          width={Math.abs(targetX - sourceX)}
          height={lineThickness}
          backgroundColor={lineColor}
        />
        {/* Vertical line from midpoint to target */}
        <View
          position="absolute"
          left={targetX}
          top={midY}
          width={lineThickness}
          height={Math.abs(targetY - midY)}
          backgroundColor={lineColor}
          style={{
            transform: `translateY(${direction > 0 ? 0 : -100}%)`,
          }}
        />

        {/* Add Node Button in the middle of the vertical connection */}
        {allowAddingNodes && onAddNode && (
          <View
            position="absolute"
            left={midX}
            top={midY}
            transform="translate(-50%, -50%)"
            zIndex={5}
            pointerEvents="auto"
          >
            <FlowAddNodeButtonView
              onClick={handleAddNodeInMiddle}
              aria-label={`Add node between ${
                sourceNode.data?.label || sourceNode.id
              } and ${targetNode.data?.label || targetNode.id}`}
              views={views?.button}
            />
          </View>
        )}

        {edge.label && (
          <View
            position="absolute"
            left={midX}
            top={midY}
            transform="translate(-50%, -50%)"
            backgroundColor="white"
            padding={2}
            borderRadius={4}
            border="1px solid"
            borderColor="color.gray.200"
            zIndex={10}
            {...views?.labelContainer}
          >
            <Text fontSize="xs" textAlign="center" {...views?.labelText}>
              {edge.label}
            </Text>
          </View>
        )}
      </View>
    );
  }
};

// Flow Controls component
export const FlowControlsView: React.FC<FlowControlsProps> = ({
  onZoomIn,
  onZoomOut,
  onReset,
  onOrganize,
  views,
  ...props
}) => {
  return (
    <View
      {...DefaultFlowStyles.controls} // Base styles for the container
      {...views?.container} // Custom styles for the container
      {...props} // Allow overriding all styles via props
    >
      <View
        as="button" // Make it a button for accessibility
        aria-label="Zoom In"
        {...DefaultFlowStyles.controlButton}
        onClick={onZoomIn}
        {...views?.button} // Custom styles for individual buttons
      >
        <PlusIcon size={16} />
      </View>
      <View
        as="button"
        aria-label="Zoom Out"
        {...DefaultFlowStyles.controlButton}
        onClick={onZoomOut}
        {...views?.button}
      >
        <MinusIcon size={16} />
      </View>
      <View
        as="button"
        aria-label="Reset View"
        {...DefaultFlowStyles.controlButton}
        onClick={onReset}
        {...views?.button}
      >
        <RefreshIcon size={16} />
      </View>
      {onOrganize && (
        <View
          as="button"
          aria-label="Organize Tree"
          {...DefaultFlowStyles.controlButton}
          onClick={onOrganize}
          {...views?.button}
          title="Organize nodes in a tree structure"
        >
          <Text fontSize="xs" fontWeight="bold">
            Tree
          </Text>
        </View>
      )}
    </View>
  );
};

// Flow Add Node Button component
export const FlowAddNodeButtonView: React.FC<FlowAddNodeButtonProps> = ({
  onClick,
  // attachmentPosition = 'bottom', // This prop is for styling hints, not direct layout
  views,
  ...props
}) => {
  return (
    <View
      as="button" // Make it a button for accessibility
      aria-label="Add Node"
      {...DefaultFlowStyles.addNodeButton}
      onClick={onClick}
      {...views?.container}
      {...props} // Allow overriding all styles via props
    >
      <PlusIcon size={16} color="color.blue.600" {...views?.icon} />
    </View>
  );
};

// Define props for the main FlowView component
interface InternalFlowViewProps
  extends Pick<
      FlowProps,
      | 'size'
      | 'variant'
      | 'direction'
      | 'showControls'
      | 'allowAddingNodes'
      | 'views'
    >,
    Omit<
      ViewProps,
      keyof Pick<
        FlowProps,
        | 'size'
        | 'variant'
        | 'direction'
        | 'showControls'
        | 'allowAddingNodes'
        | 'views'
      >
    > {
  nodes: FlowNodeType[];
  edges: NodeConnection[]; // Edges are passed but not rendered effectively by this simplified view
  selectedNodeId?: string;
  onNodeSelect: (nodeId: string) => void;
  onAddNode: (
    afterNodeId: string,
    position?: 'below' | 'right' | 'left' | 'middle',
    edgeId?: string
  ) => void;
  baseId: string;
  viewport?: FlowViewport;
  onZoomIn?: () => void;
  onZoomOut?: () => void;
  onReset?: () => void;
  onViewportChange?: (viewport: FlowViewport) => void;
  // New props for node drag and drop and dimensions
  onNodePositionChange?: (nodeId: string, newPosition: NodePosition) => void;
  onNodeDimensionsChange?: (
    nodeId: string,
    dimensions: { width: number; height: number }
  ) => void;
  // New prop for organizing nodes in a tree structure
  onOrganize?: () => void;
}

// Main Flow View component
export const FlowView: React.FC<InternalFlowViewProps> = ({
  nodes = [], // Default to empty array
  edges = [], // Default to empty array, not visually used much in this simplified view
  selectedNodeId,
  onNodeSelect,
  onAddNode, // Callback to request adding a node
  size = 'md',
  variant = 'default',
  direction,
  // direction = 'vertical', // direction prop influences state logic, not directly this view's layout
  showControls = true,
  allowAddingNodes = true,
  views = {},
  baseId,
  viewport = { zoom: 1, x: 0, y: 0 },
  onZoomIn,
  onZoomOut,
  onReset,
  onViewportChange,
  // New props for node drag and drop and dimensions
  onNodePositionChange,
  onNodeDimensionsChange,
  // New prop for organizing nodes in a tree structure
  onOrganize,
  ...props
}) => {
  // NOTE: This is a simplified layout. For 'left'/'right' node additions to be visually accurate,
  // and for edges to render correctly, a proper layout engine (like react-flow/xyflow)
  // that respects node.position and calculates edge paths is needed.
  // The current view primarily stacks nodes vertically. Node positions (x,y) from state are not used for rendering here.

  // State for tracking mouse drag
  const [isDragging, setIsDragging] = React.useState(false);
  const [dragStart, setDragStart] = React.useState({ x: 0, y: 0 });
  const [viewportAtDragStart, setViewportAtDragStart] = React.useState({
    x: 0,
    y: 0,
  });

  // Reference to the container element for keyboard focus
  const containerRef = React.useRef<HTMLDivElement>(null);

  // Handle mouse down for dragging
  const handleMouseDown = (e: React.MouseEvent) => {
    // Only enable dragging with middle mouse button or when holding space key
    if (e.button === 1 || e.altKey) {
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
      setViewportAtDragStart({ x: viewport.x, y: viewport.y });
      e.preventDefault();
    }
  };

  // Handle mouse move for dragging
  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging) {
      const dx = (e.clientX - dragStart.x) / viewport.zoom;
      const dy = (e.clientY - dragStart.y) / viewport.zoom;

      // Update viewport position
      const newViewport = {
        ...viewport,
        x: viewportAtDragStart.x + dx,
        y: viewportAtDragStart.y + dy,
      };

      // Call the viewport update function
      handleViewportChange(newViewport);

      e.preventDefault();
    }
  };

  // Handle mouse up to end dragging
  const handleMouseUp = () => {
    if (isDragging) {
      setIsDragging(false);
    }
  };

  // Handle mouse wheel for zooming
  const handleWheel = (e: React.WheelEvent) => {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();

      // Determine zoom direction
      const zoomFactor = e.deltaY < 0 ? 0.1 : -0.1;
      const newZoom = Math.max(0.1, Math.min(2, viewport.zoom + zoomFactor));

      // Update viewport zoom
      const newViewport = {
        ...viewport,
        zoom: newZoom,
      };

      // Call the viewport update function
      handleViewportChange(newViewport);
    }
  };

  // Handle keyboard navigation
  const handleKeyDown = (e: React.KeyboardEvent) => {
    const panStep = 20 / viewport.zoom; // Adjust step size based on zoom level
    let newX = viewport.x;
    let newY = viewport.y;

    switch (e.key) {
      case 'ArrowUp':
        newY += panStep;
        break;
      case 'ArrowDown':
        newY -= panStep;
        break;
      case 'ArrowLeft':
        newX += panStep;
        break;
      case 'ArrowRight':
        newX -= panStep;
        break;
      case '0': // Reset view with '0' key
        if (onReset) {
          onReset();
          return;
        }
        break;
      case '+': // Zoom in with '+' key
        if (onZoomIn) {
          onZoomIn();
          return;
        }
        break;
      case '-': // Zoom out with '-' key
        if (onZoomOut) {
          onZoomOut();
          return;
        }
        break;
      default:
        return; // Exit if not a navigation key
    }

    // Update viewport position
    const newViewport = {
      ...viewport,
      x: newX,
      y: newY,
    };

    // Call the viewport update function
    handleViewportChange(newViewport);
    e.preventDefault();
  };

  // Function to handle viewport changes
  const handleViewportChange = (newViewport: FlowViewport) => {
    // We need to pass this to the parent component
    if (onViewportChange) {
      onViewportChange(newViewport);
    }
    // else {
    //   // If no onViewportChange is provided, we can try to use the zoom functions
    //   if (onZoomIn && onZoomOut && onReset) {
    //     const currentZoom = viewport.zoom;

    //     if (newViewport.zoom > currentZoom) {
    //       onZoomIn();
    //     } else if (newViewport.zoom < currentZoom) {
    //       onZoomOut();
    //     } else if (
    //       newViewport.x !== viewport.x ||
    //       newViewport.y !== viewport.y
    //     ) {
    //       // This is a pan operation, but we don't have direct access to updateViewport
    //       // We'll just use the zoom functions to approximate the behavior
    //       onReset(); // This is not ideal, but it's the best we can do without updateViewport
    //     }
    //   }
    // }
  };

  const handleAddNode = (
    sourceNodeId: string,
    pos: 'below' | 'left' | 'right' | 'middle',
    edgeId?: string
  ) => {
    if (onAddNode) {
      onAddNode(sourceNodeId, pos, edgeId);
    }
  };

  return (
    <View
      id={baseId}
      role="application"
      aria-label="Flow diagram"
      ref={containerRef}
      tabIndex={0} // Make the container focusable for keyboard navigation
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp} // Also stop dragging if mouse leaves the container
      onWheel={handleWheel}
      onKeyDown={handleKeyDown}
      cursor={isDragging ? 'grabbing' : 'default'}
      {...DefaultFlowStyles.container}
      {...views.container}
      {...props}
    >
      {/* SVG layer for edges */}
      <View
        position="absolute"
        top={0}
        left={0}
        width="100%"
        height="100%"
        zIndex={1}
        transform={`scale(${viewport.zoom}) translate(${viewport.x}px, ${viewport.y}px)`}
        transformOrigin="center"
        transition="transform 0.2s ease"
        style={{ pointerEvents: 'none' }} // Don't intercept pointer events
      >
        {edges.map((edge) => {
          const sourceNode = nodes.find((n) => n.id === edge.source);
          const targetNode = nodes.find((n) => n.id === edge.target);

          if (sourceNode && targetNode) {
            return (
              <FlowEdgeView
                key={edge.id}
                edge={edge}
                sourceNode={sourceNode}
                targetNode={targetNode}
                views={views.edge}
                nodeSize={size}
                onAddNode={onAddNode}
                allowAddingNodes={allowAddingNodes}
              />
            );
          }
          return null;
        })}
      </View>

      {/* Nodes layer */}
      <View
        position="relative"
        width="100%"
        height="100%"
        zIndex={2}
        transform={`scale(${viewport.zoom}) translate(${viewport.x}px, ${viewport.y}px)`}
        transformOrigin="center"
        transition="transform 0.2s ease"
      >
        {nodes.map((node) => (
          <View
            key={node.id}
            position="absolute"
            top={node.position.y}
            left={node.position.x}
            transform="translate(-50%, -50%)" // Center the node on its position
          >
            {/* Node */}
            <FlowNodeView
              node={node}
              isSelected={selectedNodeId === node.id}
              onSelect={onNodeSelect}
              size={size}
              variant={variant}
              views={views.node}
              onNodeDrag={onNodePositionChange}
              onNodeDimensionsChange={onNodeDimensionsChange}
              viewportZoom={viewport.zoom}
            />
            {allowAddingNodes && (
              <View width={'100%'} height={'100%'}>
                {/* Below Add Button */}
                <View
                  position="absolute"
                  bottom="-20%"
                  left="50%"
                  transform="translate(-50%, 0%)"
                  zIndex={5}
                >
                  <FlowAddNodeButtonView
                    onClick={() => handleAddNode(node.id, 'below')}
                    views={views.addButton}
                    aria-label={`Add node below ${node.data?.label || node.id}`}
                  />
                </View>

                {/* Left Add Button */}
                <View
                  position="absolute"
                  left="0%"
                  top="50%"
                  transform="translate(-50%, -50%)"
                  zIndex={5}
                >
                  <FlowAddNodeButtonView
                    onClick={() => handleAddNode(node.id, 'left')}
                    views={views.addButton}
                    aria-label={`Add node left of ${
                      node.data?.label || node.id
                    }`}
                  />
                </View>

                {/* Right Add Button */}
                <View
                  position="absolute"
                  right="0%"
                  top="50%"
                  transform="translate(50%, -50%)"
                  zIndex={5}
                >
                  <FlowAddNodeButtonView
                    onClick={() => handleAddNode(node.id, 'right')}
                    views={views.addButton}
                    aria-label={`Add node right of ${
                      node.data?.label || node.id
                    }`}
                  />
                </View>
              </View>
            )}
          </View>
        ))}

        {/* Add first node button if no nodes exist */}
        {allowAddingNodes && nodes.length === 0 && (
          <View
            position="absolute"
            top="50%"
            left="50%"
            transform="translate(-50%, -50%)"
          >
            <FlowAddNodeButtonView
              onClick={() => handleAddNode(undefined as any, 'middle')}
              aria-label="Add first node"
              views={views.addButton}
            />
          </View>
        )}
      </View>

      {/* Fixed Controls - Always visible regardless of viewport position */}
      {showControls && (
        <View
          position="absolute"
          top={40}
          right={40}
          zIndex={1000}
          display="flex"
          flexDirection="column"
          gap={8}
          backgroundColor="white"
          padding={4}
          borderRadius={8}
          boxShadow="0 2px 8px rgba(0, 0, 0, 0.15)"
          border="1px solid"
          borderColor="color.gray.200"
          pointerEvents="auto" // Ensure controls are clickable
          {...views?.fixedControlsContainer}
        >
          <FlowControlsView
            onZoomIn={onZoomIn}
            onZoomOut={onZoomOut}
            onReset={onReset}
            onOrganize={onOrganize}
            views={views.controls}
          />
        </View>
      )}

      {/* Display current zoom level */}
      <View
        position="absolute"
        bottom={16}
        left={16}
        backgroundColor="white"
        padding={2}
        borderRadius={4}
        fontSize="xs"
        border="1px solid"
        borderColor="color.gray.200"
        zIndex={1000}
        pointerEvents="none" // Don't intercept pointer events
      >
        <Text fontSize="xs">Zoom: {Math.round(viewport.zoom * 100)}%</Text>
      </View>
    </View>
  );
};




================================================================
End of Codebase
================================================================
